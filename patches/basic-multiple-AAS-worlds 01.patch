Index: code/botlib/aasfile.h
===================================================================
--- code/botlib/aasfile.h	(revision 1306)
+++ code/botlib/aasfile.h	(working copy)
@@ -29,7 +29,6 @@
 //			   default long
 
 #define AASID (('S' << 24) + ('A' << 16) + ('A' << 8) + 'E')
-#define AASVERSION_OLD 4
 #define AASVERSION 5
 // presence types
 #define PRESENCE_NONE	1
@@ -153,6 +152,8 @@
 	int clusterareanum;		// number of the area in the cluster
 	int numreachableareas;	// number of reachable areas from this one
 	int firstreachablearea;	// first reachable area in the reachable area index
+	// add a ground steepness stat, so we can avoid terrain when we can take a close-by flat route
+	float groundsteepness;	// 0 = flat, 1 = steep
 } aas_areasettings_t;
 // cluster portal
 typedef struct aas_portal_s {
Index: code/botlib/be_aas.h
===================================================================
--- code/botlib/be_aas.h	(revision 1306)
+++ code/botlib/be_aas.h	(working copy)
@@ -28,6 +28,7 @@
  Area Awareness System, stuff exported to the AI.
 **************************************************************************************************************************************/
 
+#define MAX_AAS_WORLDS 2 // one for each bounding box type
 #define MAX_EPAIRKEY 128
 #ifndef MAX_STRINGFIELD
 #define MAX_STRINGFIELD 80
Index: code/botlib/be_aas_cluster.c
===================================================================
--- code/botlib/be_aas_cluster.c	(revision 1306)
+++ code/botlib/be_aas_cluster.c	(working copy)
@@ -59,8 +59,8 @@
 void AAS_RemoveClusterAreas(void) {
 	int i;
 
-	for (i = 1; i < aasworld.numareas; i++) {
-		aasworld.areasettings[i].cluster = 0;
+	for (i = 1; i < (*aasworld).numareas; i++) {
+		(*aasworld).areasettings[i].cluster = 0;
 	}
 }
 
@@ -72,9 +72,9 @@
 void AAS_ClearCluster(int clusternum) {
 	int i;
 
-	for (i = 1; i < aasworld.numareas; i++) {
-		if (aasworld.areasettings[i].cluster == clusternum) {
-			aasworld.areasettings[i].cluster = 0;
+	for (i = 1; i < (*aasworld).numareas; i++) {
+		if ((*aasworld).areasettings[i].cluster == clusternum) {
+			(*aasworld).areasettings[i].cluster = 0;
 		}
 	}
 }
@@ -87,13 +87,13 @@
 void AAS_RemovePortalsClusterReference(int clusternum) {
 	int portalnum;
 
-	for (portalnum = 1; portalnum < aasworld.numportals; portalnum++) {
-		if (aasworld.portals[portalnum].frontcluster == clusternum) {
-			aasworld.portals[portalnum].frontcluster = 0;
+	for (portalnum = 1; portalnum < (*aasworld).numportals; portalnum++) {
+		if ((*aasworld).portals[portalnum].frontcluster == clusternum) {
+			(*aasworld).portals[portalnum].frontcluster = 0;
 		}
 
-		if (aasworld.portals[portalnum].backcluster == clusternum) {
-			aasworld.portals[portalnum].backcluster = 0;
+		if ((*aasworld).portals[portalnum].backcluster == clusternum) {
+			(*aasworld).portals[portalnum].backcluster = 0;
 		}
 	}
 }
@@ -109,18 +109,18 @@
 	aas_cluster_t *cluster;
 
 	// find the portal of the area
-	for (portalnum = 1; portalnum < aasworld.numportals; portalnum++) {
-		if (aasworld.portals[portalnum].areanum == areanum) {
+	for (portalnum = 1; portalnum < (*aasworld).numportals; portalnum++) {
+		if ((*aasworld).portals[portalnum].areanum == areanum) {
 			break;
 		}
 	}
 
-	if (portalnum == aasworld.numportals) {
+	if (portalnum == (*aasworld).numportals) {
 		AAS_Error("no portal of area %d\n", areanum);
 		return qtrue;
 	}
 
-	portal = &aasworld.portals[portalnum];
+	portal = &(*aasworld).portals[portalnum];
 	// if the portal is already fully updated
 	if (portal->frontcluster == clusternum) {
 		return qtrue;
@@ -137,21 +137,21 @@
 		portal->backcluster = clusternum;
 	} else {
 		// remove the cluster portal flag contents
-		aasworld.areasettings[areanum].contents &= ~AREACONTENTS_CLUSTERPORTAL;
+		(*aasworld).areasettings[areanum].contents &= ~AREACONTENTS_CLUSTERPORTAL;
 		Log_Write("portal area %d is separating more than two clusters\r\n", areanum);
 		return qfalse;
 	}
 
-	if (aasworld.portalindexsize >= AAS_MAX_PORTALINDEXSIZE) {
+	if ((*aasworld).portalindexsize >= AAS_MAX_PORTALINDEXSIZE) {
 		AAS_Error("AAS_MAX_PORTALINDEXSIZE\n");
 		return qtrue;
 	}
 	// set the area cluster number to the negative portal number
-	aasworld.areasettings[areanum].cluster = -portalnum;
+	(*aasworld).areasettings[areanum].cluster = -portalnum;
 	// add the portal to the cluster using the portal index
-	cluster = &aasworld.clusters[clusternum];
-	aasworld.portalindex[cluster->firstportal + cluster->numportals] = portalnum;
-	aasworld.portalindexsize++;
+	cluster = &(*aasworld).clusters[clusternum];
+	(*aasworld).portalindex[cluster->firstportal + cluster->numportals] = portalnum;
+	(*aasworld).portalindexsize++;
 	cluster->numportals++;
 	return qtrue;
 }
@@ -166,35 +166,35 @@
 	aas_face_t *face;
 	int facenum, i;
 
-	if (areanum <= 0 || areanum >= aasworld.numareas) {
+	if (areanum <= 0 || areanum >= (*aasworld).numareas) {
 		AAS_Error("AAS_FloodClusterAreas_r: areanum out of range\n");
 		return qfalse;
 	}
 	// if the area is already part of a cluster
-	if (aasworld.areasettings[areanum].cluster > 0) {
-		if (aasworld.areasettings[areanum].cluster == clusternum) {
+	if ((*aasworld).areasettings[areanum].cluster > 0) {
+		if ((*aasworld).areasettings[areanum].cluster == clusternum) {
 			return qtrue;
 		}
 		// there's a reachability going from one cluster to another only in one direction
-		AAS_Error("cluster %d touched cluster %d at area %d\n", clusternum, aasworld.areasettings[areanum].cluster, areanum);
+		AAS_Error("cluster %d touched cluster %d at area %d\n", clusternum, (*aasworld).areasettings[areanum].cluster, areanum);
 		return qfalse;
 	}
 	// don't add the cluster portal areas to the clusters
-	if (aasworld.areasettings[areanum].contents & AREACONTENTS_CLUSTERPORTAL) {
+	if ((*aasworld).areasettings[areanum].contents & AREACONTENTS_CLUSTERPORTAL) {
 		return AAS_UpdatePortal(areanum, clusternum);
 	}
 	// set the area cluster number
-	aasworld.areasettings[areanum].cluster = clusternum;
-	aasworld.areasettings[areanum].clusterareanum = aasworld.clusters[clusternum].numareas;
+	(*aasworld).areasettings[areanum].cluster = clusternum;
+	(*aasworld).areasettings[areanum].clusterareanum = (*aasworld).clusters[clusternum].numareas;
 	// the cluster has an extra area
-	aasworld.clusters[clusternum].numareas++;
+	(*aasworld).clusters[clusternum].numareas++;
 
-	area = &aasworld.areas[areanum];
+	area = &(*aasworld).areas[areanum];
 	// use area faces to flood into adjacent areas
 	if (!nofaceflood) {
 		for (i = 0; i < area->numfaces; i++) {
-			facenum = abs(aasworld.faceindex[area->firstface + i]);
-			face = &aasworld.faces[facenum];
+			facenum = abs((*aasworld).faceindex[area->firstface + i]);
+			face = &(*aasworld).faces[facenum];
 
 			if (face->frontarea == areanum) {
 				if (face->backarea) {
@@ -212,12 +212,12 @@
 		}
 	}
 	// use the reachabilities to flood into other areas
-	for (i = 0; i < aasworld.areasettings[areanum].numreachableareas; i++) {
-		if (!aasworld.reachability[aasworld.areasettings[areanum].firstreachablearea + i].areanum) {
+	for (i = 0; i < (*aasworld).areasettings[areanum].numreachableareas; i++) {
+		if (!(*aasworld).reachability[(*aasworld).areasettings[areanum].firstreachablearea + i].areanum) {
 			continue;
 		}
 
-		if (!AAS_FloodClusterAreas_r(aasworld.reachability[aasworld.areasettings[areanum].firstreachablearea + i].areanum, clusternum)) {
+		if (!AAS_FloodClusterAreas_r((*aasworld).reachability[(*aasworld).areasettings[areanum].firstreachablearea + i].areanum, clusternum)) {
 			return qfalse;
 		}
 	}
@@ -235,25 +235,25 @@
 int AAS_FloodClusterAreasUsingReachabilities(int clusternum) {
 	int i, j, areanum;
 
-	for (i = 1; i < aasworld.numareas; i++) {
+	for (i = 1; i < (*aasworld).numareas; i++) {
 		// if this area already has a cluster set
-		if (aasworld.areasettings[i].cluster) {
+		if ((*aasworld).areasettings[i].cluster) {
 			continue;
 		}
 		// if this area is a cluster portal
-		if (aasworld.areasettings[i].contents & AREACONTENTS_CLUSTERPORTAL) {
+		if ((*aasworld).areasettings[i].contents & AREACONTENTS_CLUSTERPORTAL) {
 			continue;
 		}
 		// loop over the reachable areas from this area
-		for (j = 0; j < aasworld.areasettings[i].numreachableareas; j++) {
+		for (j = 0; j < (*aasworld).areasettings[i].numreachableareas; j++) {
 			// the reachable area
-			areanum = aasworld.reachability[aasworld.areasettings[i].firstreachablearea + j].areanum;
+			areanum = (*aasworld).reachability[(*aasworld).areasettings[i].firstreachablearea + j].areanum;
 			// if this area is a cluster portal
-			if (aasworld.areasettings[areanum].contents & AREACONTENTS_CLUSTERPORTAL) {
+			if ((*aasworld).areasettings[areanum].contents & AREACONTENTS_CLUSTERPORTAL) {
 				continue;
 			}
 			// if this area has a cluster set
-			if (aasworld.areasettings[areanum].cluster) {
+			if ((*aasworld).areasettings[areanum].cluster) {
 				if (!AAS_FloodClusterAreas_r(i, clusternum)) {
 					return qfalse;
 				}
@@ -277,11 +277,11 @@
 	aas_cluster_t *cluster;
 	aas_portal_t *portal;
 
-	cluster = &aasworld.clusters[clusternum];
+	cluster = &(*aasworld).clusters[clusternum];
 
 	for (i = 0; i < cluster->numportals; i++) {
-		portalnum = aasworld.portalindex[cluster->firstportal + i];
-		portal = &aasworld.portals[portalnum];
+		portalnum = (*aasworld).portalindex[cluster->firstportal + i];
+		portal = &(*aasworld).portals[portalnum];
 
 		if (portal->frontcluster == clusternum) {
 			portal->clusterareanum[0] = cluster->numareas++;
@@ -301,11 +301,11 @@
 	aas_cluster_t *cluster;
 	aas_portal_t *portal;
 
-	aasworld.clusters[clusternum].numareas = 0;
-	aasworld.clusters[clusternum].numreachabilityareas = 0;
+	(*aasworld).clusters[clusternum].numareas = 0;
+	(*aasworld).clusters[clusternum].numreachabilityareas = 0;
 	// number all areas in this cluster WITH reachabilities
-	for (i = 1; i < aasworld.numareas; i++) {
-		if (aasworld.areasettings[i].cluster != clusternum) {
+	for (i = 1; i < (*aasworld).numareas; i++) {
+		if ((*aasworld).areasettings[i].cluster != clusternum) {
 			continue;
 		}
 
@@ -313,17 +313,17 @@
 			continue;
 		}
 
-		aasworld.areasettings[i].clusterareanum = aasworld.clusters[clusternum].numareas;
+		(*aasworld).areasettings[i].clusterareanum = (*aasworld).clusters[clusternum].numareas;
 		// the cluster has an extra area
-		aasworld.clusters[clusternum].numareas++;
-		aasworld.clusters[clusternum].numreachabilityareas++;
+		(*aasworld).clusters[clusternum].numareas++;
+		(*aasworld).clusters[clusternum].numreachabilityareas++;
 	}
 	// number all portals in this cluster WITH reachabilities
-	cluster = &aasworld.clusters[clusternum];
+	cluster = &(*aasworld).clusters[clusternum];
 
 	for (i = 0; i < cluster->numportals; i++) {
-		portalnum = aasworld.portalindex[cluster->firstportal + i];
-		portal = &aasworld.portals[portalnum];
+		portalnum = (*aasworld).portalindex[cluster->firstportal + i];
+		portal = &(*aasworld).portals[portalnum];
 
 		if (!AAS_AreaReachability(portal->areanum)) {
 			continue;
@@ -331,15 +331,15 @@
 
 		if (portal->frontcluster == clusternum) {
 			portal->clusterareanum[0] = cluster->numareas++;
-			aasworld.clusters[clusternum].numreachabilityareas++;
+			(*aasworld).clusters[clusternum].numreachabilityareas++;
 		} else {
 			portal->clusterareanum[1] = cluster->numareas++;
-			aasworld.clusters[clusternum].numreachabilityareas++;
+			(*aasworld).clusters[clusternum].numreachabilityareas++;
 		}
 	}
 	// number all areas in this cluster WITHOUT reachabilities
-	for (i = 1; i < aasworld.numareas; i++) {
-		if (aasworld.areasettings[i].cluster != clusternum) {
+	for (i = 1; i < (*aasworld).numareas; i++) {
+		if ((*aasworld).areasettings[i].cluster != clusternum) {
 			continue;
 		}
 
@@ -347,16 +347,16 @@
 			continue;
 		}
 
-		aasworld.areasettings[i].clusterareanum = aasworld.clusters[clusternum].numareas;
+		(*aasworld).areasettings[i].clusterareanum = (*aasworld).clusters[clusternum].numareas;
 		// the cluster has an extra area
-		aasworld.clusters[clusternum].numareas++;
+		(*aasworld).clusters[clusternum].numareas++;
 	}
 	// number all portals in this cluster WITHOUT reachabilities
-	cluster = &aasworld.clusters[clusternum];
+	cluster = &(*aasworld).clusters[clusternum];
 
 	for (i = 0; i < cluster->numportals; i++) {
-		portalnum = aasworld.portalindex[cluster->firstportal + i];
-		portal = &aasworld.portals[portalnum];
+		portalnum = (*aasworld).portalindex[cluster->firstportal + i];
+		portal = &(*aasworld).portals[portalnum];
 
 		if (AAS_AreaReachability(portal->areanum)) {
 			continue;
@@ -381,45 +381,45 @@
 
 	AAS_RemoveClusterAreas();
 
-	for (i = 1; i < aasworld.numareas; i++) {
+	for (i = 1; i < (*aasworld).numareas; i++) {
 		// if the area is already part of a cluster
-		if (aasworld.areasettings[i].cluster) {
+		if ((*aasworld).areasettings[i].cluster) {
 			continue;
 		}
 		// if not flooding through faces only use areas that have reachabilities
 		if (nofaceflood) {
-			if (!aasworld.areasettings[i].numreachableareas) {
+			if (!(*aasworld).areasettings[i].numreachableareas) {
 				continue;
 			}
 		}
 		// if the area is a cluster portal
-		if (aasworld.areasettings[i].contents & AREACONTENTS_CLUSTERPORTAL) {
+		if ((*aasworld).areasettings[i].contents & AREACONTENTS_CLUSTERPORTAL) {
 			continue;
 		}
 
-		if (aasworld.numclusters >= AAS_MAX_CLUSTERS) {
+		if ((*aasworld).numclusters >= AAS_MAX_CLUSTERS) {
 			AAS_Error("AAS_MAX_CLUSTERS\n");
 			return qfalse;
 		}
 
-		cluster = &aasworld.clusters[aasworld.numclusters];
+		cluster = &(*aasworld).clusters[(*aasworld).numclusters];
 		cluster->numareas = 0;
 		cluster->numreachabilityareas = 0;
-		cluster->firstportal = aasworld.portalindexsize;
+		cluster->firstportal = (*aasworld).portalindexsize;
 		cluster->numportals = 0;
 		// flood the areas in this cluster
-		if (!AAS_FloodClusterAreas_r(i, aasworld.numclusters)) {
+		if (!AAS_FloodClusterAreas_r(i, (*aasworld).numclusters)) {
 			return qfalse;
 		}
 
-		if (!AAS_FloodClusterAreasUsingReachabilities(aasworld.numclusters)) {
+		if (!AAS_FloodClusterAreasUsingReachabilities((*aasworld).numclusters)) {
 			return qfalse;
 		}
 		// number the cluster areas
-		//AAS_NumberClusterPortals(aasworld.numclusters);
-		AAS_NumberClusterAreas(aasworld.numclusters);
-		//Log_Write("cluster %d has %d areas\r\n", aasworld.numclusters, cluster->numareas);
-		aasworld.numclusters++;
+		//AAS_NumberClusterPortals((*aasworld).numclusters);
+		AAS_NumberClusterAreas((*aasworld).numclusters);
+		//Log_Write("cluster %d has %d areas\r\n", (*aasworld).numclusters, cluster->numareas);
+		(*aasworld).numclusters++;
 	}
 
 	return qtrue;
@@ -434,19 +434,19 @@
 	int i;
 	aas_portal_t *portal;
 
-	for (i = 1; i < aasworld.numareas; i++) {
+	for (i = 1; i < (*aasworld).numareas; i++) {
 		// if the area is a cluster portal
-		if (aasworld.areasettings[i].contents & AREACONTENTS_CLUSTERPORTAL) {
-			if (aasworld.numportals >= AAS_MAX_PORTALS) {
+		if ((*aasworld).areasettings[i].contents & AREACONTENTS_CLUSTERPORTAL) {
+			if ((*aasworld).numportals >= AAS_MAX_PORTALS) {
 				AAS_Error("AAS_MAX_PORTALS\n");
 				return;
 			}
 
-			portal = &aasworld.portals[aasworld.numportals];
+			portal = &(*aasworld).portals[(*aasworld).numportals];
 			portal->areanum = i;
 			portal->frontcluster = 0;
 			portal->backcluster = 0;
-			aasworld.numportals++;
+			(*aasworld).numportals++;
 		}
 	}
 }
@@ -486,15 +486,15 @@
 	aas_plane_t *plane1, *plane2;
 	aas_edge_t *edge;
 
-	plane1 = &aasworld.planes[face1->planenum ^ side1];
-	plane2 = &aasworld.planes[face2->planenum ^ side2];
+	plane1 = &(*aasworld).planes[face1->planenum ^ side1];
+	plane2 = &(*aasworld).planes[face2->planenum ^ side2];
 	// check if one of the points of face1 is at the back of the plane of face2
 	for (i = 0; i < face1->numedges; i++) {
-		edgenum = abs(aasworld.edgeindex[face1->firstedge + i]);
-		edge = &aasworld.edges[edgenum];
+		edgenum = abs((*aasworld).edgeindex[face1->firstedge + i]);
+		edge = &(*aasworld).edges[edgenum];
 
 		for (j = 0; j < 2; j++) {
-			if (DotProduct(plane2->normal, aasworld.vertexes[edge->v[j]]) - plane2->dist < -0.01) {
+			if (DotProduct(plane2->normal, (*aasworld).vertexes[edge->v[j]]) - plane2->dist < -0.01) {
 				return qtrue;
 			}
 		}
@@ -501,11 +501,11 @@
 	}
 
 	for (i = 0; i < face2->numedges; i++) {
-		edgenum = abs(aasworld.edgeindex[face2->firstedge + i]);
-		edge = &aasworld.edges[edgenum];
+		edgenum = abs((*aasworld).edgeindex[face2->firstedge + i]);
+		edge = &(*aasworld).edges[edgenum];
 
 		for (j = 0; j < 2; j++) {
-			if (DotProduct(plane1->normal, aasworld.vertexes[edge->v[j]]) - plane1->dist < -0.01) {
+			if (DotProduct(plane1->normal, (*aasworld).vertexes[edge->v[j]]) - plane1->dist < -0.01) {
 				return qtrue;
 			}
 		}
@@ -526,11 +526,11 @@
 	aas_area_t *area1, *area2;
 
 	for (i = 0; i < numareas; i++) {
-		area1 = &aasworld.areas[areanums[i]];
+		area1 = &(*aasworld).areas[areanums[i]];
 
 		for (fn1 = 0; fn1 < area1->numfaces; fn1++) {
-			face1num = abs(aasworld.faceindex[area1->firstface + fn1]);
-			face1 = &aasworld.faces[face1num];
+			face1num = abs((*aasworld).faceindex[area1->firstface + fn1]);
+			face1 = &(*aasworld).faces[face1num];
 			side1 = face1->frontarea != areanums[i];
 			// check if the face isn't a shared one with one of the other areas
 			for (s = 0; s < numareas; s++) {
@@ -552,11 +552,11 @@
 					continue;
 				}
 
-				area2 = &aasworld.areas[areanums[j]];
+				area2 = &(*aasworld).areas[areanums[j]];
 
 				for (fn2 = 0; fn2 < area2->numfaces; fn2++) {
-					face2num = abs(aasworld.faceindex[area2->firstface + fn2]);
-					face2 = &aasworld.faces[face2num];
+					face2num = abs((*aasworld).faceindex[area2->firstface + fn2]);
+					face2 = &(*aasworld).faces[face2num];
 					side2 = face2->frontarea != areanums[j];
 					// check if the face isn't a shared one with one of the other areas
 					for (s = 0; s < numareas; s++) {
@@ -596,9 +596,9 @@
 	float dist1, dist2;
 	aas_plane_t *plane;
 
-	plane = &aasworld.planes[planenum];
-	VectorSubtract(aasworld.vertexes[edge1->v[1]], aasworld.vertexes[edge1->v[0]], edgevec1);
-	VectorSubtract(aasworld.vertexes[edge2->v[1]], aasworld.vertexes[edge2->v[0]], edgevec2);
+	plane = &(*aasworld).planes[planenum];
+	VectorSubtract((*aasworld).vertexes[edge1->v[1]], (*aasworld).vertexes[edge1->v[0]], edgevec1);
+	VectorSubtract((*aasworld).vertexes[edge2->v[1]], (*aasworld).vertexes[edge2->v[0]], edgevec2);
 
 	if (side1) {
 		VectorInverse(edgevec1);
@@ -609,18 +609,18 @@
 	}
 
 	CrossProduct(edgevec1, plane->normal, normal1);
-	dist1 = DotProduct(normal1, aasworld.vertexes[edge1->v[0]]);
+	dist1 = DotProduct(normal1, (*aasworld).vertexes[edge1->v[0]]);
 	CrossProduct(edgevec2, plane->normal, normal2);
-	dist2 = DotProduct(normal2, aasworld.vertexes[edge2->v[0]]);
+	dist2 = DotProduct(normal2, (*aasworld).vertexes[edge2->v[0]]);
 
 	for (i = 0; i < 2; i++) {
-		if (DotProduct(aasworld.vertexes[edge1->v[i]], normal2) - dist2 < -0.01) {
+		if (DotProduct((*aasworld).vertexes[edge1->v[i]], normal2) - dist2 < -0.01) {
 			return qfalse;
 		}
 	}
 
 	for (i = 0; i < 2; i++) {
-		if (DotProduct(aasworld.vertexes[edge2->v[i]], normal1) - dist1 < -0.01) {
+		if (DotProduct((*aasworld).vertexes[edge2->v[i]], normal1) - dist1 < -0.01) {
 			return qfalse;
 		}
 	}
@@ -640,13 +640,13 @@
 	aas_edge_t *edge1, *edge2;
 
 	for (i = 0; i < numfaces; i++) {
-		face1 = &aasworld.faces[facenums[i]];
+		face1 = &(*aasworld).faces[facenums[i]];
 
 		for (en1 = 0; en1 < face1->numedges; en1++) {
-			edgenum1 = aasworld.edgeindex[face1->firstedge + en1];
+			edgenum1 = (*aasworld).edgeindex[face1->firstedge + en1];
 			side1 = (edgenum1 < 0) ^ (face1->planenum != planenum);
 			edgenum1 = abs(edgenum1);
-			edge1 = &aasworld.edges[edgenum1];
+			edge1 = &(*aasworld).edges[edgenum1];
 			// check if the edge is shared with another face
 			for (s = 0; s < numfaces; s++) {
 				if (s == i) {
@@ -653,10 +653,10 @@
 					continue;
 				}
 
-				otherface = &aasworld.faces[facenums[s]];
+				otherface = &(*aasworld).faces[facenums[s]];
 
 				for (ens = 0; ens < otherface->numedges; ens++) {
-					if (edgenum1 == abs(aasworld.edgeindex[otherface->firstedge + ens])) {
+					if (edgenum1 == abs((*aasworld).edgeindex[otherface->firstedge + ens])) {
 						break;
 					}
 				}
@@ -675,13 +675,13 @@
 					continue;
 				}
 
-				face2 = &aasworld.faces[facenums[j]];
+				face2 = &(*aasworld).faces[facenums[j]];
 
 				for (en2 = 0; en2 < face2->numedges; en2++) {
-					edgenum2 = aasworld.edgeindex[face2->firstedge + en2];
+					edgenum2 = (*aasworld).edgeindex[face2->firstedge + en2];
 					side2 = (edgenum2 < 0) ^ (face2->planenum != planenum);
 					edgenum2 = abs(edgenum2);
-					edge2 = &aasworld.edges[edgenum2];
+					edge2 = &(*aasworld).edges[edgenum2];
 					// check if the edge is shared with another face
 					for (s = 0; s < numfaces; s++) {
 						if (s == i) {
@@ -688,10 +688,10 @@
 							continue;
 						}
 
-						otherface = &aasworld.faces[facenums[s]];
+						otherface = &(*aasworld).faces[facenums[s]];
 
 						for (ens = 0; ens < otherface->numedges; ens++) {
-							if (edgenum2 == abs(aasworld.edgeindex[otherface->firstedge + ens])) {
+							if (edgenum2 == abs((*aasworld).edgeindex[otherface->firstedge + ens])) {
 								break;
 							}
 						}
@@ -727,11 +727,11 @@
 	aas_face_t *face;
 
 	connectedareas[curarea] = qtrue;
-	area = &aasworld.areas[areanums[curarea]];
+	area = &(*aasworld).areas[areanums[curarea]];
 
 	for (i = 0; i < area->numfaces; i++) {
-		facenum = abs(aasworld.faceindex[area->firstface + i]);
-		face = &aasworld.faces[facenum];
+		facenum = abs((*aasworld).faceindex[area->firstface + i]);
+		face = &(*aasworld).faces[facenum];
 		// if the face is solid
 		if (face->faceflags & FACE_SOLID) {
 			continue;
@@ -803,12 +803,12 @@
 	aas_face_t *face;
 
 	areanums[numareas++] = curareanum;
-	area = &aasworld.areas[curareanum];
-	presencetype = aasworld.areasettings[curareanum].presencetype;
+	area = &(*aasworld).areas[curareanum];
+	presencetype = (*aasworld).areasettings[curareanum].presencetype;
 
 	for (i = 0; i < area->numfaces; i++) {
-		facenum = abs(aasworld.faceindex[area->firstface + i]);
-		face = &aasworld.faces[facenum];
+		facenum = abs((*aasworld).faceindex[area->firstface + i]);
+		face = &(*aasworld).faces[facenum];
 		// if the face is solid
 		if (face->faceflags & FACE_SOLID) {
 			continue;
@@ -820,7 +820,7 @@
 			otherareanum = face->backarea;
 		}
 
-		otherpresencetype = aasworld.areasettings[otherareanum].presencetype;
+		otherpresencetype = (*aasworld).areasettings[otherareanum].presencetype;
 		// if the other area has less presence types
 		if ((presencetype & ~otherpresencetype) && !(otherpresencetype & ~presencetype)) {
 			// check if the other area isn't already in the list
@@ -862,11 +862,11 @@
 	aas_face_t *frontface, *backface, *face;
 
 	// if it isn't already a portal
-	if (aasworld.areasettings[areanum].contents & AREACONTENTS_CLUSTERPORTAL) {
+	if ((*aasworld).areasettings[areanum].contents & AREACONTENTS_CLUSTERPORTAL) {
 		return 0;
 	}
 	// it must be a grounded area
-	if (!(aasworld.areasettings[areanum].areaflags & AREA_GROUNDED)) {
+	if (!((*aasworld).areasettings[areanum].areaflags & AREA_GROUNDED)) {
 		return 0;
 	}
 
@@ -880,11 +880,11 @@
 	numareas = AAS_GetAdjacentAreasWithLessPresenceTypes_r(areanums, 0, areanum);
 
 	for (i = 0; i < numareas; i++) {
-		area = &aasworld.areas[areanums[i]];
+		area = &(*aasworld).areas[areanums[i]];
 
 		for (j = 0; j < area->numfaces; j++) {
-			facenum = abs(aasworld.faceindex[area->firstface + j]);
-			face = &aasworld.faces[facenum];
+			facenum = abs((*aasworld).faceindex[area->firstface + j]);
+			face = &(*aasworld).faces[facenum];
 			// if the face is solid
 			if (face->faceflags & FACE_SOLID) {
 				continue;
@@ -910,7 +910,7 @@
 				otherareanum = face->frontarea;
 			}
 			// if the other area already is a cluter portal
-			if (aasworld.areasettings[otherareanum].contents & AREACONTENTS_CLUSTERPORTAL) {
+			if ((*aasworld).areasettings[otherareanum].contents & AREACONTENTS_CLUSTERPORTAL) {
 				return 0;
 			}
 			// number of the plane of the area
@@ -967,16 +967,16 @@
 	}
 	// none of the front faces should have a shared edge with a back face
 	for (i = 0; i < numfrontfaces; i++) {
-		frontface = &aasworld.faces[frontfacenums[i]];
+		frontface = &(*aasworld).faces[frontfacenums[i]];
 
 		for (fen = 0; fen < frontface->numedges; fen++) {
-			frontedgenum = abs(aasworld.edgeindex[frontface->firstedge + fen]);
+			frontedgenum = abs((*aasworld).edgeindex[frontface->firstedge + fen]);
 
 			for (j = 0; j < numbackfaces; j++) {
-				backface = &aasworld.faces[backfacenums[j]];
+				backface = &(*aasworld).faces[backfacenums[j]];
 
 				for (ben = 0; ben < backface->numedges; ben++) {
-					backedgenum = abs(aasworld.edgeindex[backface->firstedge + ben]);
+					backedgenum = abs((*aasworld).edgeindex[backface->firstedge + ben]);
 
 					if (frontedgenum == backedgenum) {
 						break;
@@ -1003,9 +1003,9 @@
 	}
 	// set the cluster portal contents
 	for (i = 0; i < numareas; i++) {
-		aasworld.areasettings[areanums[i]].contents |= AREACONTENTS_CLUSTERPORTAL;
+		(*aasworld).areasettings[areanums[i]].contents |= AREACONTENTS_CLUSTERPORTAL;
 		// this area can be used as a route portal
-		aasworld.areasettings[areanums[i]].contents |= AREACONTENTS_ROUTEPORTAL;
+		(*aasworld).areasettings[areanums[i]].contents |= AREACONTENTS_ROUTEPORTAL;
 
 		Log_Write("possible portal: %d\r\n", areanums[i]);
 	}
@@ -1023,7 +1023,7 @@
 
 	numpossibleportals = 0;
 
-	for (i = 1; i < aasworld.numareas; i++) {
+	for (i = 1; i < (*aasworld).numareas; i++) {
 		numpossibleportals += AAS_CheckAreaForPossiblePortals(i);
 	}
 
@@ -1038,8 +1038,8 @@
 void AAS_RemoveAllPortals(void) {
 	int i;
 
-	for (i = 1; i < aasworld.numareas; i++) {
-		aasworld.areasettings[i].contents &= ~AREACONTENTS_CLUSTERPORTAL;
+	for (i = 1; i < (*aasworld).numareas; i++) {
+		(*aasworld).areasettings[i].contents &= ~AREACONTENTS_CLUSTERPORTAL;
 	}
 }
 #if 0
@@ -1054,16 +1054,16 @@
 	aas_area_t *area;
 
 	// set cluster mark
-	aasworld.areasettings[areanum].cluster = clusternum;
+	(*aasworld).areasettings[areanum].cluster = clusternum;
 	// if the area is a portal
-	//if (aasworld.areasettings[areanum].contents & AREACONTENTS_CLUSTERPORTAL) {
+	//if ((*aasworld).areasettings[areanum].contents & AREACONTENTS_CLUSTERPORTAL) {
 	//	return;
 	//}
 
-	area = &aasworld.areas[areanum];
+	area = &(*aasworld).areas[areanum];
 	// use area faces to flood into adjacent areas
 	for (i = 0; i < area->numfaces; i++) {
-		face = &aasworld.faces[abs(aasworld.faceindex[area->firstface + i])];
+		face = &(*aasworld).faces[abs((*aasworld).faceindex[area->firstface + i])];
 
 		if (face->frontarea != areanum) {
 			otherareanum = face->frontarea;
@@ -1075,11 +1075,11 @@
 			continue;
 		}
 		// if the area is a portal
-		if (aasworld.areasettings[otherareanum].contents & AREACONTENTS_CLUSTERPORTAL) {
+		if ((*aasworld).areasettings[otherareanum].contents & AREACONTENTS_CLUSTERPORTAL) {
 			continue;
 		}
 		// if the area is already marked
-		if (aasworld.areasettings[otherareanum].cluster) {
+		if ((*aasworld).areasettings[otherareanum].cluster) {
 			continue;
 		}
 
@@ -1086,20 +1086,20 @@
 		AAS_FloodCluster_r(otherareanum, clusternum);
 	}
 	// use the reachabilities to flood into other areas
-	for (i = 0; i < aasworld.areasettings[areanum].numreachableareas; i++) {
-		otherareanum = aasworld.reachability[aasworld.areasettings[areanum].firstreachablearea + i].areanum;
+	for (i = 0; i < (*aasworld).areasettings[areanum].numreachableareas; i++) {
+		otherareanum = (*aasworld).reachability[(*aasworld).areasettings[areanum].firstreachablearea + i].areanum;
 
 		if (!otherareanum) {
 			continue;
 
-			AAS_Error("reachability %d has zero area\n", aasworld.areasettings[areanum].firstreachablearea + i);
+			AAS_Error("reachability %d has zero area\n", (*aasworld).areasettings[areanum].firstreachablearea + i);
 		}
 		// if the area is a portal
-		if (aasworld.areasettings[otherareanum].contents & AREACONTENTS_CLUSTERPORTAL) {
+		if ((*aasworld).areasettings[otherareanum].contents & AREACONTENTS_CLUSTERPORTAL) {
 			continue;
 		}
 		// if the area is already marked
-		if (aasworld.areasettings[otherareanum].cluster) {
+		if ((*aasworld).areasettings[otherareanum].cluster) {
 			continue;
 		}
 
@@ -1115,13 +1115,13 @@
 void AAS_RemoveTeleporterPortals(void) {
 	int i, j, areanum;
 
-	for (i = 1; i < aasworld.numareas; i++) {
-		for (j = 0; j < aasworld.areasettings[i].numreachableareas; j++) {
-			areanum = aasworld.reachability[aasworld.areasettings[i].firstreachablearea + j].areanum;
+	for (i = 1; i < (*aasworld).numareas; i++) {
+		for (j = 0; j < (*aasworld).areasettings[i].numreachableareas; j++) {
+			areanum = (*aasworld).reachability[(*aasworld).areasettings[i].firstreachablearea + j].areanum;
 
-			if (aasworld.reachability[aasworld.areasettings[i].firstreachablearea + j].traveltype == TRAVEL_TELEPORT) {
-				aasworld.areasettings[i].contents &= ~AREACONTENTS_CLUSTERPORTAL;
-				aasworld.areasettings[areanum].contents &= ~AREACONTENTS_CLUSTERPORTAL;
+			if ((*aasworld).reachability[(*aasworld).areasettings[i].firstreachablearea + j].traveltype == TRAVEL_TELEPORT) {
+				(*aasworld).areasettings[i].contents &= ~AREACONTENTS_CLUSTERPORTAL;
+				(*aasworld).areasettings[areanum].contents &= ~AREACONTENTS_CLUSTERPORTAL;
 				break;
 			}
 		}
@@ -1136,25 +1136,25 @@
 void AAS_FloodClusterReachabilities(int clusternum) {
 	int i, j, areanum;
 
-	for (i = 1; i < aasworld.numareas; i++) {
+	for (i = 1; i < (*aasworld).numareas; i++) {
 		// if this area already has a cluster set
-		if (aasworld.areasettings[i].cluster) {
+		if ((*aasworld).areasettings[i].cluster) {
 			continue;
 		}
 		// if this area is a cluster portal
-		if (aasworld.areasettings[i].contents & AREACONTENTS_CLUSTERPORTAL) {
+		if ((*aasworld).areasettings[i].contents & AREACONTENTS_CLUSTERPORTAL) {
 			continue;
 		}
 		// loop over the reachable areas from this area
-		for (j = 0; j < aasworld.areasettings[i].numreachableareas; j++) {
+		for (j = 0; j < (*aasworld).areasettings[i].numreachableareas; j++) {
 			// the reachable area
-			areanum = aasworld.reachability[aasworld.areasettings[i].firstreachablearea + j].areanum;
+			areanum = (*aasworld).reachability[(*aasworld).areasettings[i].firstreachablearea + j].areanum;
 			// if this area is a cluster portal
-			if (aasworld.areasettings[areanum].contents & AREACONTENTS_CLUSTERPORTAL) {
+			if ((*aasworld).areasettings[areanum].contents & AREACONTENTS_CLUSTERPORTAL) {
 				continue;
 			}
 			// if this area has a cluster set
-			if (aasworld.areasettings[areanum].cluster == clusternum) {
+			if ((*aasworld).areasettings[areanum].cluster == clusternum) {
 				AAS_FloodCluster_r(i, clusternum);
 				i = 0;
 				break;
@@ -1177,16 +1177,16 @@
 
 	nonclosingportals = 0;
 
-	for (i = 1; i < aasworld.numareas; i++) {
-		if (!(aasworld.areasettings[i].contents & AREACONTENTS_CLUSTERPORTAL)) {
+	for (i = 1; i < (*aasworld).numareas; i++) {
+		if (!((*aasworld).areasettings[i].contents & AREACONTENTS_CLUSTERPORTAL)) {
 			continue;
 		}
 		// find a non-portal area adjacent to the portal area and flood the cluster from there
-		area = &aasworld.areas[i];
+		area = &(*aasworld).areas[i];
 
 		for (j = 0; j < area->numfaces; j++) {
-			facenum = abs(aasworld.faceindex[area->firstface + j]);
-			face = &aasworld.faces[facenum];
+			facenum = abs((*aasworld).faceindex[area->firstface + j]);
+			face = &(*aasworld).faces[facenum];
 
 			if (face->frontarea != i) {
 				otherareanum = face->frontarea;
@@ -1198,7 +1198,7 @@
 				continue;
 			}
 
-			if (aasworld.areasettings[otherareanum].contents & AREACONTENTS_CLUSTERPORTAL) {
+			if ((*aasworld).areasettings[otherareanum].contents & AREACONTENTS_CLUSTERPORTAL) {
 				continue;
 			}
 			// reset all cluster fields
@@ -1207,8 +1207,8 @@
 			AAS_FloodClusterReachabilities(1);
 			// check if all adjacent non-portal areas have a cluster set
 			for (k = 0; k < area->numfaces; k++) {
-				facenum = abs(aasworld.faceindex[area->firstface + k]);
-				face = &aasworld.faces[facenum];
+				facenum = abs((*aasworld).faceindex[area->firstface + k]);
+				face = &(*aasworld).faces[facenum];
 
 				if (face->frontarea != i) {
 					otherareanum = face->frontarea;
@@ -1220,17 +1220,17 @@
 					continue;
 				}
 
-				if (aasworld.areasettings[otherareanum].contents & AREACONTENTS_CLUSTERPORTAL) {
+				if ((*aasworld).areasettings[otherareanum].contents & AREACONTENTS_CLUSTERPORTAL) {
 					continue;
 				}
 
-				if (!aasworld.areasettings[otherareanum].cluster) {
+				if (!(*aasworld).areasettings[otherareanum].cluster) {
 					break;
 				}
 			}
 			// if all adjacent non-portal areas have a cluster set then the portal didn't seal a cluster
 			if (k >= area->numfaces) {
-				aasworld.areasettings[i].contents &= ~AREACONTENTS_CLUSTERPORTAL;
+				(*aasworld).areasettings[i].contents &= ~AREACONTENTS_CLUSTERPORTAL;
 				nonclosingportals++;
 				// recheck all the other portals again
 				i = 0;
@@ -1256,8 +1256,8 @@
 
 	nonclosingportals = 0;
 
-	for (i = 1; i < aasworld.numareas; i++) {
-		if (!(aasworld.areasettings[i].contents & AREACONTENTS_CLUSTERPORTAL)) {
+	for (i = 1; i < (*aasworld).numareas; i++) {
+		if (!((*aasworld).areasettings[i].contents & AREACONTENTS_CLUSTERPORTAL)) {
 			continue;
 		}
 
@@ -1265,11 +1265,11 @@
 		// reset all cluster fields
 		AAS_RemoveClusterAreas();
 		// find a non-portal area adjacent to the portal area and flood the cluster from there
-		area = &aasworld.areas[i];
+		area = &(*aasworld).areas[i];
 
 		for (j = 0; j < area->numfaces; j++) {
-			facenum = abs(aasworld.faceindex[area->firstface + j]);
-			face = &aasworld.faces[facenum];
+			facenum = abs((*aasworld).faceindex[area->firstface + j]);
+			face = &(*aasworld).faces[facenum];
 
 			if (face->frontarea != i) {
 				otherareanum = face->frontarea;
@@ -1281,11 +1281,11 @@
 				continue;
 			}
 			// don't flood into other portals
-			if (aasworld.areasettings[otherareanum].contents & AREACONTENTS_CLUSTERPORTAL) {
+			if ((*aasworld).areasettings[otherareanum].contents & AREACONTENTS_CLUSTERPORTAL) {
 				continue;
 			}
 			// if the area already has a cluster set
-			if (aasworld.areasettings[otherareanum].cluster) {
+			if ((*aasworld).areasettings[otherareanum].cluster) {
 				continue;
 			}
 			// another cluster is separated by this portal
@@ -1295,18 +1295,18 @@
 			AAS_FloodClusterReachabilities(numseparatedclusters);
 		}
 		// use the reachabilities to flood into other areas
-		for (j = 0; j < aasworld.areasettings[i].numreachableareas; j++) {
-			otherareanum = aasworld.reachability[aasworld.areasettings[i].firstreachablearea + j].areanum;
+		for (j = 0; j < (*aasworld).areasettings[i].numreachableareas; j++) {
+			otherareanum = (*aasworld).reachability[(*aasworld).areasettings[i].firstreachablearea + j].areanum;
 			// this should never be qtrue but we check anyway
 			if (!otherareanum) {
 				continue;
 			}
 			// don't flood into other portals
-			if (aasworld.areasettings[otherareanum].contents & AREACONTENTS_CLUSTERPORTAL) {
+			if ((*aasworld).areasettings[otherareanum].contents & AREACONTENTS_CLUSTERPORTAL) {
 				continue;
 			}
 			// if the area already has a cluster set
-			if (aasworld.areasettings[otherareanum].cluster) {
+			if ((*aasworld).areasettings[otherareanum].cluster) {
 				continue;
 			}
 			// another cluster is separated by this portal
@@ -1317,7 +1317,7 @@
 		}
 		// a portal must separate no more and no less than 2 clusters
 		if (numseparatedclusters != 2) {
-			aasworld.areasettings[i].contents &= ~AREACONTENTS_CLUSTERPORTAL;
+			(*aasworld).areasettings[i].contents &= ~AREACONTENTS_CLUSTERPORTAL;
 			nonclosingportals++;
 			// recheck all the other portals again
 			i = 0;
@@ -1399,8 +1399,8 @@
 
 			area2num = AAS_PointAreaNum(destorigin);
 			// reset all cluster fields
-			for (j = 0; j < aasworld.numareas; j++) {
-				aasworld.areasettings[j].cluster = 0;
+			for (j = 0; j < (*aasworld).numareas; j++) {
+				(*aasworld).areasettings[j].cluster = 0;
 			}
 
 			VectorSet(mins, -8, -8, 8);
@@ -1419,7 +1419,7 @@
 					continue;
 				}
 				// add the teleporter portal mark
-				aasworld.areasettings[link->areanum].contents |= AREACONTENTS_CLUSTERPORTAL|AREACONTENTS_TELEPORTAL;
+				(*aasworld).areasettings[link->areanum].contents |= AREACONTENTS_CLUSTERPORTAL|AREACONTENTS_TELEPORTAL;
 			}
 
 			for (link = areas; link; link = link->next_area) {
@@ -1427,11 +1427,11 @@
 					continue;
 				}
 				// find a non-portal area adjacent to the portal area and flood the cluster from there
-				area = &aasworld.areas[link->areanum];
+				area = &(*aasworld).areas[link->areanum];
 
 				for (j = 0; j < area->numfaces; j++) {
-					facenum = abs(aasworld.faceindex[area->firstface + j]);
-					face = &aasworld.faces[facenum];
+					facenum = abs((*aasworld).faceindex[area->firstface + j]);
+					face = &(*aasworld).faces[facenum];
 
 					if (face->frontarea != link->areanum) {
 						otherareanum = face->frontarea;
@@ -1443,7 +1443,7 @@
 						continue;
 					}
 
-					if (aasworld.areasettings[otherareanum].contents & AREACONTENTS_CLUSTERPORTAL) {
+					if ((*aasworld).areasettings[otherareanum].contents & AREACONTENTS_CLUSTERPORTAL) {
 						continue;
 					}
 
@@ -1451,13 +1451,13 @@
 				}
 			}
 			// if the teleport destination IS in the same cluster
-			if (aasworld.areasettings[area2num].cluster) {
+			if ((*aasworld).areasettings[area2num].cluster) {
 				for (link = areas; link; link = link->next_area) {
 					if (!AAS_AreaGrounded(link->areanum)) {
 						continue;
 					}
 					// add the teleporter portal mark
-					aasworld.areasettings[link->areanum].contents &= ~(AREACONTENTS_CLUSTERPORTAL|AREACONTENTS_TELEPORTAL);
+					(*aasworld).areasettings[link->areanum].contents &= ~(AREACONTENTS_CLUSTERPORTAL|AREACONTENTS_TELEPORTAL);
 				}
 			}
 		}
@@ -1474,14 +1474,14 @@
 void AAS_AddTeleporterPortals(void) {
 	int i, j, areanum;
 
-	for (i = 1; i < aasworld.numareas; i++) {
-		for (j = 0; j < aasworld.areasettings[i].numreachableareas; j++) {
-			if (aasworld.reachability[aasworld.areasettings[i].firstreachablearea + j].traveltype != TRAVEL_TELEPORT) {
+	for (i = 1; i < (*aasworld).numareas; i++) {
+		for (j = 0; j < (*aasworld).areasettings[i].numreachableareas; j++) {
+			if ((*aasworld).reachability[(*aasworld).areasettings[i].firstreachablearea + j].traveltype != TRAVEL_TELEPORT) {
 				continue;
 			}
 
-			areanum = aasworld.reachability[aasworld.areasettings[i].firstreachablearea + j].areanum;
-			aasworld.areasettings[areanum].contents |= AREACONTENTS_CLUSTERPORTAL;
+			areanum = (*aasworld).reachability[(*aasworld).areasettings[i].firstreachablearea + j].areanum;
+			(*aasworld).areasettings[areanum].contents |= AREACONTENTS_CLUSTERPORTAL;
 		}
 	}
 }
@@ -1495,17 +1495,17 @@
 	int i;
 	aas_portal_t *portal;
 
-	for (i = 1; i < aasworld.numportals; i++) {
-		portal = &aasworld.portals[i];
+	for (i = 1; i < (*aasworld).numportals; i++) {
+		portal = &(*aasworld).portals[i];
 
 		if (!portal->frontcluster) {
-			aasworld.areasettings[portal->areanum].contents &= ~AREACONTENTS_CLUSTERPORTAL;
+			(*aasworld).areasettings[portal->areanum].contents &= ~AREACONTENTS_CLUSTERPORTAL;
 			Log_Write("portal area %d has no front cluster\r\n", portal->areanum);
 			return qfalse;
 		}
 
 		if (!portal->backcluster) {
-			aasworld.areasettings[portal->areanum].contents &= ~AREACONTENTS_CLUSTERPORTAL;
+			(*aasworld).areasettings[portal->areanum].contents &= ~AREACONTENTS_CLUSTERPORTAL;
 			Log_Write("portal area %d has no back cluster\r\n", portal->areanum);
 			return qfalse;
 		}
@@ -1524,8 +1524,8 @@
 
 	num = 0;
 
-	for (i = 1; i < aasworld.numareas; i++) {
-		if (aasworld.areasettings[i].contents & AREACONTENTS_CLUSTERPORTAL) {
+	for (i = 1; i < (*aasworld).numareas; i++) {
+		if ((*aasworld).areasettings[i].contents & AREACONTENTS_CLUSTERPORTAL) {
 			Log_Write("area %d is a forced portal area\r\n", i);
 			num++;
 		}
@@ -1542,9 +1542,9 @@
 void AAS_CreateViewPortals(void) {
 	int i;
 
-	for (i = 1; i < aasworld.numareas; i++) {
-		if (aasworld.areasettings[i].contents & AREACONTENTS_CLUSTERPORTAL) {
-			aasworld.areasettings[i].contents |= AREACONTENTS_VIEWPORTAL;
+	for (i = 1; i < (*aasworld).numareas; i++) {
+		if ((*aasworld).areasettings[i].contents & AREACONTENTS_CLUSTERPORTAL) {
+			(*aasworld).areasettings[i].contents |= AREACONTENTS_VIEWPORTAL;
 		}
 	}
 }
@@ -1557,9 +1557,9 @@
 void AAS_SetViewPortalsAsClusterPortals(void) {
 	int i;
 
-	for (i = 1; i < aasworld.numareas; i++) {
-		if (aasworld.areasettings[i].contents & AREACONTENTS_VIEWPORTAL) {
-			aasworld.areasettings[i].contents |= AREACONTENTS_CLUSTERPORTAL;
+	for (i = 1; i < (*aasworld).numareas; i++) {
+		if ((*aasworld).areasettings[i].contents & AREACONTENTS_VIEWPORTAL) {
+			(*aasworld).areasettings[i].contents |= AREACONTENTS_CLUSTERPORTAL;
 		}
 	}
 }
@@ -1573,11 +1573,11 @@
 	int i, removedPortalAreas;
 	int n, total, numreachabilityareas;
 
-	if (!aasworld.loaded) {
+	if (!(*aasworld).loaded) {
 		return;
 	}
 	// if there are clusters
-	if (aasworld.numclusters >= 1) {
+	if ((*aasworld).numclusters >= 1) {
 #ifndef BSPC
 		// if clustering isn't forced
 		if (!((int)LibVarGetValue("forceclustering")) && !((int)LibVarGetValue("forcereachability"))) {
@@ -1598,23 +1598,23 @@
 	// remove all portals that are not closing a cluster
 	//AAS_RemoveNotClusterClosingPortals();
 	// initialize portal memory
-	if (aasworld.portals) {
-		FreeMemory(aasworld.portals);
+	if ((*aasworld).portals) {
+		FreeMemory((*aasworld).portals);
 	}
 
-	aasworld.portals = (aas_portal_t *)GetClearedMemory(AAS_MAX_PORTALS * sizeof(aas_portal_t));
+	(*aasworld).portals = (aas_portal_t *)GetClearedMemory(AAS_MAX_PORTALS * sizeof(aas_portal_t));
 	// initialize portal index memory
-	if (aasworld.portalindex) {
-		FreeMemory(aasworld.portalindex);
+	if ((*aasworld).portalindex) {
+		FreeMemory((*aasworld).portalindex);
 	}
 
-	aasworld.portalindex = (aas_portalindex_t *)GetClearedMemory(AAS_MAX_PORTALINDEXSIZE * sizeof(aas_portalindex_t));
+	(*aasworld).portalindex = (aas_portalindex_t *)GetClearedMemory(AAS_MAX_PORTALINDEXSIZE * sizeof(aas_portalindex_t));
 	// initialize cluster memory
-	if (aasworld.clusters) {
-		FreeMemory(aasworld.clusters);
+	if ((*aasworld).clusters) {
+		FreeMemory((*aasworld).clusters);
 	}
 
-	aasworld.clusters = (aas_cluster_t *)GetClearedMemory(AAS_MAX_CLUSTERS * sizeof(aas_cluster_t));
+	(*aasworld).clusters = (aas_cluster_t *)GetClearedMemory(AAS_MAX_CLUSTERS * sizeof(aas_cluster_t));
 	removedPortalAreas = 0;
 
 	botimport.Print(PRT_MESSAGE, "\r%6d removed portal areas", removedPortalAreas);
@@ -1622,9 +1622,9 @@
 	while (1) {
 		botimport.Print(PRT_MESSAGE, "\r%6d", removedPortalAreas);
 		// initialize the number of portals and clusters
-		aasworld.numportals = 1; // portal 0 is a dummy
-		aasworld.portalindexsize = 0;
-		aasworld.numclusters = 1; // cluster 0 is a dummy
+		(*aasworld).numportals = 1; // portal 0 is a dummy
+		(*aasworld).portalindexsize = 0;
+		(*aasworld).numclusters = 1; // cluster 0 is a dummy
 		// create the portals from the portal areas
 		AAS_CreatePortals();
 
@@ -1643,29 +1643,29 @@
 
 	botimport.Print(PRT_MESSAGE, "\n");
 	// the AAS file should be saved
-	aasworld.savefile = qtrue;
+	(*aasworld).savefile = qtrue;
 	// write the portal areas to the log file
-	for (i = 1; i < aasworld.numportals; i++) {
-		Log_Write("portal %d: area %d\r\n", i, aasworld.portals[i].areanum);
+	for (i = 1; i < (*aasworld).numportals; i++) {
+		Log_Write("portal %d: area %d\r\n", i, (*aasworld).portals[i].areanum);
 	}
 	// report cluster info
-	botimport.Print(PRT_MESSAGE, "%6d portals created\n", aasworld.numportals);
-	botimport.Print(PRT_MESSAGE, "%6d clusters created\n", aasworld.numclusters);
+	botimport.Print(PRT_MESSAGE, "%6d portals created\n", (*aasworld).numportals);
+	botimport.Print(PRT_MESSAGE, "%6d clusters created\n", (*aasworld).numclusters);
 
-	for (i = 1; i < aasworld.numclusters; i++) {
-		botimport.Print(PRT_MESSAGE, "cluster %d has %d reachability areas\n", i, aasworld.clusters[i].numreachabilityareas);
+	for (i = 1; i < (*aasworld).numclusters; i++) {
+		botimport.Print(PRT_MESSAGE, "cluster %d has %d reachability areas\n", i, (*aasworld).clusters[i].numreachabilityareas);
 	}
 	// report AAS file efficiency
 	numreachabilityareas = 0;
 	total = 0;
 
-	for (i = 0; i < aasworld.numclusters; i++) {
-		n = aasworld.clusters[i].numreachabilityareas;
+	for (i = 0; i < (*aasworld).numclusters; i++) {
+		n = (*aasworld).clusters[i].numreachabilityareas;
 		numreachabilityareas += n;
 		total += n * n;
 	}
 
-	total += numreachabilityareas * aasworld.numportals;
+	total += numreachabilityareas * (*aasworld).numportals;
 
 	botimport.Print(PRT_MESSAGE, "%6i total reachability areas\n", numreachabilityareas);
 	botimport.Print(PRT_MESSAGE, "%6i AAS memory/CPU usage (the lower the better)\n", total * 3);
Index: code/botlib/be_aas_debug.c
===================================================================
--- code/botlib/be_aas_debug.c	(revision 1306)
+++ code/botlib/be_aas_debug.c	(working copy)
@@ -283,21 +283,21 @@
 
 	color = LINECOLOR_YELLOW;
 	// check if face number is in range
-	if (facenum >= aasworld.numfaces) {
+	if (facenum >= (*aasworld).numfaces) {
 		botimport.Print(PRT_ERROR, "facenum %d out of range\n", facenum);
 	}
 
-	face = &aasworld.faces[facenum];
+	face = &(*aasworld).faces[facenum];
 	// walk through the edges of the face
 	for (i = 0; i < face->numedges; i++) {
 		// edge number
-		edgenum = abs(aasworld.edgeindex[face->firstedge + i]);
+		edgenum = abs((*aasworld).edgeindex[face->firstedge + i]);
 		// check if edge number is in range
-		if (edgenum >= aasworld.numedges) {
+		if (edgenum >= (*aasworld).numedges) {
 			botimport.Print(PRT_ERROR, "edgenum %d out of range\n", edgenum);
 		}
 
-		edge = &aasworld.edges[edgenum];
+		edge = &(*aasworld).edges[edgenum];
 
 		if (color == LINECOLOR_RED) {
 			color = LINECOLOR_GREEN;
@@ -309,14 +309,14 @@
 			color = LINECOLOR_RED;
 		}
 
-		AAS_DebugLine(aasworld.vertexes[edge->v[0]], aasworld.vertexes[edge->v[1]], color);
+		AAS_DebugLine((*aasworld).vertexes[edge->v[0]], (*aasworld).vertexes[edge->v[1]], color);
 	}
 
-	plane = &aasworld.planes[face->planenum];
-	edgenum = abs(aasworld.edgeindex[face->firstedge]);
-	edge = &aasworld.edges[edgenum];
+	plane = &(*aasworld).planes[face->planenum];
+	edgenum = abs((*aasworld).edgeindex[face->firstedge]);
+	edge = &(*aasworld).edges[edgenum];
 
-	VectorCopy(aasworld.vertexes[edge->v[0]], start);
+	VectorCopy((*aasworld).vertexes[edge->v[0]], start);
 	VectorMA(start, 20, plane->normal, end);
 	AAS_DebugLine(start, end, LINECOLOR_RED);
 }
@@ -333,11 +333,11 @@
 	aas_face_t *face;
 
 	// check if face number is in range
-	if (facenum >= aasworld.numfaces) {
+	if (facenum >= (*aasworld).numfaces) {
 		botimport.Print(PRT_ERROR, "facenum %d out of range\n", facenum);
 	}
 
-	face = &aasworld.faces[facenum];
+	face = &(*aasworld).faces[facenum];
 	// walk through the edges of the face
 	numpoints = 0;
 
@@ -344,10 +344,10 @@
 	if (flip) {
 		for (i = face->numedges - 1; i >= 0; i--) {
 			// edge number
-			edgenum = aasworld.edgeindex[face->firstedge + i];
-			edge = &aasworld.edges[abs(edgenum)];
+			edgenum = (*aasworld).edgeindex[face->firstedge + i];
+			edge = &(*aasworld).edges[abs(edgenum)];
 
-			VectorCopy(aasworld.vertexes[edge->v[edgenum < 0]], points[numpoints]);
+			VectorCopy((*aasworld).vertexes[edge->v[edgenum < 0]], points[numpoints]);
 
 			numpoints++;
 		}
@@ -354,10 +354,10 @@
 	} else {
 		for (i = 0; i < face->numedges; i++) {
 			// edge number
-			edgenum = aasworld.edgeindex[face->firstedge + i];
-			edge = &aasworld.edges[abs(edgenum)];
+			edgenum = (*aasworld).edgeindex[face->firstedge + i];
+			edge = &(*aasworld).edges[abs(edgenum)];
 
-			VectorCopy(aasworld.vertexes[edge->v[edgenum < 0]], points[numpoints]);
+			VectorCopy((*aasworld).vertexes[edge->v[edgenum < 0]], points[numpoints]);
 
 			numpoints++;
 		}
@@ -381,21 +381,21 @@
 
 	numareaedges = 0;
 
-	if (areanum < 0 || areanum >= aasworld.numareas) {
-		botimport.Print(PRT_ERROR, "area %d out of range [0, %d]\n", areanum, aasworld.numareas);
+	if (areanum < 0 || areanum >= (*aasworld).numareas) {
+		botimport.Print(PRT_ERROR, "area %d out of range [0, %d]\n", areanum, (*aasworld).numareas);
 		return;
 	}
 	// pointer to the convex area
-	area = &aasworld.areas[areanum];
+	area = &(*aasworld).areas[areanum];
 	// walk through the faces of the area
 	for (i = 0; i < area->numfaces; i++) {
-		facenum = abs(aasworld.faceindex[area->firstface + i]);
+		facenum = abs((*aasworld).faceindex[area->firstface + i]);
 		// check if face number is in range
-		if (facenum >= aasworld.numfaces) {
+		if (facenum >= (*aasworld).numfaces) {
 			botimport.Print(PRT_ERROR, "facenum %d out of range\n", facenum);
 		}
 
-		face = &aasworld.faces[facenum];
+		face = &(*aasworld).faces[facenum];
 		// ground faces only
 		if (groundfacesonly) {
 			if (!(face->faceflags & (FACE_GROUND|FACE_LADDER))) {
@@ -405,9 +405,9 @@
 		// walk through the edges of the face
 		for (j = 0; j < face->numedges; j++) {
 			// edge number
-			edgenum = abs(aasworld.edgeindex[face->firstedge + j]);
+			edgenum = abs((*aasworld).edgeindex[face->firstedge + j]);
 			// check if edge number is in range
-			if (edgenum >= aasworld.numedges) {
+			if (edgenum >= (*aasworld).numedges) {
 				botimport.Print(PRT_ERROR, "edgenum %d out of range\n", edgenum);
 			}
 			// check if the edge is stored already
@@ -442,7 +442,7 @@
 			return;
 		}
 
-		edge = &aasworld.edges[areaedges[n]];
+		edge = &(*aasworld).edges[areaedges[n]];
 
 		if (color == LINECOLOR_RED) {
 			color = LINECOLOR_BLUE;
@@ -454,7 +454,7 @@
 			color = LINECOLOR_RED;
 		}
 
-		botimport.DebugLineShow(debuglines[line], aasworld.vertexes[edge->v[0]], aasworld.vertexes[edge->v[1]], color);
+		botimport.DebugLineShow(debuglines[line], (*aasworld).vertexes[edge->v[0]], (*aasworld).vertexes[edge->v[1]], color);
 
 		debuglinevisible[line] = qtrue;
 	}
@@ -470,21 +470,21 @@
 	aas_area_t *area;
 	aas_face_t *face;
 
-	if (areanum < 0 || areanum >= aasworld.numareas) {
-		botimport.Print(PRT_ERROR, "area %d out of range [0, %d]\n", areanum, aasworld.numareas);
+	if (areanum < 0 || areanum >= (*aasworld).numareas) {
+		botimport.Print(PRT_ERROR, "area %d out of range [0, %d]\n", areanum, (*aasworld).numareas);
 		return;
 	}
 	// pointer to the convex area
-	area = &aasworld.areas[areanum];
+	area = &(*aasworld).areas[areanum];
 	// walk through the faces of the area
 	for (i = 0; i < area->numfaces; i++) {
-		facenum = abs(aasworld.faceindex[area->firstface + i]);
+		facenum = abs((*aasworld).faceindex[area->firstface + i]);
 		// check if face number is in range
-		if (facenum >= aasworld.numfaces) {
+		if (facenum >= (*aasworld).numfaces) {
 			botimport.Print(PRT_ERROR, "facenum %d out of range\n", facenum);
 		}
 
-		face = &aasworld.faces[facenum];
+		face = &(*aasworld).faces[facenum];
 		// ground faces only
 		if (groundfacesonly) {
 			if (!(face->faceflags & (FACE_GROUND|FACE_LADDER))) {
@@ -699,7 +699,7 @@
 		lastareanum = areanum;
 	}
 
-	settings = &aasworld.areasettings[areanum];
+	settings = &(*aasworld).areasettings[areanum];
 
 	if (!settings->numreachableareas) {
 		return;
@@ -710,7 +710,7 @@
 	}
 
 	if (AAS_Time() - lasttime > 1.5) {
-		Com_Memcpy(&reach, &aasworld.reachability[settings->firstreachablearea + index], sizeof(aas_reachability_t));
+		Com_Memcpy(&reach, &(*aasworld).reachability[settings->firstreachablearea + index], sizeof(aas_reachability_t));
 
 		index++;
 		lasttime = AAS_Time();
@@ -737,12 +737,12 @@
 
 	AAS_ShowAreaPolygons(areanum, 1, qtrue);
 	// pointer to the convex area
-	area = &aasworld.areas[areanum];
-	settings = &aasworld.areasettings[areanum];
+	area = &(*aasworld).areas[areanum];
+	settings = &(*aasworld).areasettings[areanum];
 	// walk through the faces of the area
 	for (i = 0; i < area->numfaces; i++) {
-		facenum = abs(aasworld.faceindex[area->firstface + i]);
-		face = &aasworld.faces[facenum];
+		facenum = abs((*aasworld).faceindex[area->firstface + i]);
+		face = &(*aasworld).faces[facenum];
 
 		if (face->frontarea == areanum) {
 			nextareanum = face->backarea;
@@ -760,7 +760,7 @@
 
 		done[nextareanum] = qtrue;
 
-		if (aasworld.areasettings[nextareanum].contents & AREACONTENTS_VIEWPORTAL) {
+		if ((*aasworld).areasettings[nextareanum].contents & AREACONTENTS_VIEWPORTAL) {
 			continue;
 		}
 
@@ -772,7 +772,7 @@
 	}
 
 	for (i = 0; i < settings->numreachableareas; i++) {
-		reach = &aasworld.reachability[settings->firstreachablearea + i];
+		reach = &(*aasworld).reachability[settings->firstreachablearea + i];
 		nextareanum = reach->areanum;
 
 		if (!nextareanum) {
@@ -785,7 +785,7 @@
 
 		done[nextareanum] = qtrue;
 
-		if (aasworld.areasettings[nextareanum].contents & AREACONTENTS_VIEWPORTAL) {
+		if ((*aasworld).areasettings[nextareanum].contents & AREACONTENTS_VIEWPORTAL) {
 			continue;
 		}
 
@@ -809,7 +809,7 @@
 void AAS_FloodAreas(vec3_t origin) {
 	int areanum, cluster, *done;
 
-	done = (int *)GetClearedMemory(aasworld.numareas * sizeof(int));
+	done = (int *)GetClearedMemory((*aasworld).numareas * sizeof(int));
 	areanum = AAS_PointAreaNum(origin);
 	cluster = AAS_AreaCluster(areanum);
 
Index: code/botlib/be_aas_def.h
===================================================================
--- code/botlib/be_aas_def.h	(revision 1306)
+++ code/botlib/be_aas_def.h	(working copy)
@@ -25,10 +25,10 @@
 #include "../qcommon/q_shared.h"
 // debugging on
 #define AAS_DEBUG
-#define DF_AASENTNUMBER(x) (x - aasworld.entities)
-#define DF_NUMBERAASENT(x) (&aasworld.entities[x])
-#define DF_AASENTCLIENT(x) (x - aasworld.entities - 1)
-#define DF_CLIENTAASENT(x) (&aasworld.entities[x + 1])
+#define DF_AASENTNUMBER(x) (x - (*aasworlds).entities)
+#define DF_NUMBERAASENT(x) (&(*aasworlds).entities[x])
+#define DF_AASENTCLIENT(x) (x - (*aasworlds).entities - 1)
+#define DF_CLIENTAASENT(x) (&(*aasworlds).entities[x + 1])
 // structure to link entities to areas and areas to entities
 typedef struct aas_link_s {
 	int entnum;
Index: code/botlib/be_aas_entity.c
===================================================================
--- code/botlib/be_aas_entity.c	(revision 1306)
+++ code/botlib/be_aas_entity.c	(working copy)
@@ -39,6 +39,9 @@
 #include "be_aas_funcs.h"
 #include "be_interface.h"
 #include "be_aas_def.h"
+// always use the default world for entities
+extern aas_t aasworlds[MAX_AAS_WORLDS];
+aas_t *defaultaasworld = aasworlds;
 
 /*
 =======================================================================================================================================
@@ -50,12 +53,12 @@
 	aas_entity_t *ent;
 	vec3_t absmins, absmaxs;
 
-	if (!aasworld.loaded) {
+	if (!(*defaultaasworld).loaded) {
 		botimport.Print(PRT_MESSAGE, "AAS_UpdateEntity: not loaded\n");
 		return BLERR_NOAASFILE;
 	}
 
-	ent = &aasworld.entities[entnum];
+	ent = &(*defaultaasworld).entities[entnum];
 
 	if (!state) {
 		// unlink the entity
@@ -76,7 +79,7 @@
 
 	VectorCopy(ent->i.origin, ent->i.lastvisorigin);
 	// link everything the first frame
-	if (aasworld.numframes == 1) {
+	if ((*defaultaasworld).numframes == 1) {
 		relink = qtrue;
 	} else {
 		relink = qfalse;
@@ -149,19 +152,19 @@
 */
 void AAS_EntityInfo(int entnum, aas_entityinfo_t *info) {
 
-	if (!aasworld.initialized) {
-		botimport.Print(PRT_FATAL, "AAS_EntityInfo: aasworld not initialized\n");
+	if (!(*defaultaasworld).initialized) {
+		botimport.Print(PRT_FATAL, "AAS_EntityInfo: (*defaultaasworld) not initialized\n");
 		Com_Memset(info, 0, sizeof(aas_entityinfo_t));
 		return;
 	}
 
-	if (entnum < 0 || entnum >= aasworld.maxentities) {
+	if (entnum < 0 || entnum >= (*defaultaasworld).maxentities) {
 		botimport.Print(PRT_FATAL, "AAS_EntityInfo: entnum %d out of range\n", entnum);
 		Com_Memset(info, 0, sizeof(aas_entityinfo_t));
 		return;
 	}
 
-	Com_Memcpy(info, &aasworld.entities[entnum].i, sizeof(aas_entityinfo_t));
+	Com_Memcpy(info, &(*defaultaasworld).entities[entnum].i, sizeof(aas_entityinfo_t));
 }
 
 /*
@@ -171,13 +174,13 @@
 */
 void AAS_EntityOrigin(int entnum, vec3_t origin) {
 
-	if (entnum < 0 || entnum >= aasworld.maxentities) {
+	if (entnum < 0 || entnum >= (*defaultaasworld).maxentities) {
 		botimport.Print(PRT_FATAL, "AAS_EntityOrigin: entnum %d out of range\n", entnum);
 		VectorClear(origin);
 		return;
 	}
 
-	VectorCopy(aasworld.entities[entnum].i.origin, origin);
+	VectorCopy((*defaultaasworld).entities[entnum].i.origin, origin);
 }
 
 /*
@@ -187,12 +190,12 @@
 */
 int AAS_EntityModelindex(int entnum) {
 
-	if (entnum < 0 || entnum >= aasworld.maxentities) {
+	if (entnum < 0 || entnum >= (*defaultaasworld).maxentities) {
 		botimport.Print(PRT_FATAL, "AAS_EntityModelindex: entnum %d out of range\n", entnum);
 		return 0;
 	}
 
-	return aasworld.entities[entnum].i.modelindex;
+	return (*defaultaasworld).entities[entnum].i.modelindex;
 }
 
 /*
@@ -202,16 +205,16 @@
 */
 int AAS_EntityType(int entnum) {
 
-	if (!aasworld.initialized) {
+	if (!(*defaultaasworld).initialized) {
 		return 0;
 	}
 
-	if (entnum < 0 || entnum >= aasworld.maxentities) {
+	if (entnum < 0 || entnum >= (*defaultaasworld).maxentities) {
 		botimport.Print(PRT_FATAL, "AAS_EntityType: entnum %d out of range\n", entnum);
 		return 0;
 	}
 
-	return aasworld.entities[entnum].i.type;
+	return (*defaultaasworld).entities[entnum].i.type;
 }
 
 /*
@@ -221,16 +224,16 @@
 */
 int AAS_EntityModelNum(int entnum) {
 
-	if (!aasworld.initialized) {
+	if (!(*defaultaasworld).initialized) {
 		return 0;
 	}
 
-	if (entnum < 0 || entnum >= aasworld.maxentities) {
+	if (entnum < 0 || entnum >= (*defaultaasworld).maxentities) {
 		botimport.Print(PRT_FATAL, "AAS_EntityModelNum: entnum %d out of range\n", entnum);
 		return 0;
 	}
 
-	return aasworld.entities[entnum].i.modelindex;
+	return (*defaultaasworld).entities[entnum].i.modelindex;
 }
 
 /*
@@ -241,16 +244,16 @@
 void AAS_EntitySize(int entnum, vec3_t mins, vec3_t maxs) {
 	aas_entity_t *ent;
 
-	if (!aasworld.initialized) {
+	if (!(*defaultaasworld).initialized) {
 		return;
 	}
 
-	if (entnum < 0 || entnum >= aasworld.maxentities) {
+	if (entnum < 0 || entnum >= (*defaultaasworld).maxentities) {
 		botimport.Print(PRT_FATAL, "AAS_EntitySize: entnum %d out of range\n", entnum);
 		return;
 	}
 
-	ent = &aasworld.entities[entnum];
+	ent = &(*defaultaasworld).entities[entnum];
 
 	VectorCopy(ent->i.mins, mins);
 	VectorCopy(ent->i.maxs, maxs);
@@ -264,7 +267,7 @@
 void AAS_EntityBSPData(int entnum, bsp_entdata_t *entdata) {
 	aas_entity_t *ent;
 
-	ent = &aasworld.entities[entnum];
+	ent = &(*defaultaasworld).entities[entnum];
 
 	VectorCopy(ent->i.origin, entdata->origin);
 	VectorCopy(ent->i.angles, entdata->angles);
@@ -283,9 +286,9 @@
 void AAS_ResetEntityLinks(void) {
 	int i;
 
-	for (i = 0; i < aasworld.maxentities; i++) {
-		aasworld.entities[i].areas = NULL;
-		aasworld.entities[i].leaves = NULL;
+	for (i = 0; i < (*defaultaasworld).maxentities; i++) {
+		(*defaultaasworld).entities[i].areas = NULL;
+		(*defaultaasworld).entities[i].leaves = NULL;
 	}
 }
 
@@ -297,9 +300,9 @@
 void AAS_InvalidateEntities(void) {
 	int i;
 
-	for (i = 0; i < aasworld.maxentities; i++) {
-		aasworld.entities[i].i.number = i;
-		aasworld.entities[i].i.valid = qfalse;
+	for (i = 0; i < (*defaultaasworld).maxentities; i++) {
+		(*defaultaasworld).entities[i].i.number = i;
+		(*defaultaasworld).entities[i].i.valid = qfalse;
 	}
 }
 
@@ -312,8 +315,8 @@
 	int i;
 	aas_entity_t *ent;
 
-	for (i = 0; i < aasworld.maxentities; i++) {
-		ent = &aasworld.entities[i];
+	for (i = 0; i < (*defaultaasworld).maxentities; i++) {
+		ent = &(*defaultaasworld).entities[i];
 
 		if (!ent->i.valid) {
 			AAS_UnlinkFromAreas(ent->areas);
@@ -338,8 +341,8 @@
 	bestentnum = 0;
 	bestdist = 99999;
 
-	for (i = 0; i < aasworld.maxentities; i++) {
-		ent = &aasworld.entities[i];
+	for (i = 0; i < (*defaultaasworld).maxentities; i++) {
+		ent = &(*defaultaasworld).entities[i];
 
 		if (ent->i.modelindex != modelindex) {
 			continue;
@@ -370,7 +373,7 @@
 int AAS_BestReachableEntityArea(int entnum) {
 	aas_entity_t *ent;
 
-	ent = &aasworld.entities[entnum];
+	ent = &(*defaultaasworld).entities[entnum];
 	return AAS_BestReachableLinkArea(ent->areas);
 }
 
@@ -381,7 +384,7 @@
 */
 int AAS_NextEntity(int entnum) {
 
-	if (!aasworld.loaded) {
+	if (!(*defaultaasworld).loaded) {
 		return 0;
 	}
 
@@ -389,8 +392,8 @@
 		entnum = -1;
 	}
 
-	while (++entnum < aasworld.maxentities) {
-		if (aasworld.entities[entnum].i.valid) {
+	while (++entnum < (*defaultaasworld).maxentities) {
+		if ((*defaultaasworld).entities[entnum].i.valid) {
 			return entnum;
 		}
 	}
Index: code/botlib/be_aas_file.c
===================================================================
--- code/botlib/be_aas_file.c	(revision 1306)
+++ code/botlib/be_aas_file.c	(working copy)
@@ -51,112 +51,112 @@
 	int i, j;
 
 	// bounding boxes
-	for (i = 0; i < aasworld.numbboxes; i++) {
-		aasworld.bboxes[i].presencetype = LittleLong(aasworld.bboxes[i].presencetype);
-		aasworld.bboxes[i].flags = LittleLong(aasworld.bboxes[i].flags);
+	for (i = 0; i < (*aasworld).numbboxes; i++) {
+		(*aasworld).bboxes[i].presencetype = LittleLong((*aasworld).bboxes[i].presencetype);
+		(*aasworld).bboxes[i].flags = LittleLong((*aasworld).bboxes[i].flags);
 
 		for (j = 0; j < 3; j++) {
-			aasworld.bboxes[i].mins[j] = LittleFloat(aasworld.bboxes[i].mins[j]);
-			aasworld.bboxes[i].maxs[j] = LittleFloat(aasworld.bboxes[i].maxs[j]);
+			(*aasworld).bboxes[i].mins[j] = LittleFloat((*aasworld).bboxes[i].mins[j]);
+			(*aasworld).bboxes[i].maxs[j] = LittleFloat((*aasworld).bboxes[i].maxs[j]);
 		}
 	}
 	// vertexes
-	for (i = 0; i < aasworld.numvertexes; i++) {
+	for (i = 0; i < (*aasworld).numvertexes; i++) {
 		for (j = 0; j < 3; j++) {
-			aasworld.vertexes[i][j] = LittleFloat(aasworld.vertexes[i][j]);
+			(*aasworld).vertexes[i][j] = LittleFloat((*aasworld).vertexes[i][j]);
 		}
 	}
 	// planes
-	for (i = 0; i < aasworld.numplanes; i++) {
+	for (i = 0; i < (*aasworld).numplanes; i++) {
 		for (j = 0; j < 3; j++) {
-			aasworld.planes[i].normal[j] = LittleFloat(aasworld.planes[i].normal[j]);
+			(*aasworld).planes[i].normal[j] = LittleFloat((*aasworld).planes[i].normal[j]);
 		}
 
-		aasworld.planes[i].dist = LittleFloat(aasworld.planes[i].dist);
-		aasworld.planes[i].type = LittleLong(aasworld.planes[i].type);
+		(*aasworld).planes[i].dist = LittleFloat((*aasworld).planes[i].dist);
+		(*aasworld).planes[i].type = LittleLong((*aasworld).planes[i].type);
 	}
 	// edges
-	for (i = 0; i < aasworld.numedges; i++) {
-		aasworld.edges[i].v[0] = LittleLong(aasworld.edges[i].v[0]);
-		aasworld.edges[i].v[1] = LittleLong(aasworld.edges[i].v[1]);
+	for (i = 0; i < (*aasworld).numedges; i++) {
+		(*aasworld).edges[i].v[0] = LittleLong((*aasworld).edges[i].v[0]);
+		(*aasworld).edges[i].v[1] = LittleLong((*aasworld).edges[i].v[1]);
 	}
 	// edgeindex
-	for (i = 0; i < aasworld.edgeindexsize; i++) {
-		aasworld.edgeindex[i] = LittleLong(aasworld.edgeindex[i]);
+	for (i = 0; i < (*aasworld).edgeindexsize; i++) {
+		(*aasworld).edgeindex[i] = LittleLong((*aasworld).edgeindex[i]);
 	}
 	// faces
-	for (i = 0; i < aasworld.numfaces; i++) {
-		aasworld.faces[i].planenum = LittleLong(aasworld.faces[i].planenum);
-		aasworld.faces[i].faceflags = LittleLong(aasworld.faces[i].faceflags);
-		aasworld.faces[i].numedges = LittleLong(aasworld.faces[i].numedges);
-		aasworld.faces[i].firstedge = LittleLong(aasworld.faces[i].firstedge);
-		aasworld.faces[i].frontarea = LittleLong(aasworld.faces[i].frontarea);
-		aasworld.faces[i].backarea = LittleLong(aasworld.faces[i].backarea);
+	for (i = 0; i < (*aasworld).numfaces; i++) {
+		(*aasworld).faces[i].planenum = LittleLong((*aasworld).faces[i].planenum);
+		(*aasworld).faces[i].faceflags = LittleLong((*aasworld).faces[i].faceflags);
+		(*aasworld).faces[i].numedges = LittleLong((*aasworld).faces[i].numedges);
+		(*aasworld).faces[i].firstedge = LittleLong((*aasworld).faces[i].firstedge);
+		(*aasworld).faces[i].frontarea = LittleLong((*aasworld).faces[i].frontarea);
+		(*aasworld).faces[i].backarea = LittleLong((*aasworld).faces[i].backarea);
 	}
 	// face index
-	for (i = 0; i < aasworld.faceindexsize; i++) {
-		aasworld.faceindex[i] = LittleLong(aasworld.faceindex[i]);
+	for (i = 0; i < (*aasworld).faceindexsize; i++) {
+		(*aasworld).faceindex[i] = LittleLong((*aasworld).faceindex[i]);
 	}
 	// convex areas
-	for (i = 0; i < aasworld.numareas; i++) {
-		aasworld.areas[i].areanum = LittleLong(aasworld.areas[i].areanum);
-		aasworld.areas[i].numfaces = LittleLong(aasworld.areas[i].numfaces);
-		aasworld.areas[i].firstface = LittleLong(aasworld.areas[i].firstface);
+	for (i = 0; i < (*aasworld).numareas; i++) {
+		(*aasworld).areas[i].areanum = LittleLong((*aasworld).areas[i].areanum);
+		(*aasworld).areas[i].numfaces = LittleLong((*aasworld).areas[i].numfaces);
+		(*aasworld).areas[i].firstface = LittleLong((*aasworld).areas[i].firstface);
 
 		for (j = 0; j < 3; j++) {
-			aasworld.areas[i].mins[j] = LittleFloat(aasworld.areas[i].mins[j]);
-			aasworld.areas[i].maxs[j] = LittleFloat(aasworld.areas[i].maxs[j]);
-			aasworld.areas[i].center[j] = LittleFloat(aasworld.areas[i].center[j]);
+			(*aasworld).areas[i].mins[j] = LittleFloat((*aasworld).areas[i].mins[j]);
+			(*aasworld).areas[i].maxs[j] = LittleFloat((*aasworld).areas[i].maxs[j]);
+			(*aasworld).areas[i].center[j] = LittleFloat((*aasworld).areas[i].center[j]);
 		}
 	}
 	// area settings
-	for (i = 0; i < aasworld.numareasettings; i++) {
-		aasworld.areasettings[i].contents = LittleLong(aasworld.areasettings[i].contents);
-		aasworld.areasettings[i].areaflags = LittleLong(aasworld.areasettings[i].areaflags);
-		aasworld.areasettings[i].presencetype = LittleLong(aasworld.areasettings[i].presencetype);
-		aasworld.areasettings[i].cluster = LittleLong(aasworld.areasettings[i].cluster);
-		aasworld.areasettings[i].clusterareanum = LittleLong(aasworld.areasettings[i].clusterareanum);
-		aasworld.areasettings[i].numreachableareas = LittleLong(aasworld.areasettings[i].numreachableareas);
-		aasworld.areasettings[i].firstreachablearea = LittleLong(aasworld.areasettings[i].firstreachablearea);
+	for (i = 0; i < (*aasworld).numareasettings; i++) {
+		(*aasworld).areasettings[i].contents = LittleLong((*aasworld).areasettings[i].contents);
+		(*aasworld).areasettings[i].areaflags = LittleLong((*aasworld).areasettings[i].areaflags);
+		(*aasworld).areasettings[i].presencetype = LittleLong((*aasworld).areasettings[i].presencetype);
+		(*aasworld).areasettings[i].cluster = LittleLong((*aasworld).areasettings[i].cluster);
+		(*aasworld).areasettings[i].clusterareanum = LittleLong((*aasworld).areasettings[i].clusterareanum);
+		(*aasworld).areasettings[i].numreachableareas = LittleLong((*aasworld).areasettings[i].numreachableareas);
+		(*aasworld).areasettings[i].firstreachablearea = LittleLong((*aasworld).areasettings[i].firstreachablearea);
 	}
 	// area reachability
-	for (i = 0; i < aasworld.reachabilitysize; i++) {
-		aasworld.reachability[i].areanum = LittleLong(aasworld.reachability[i].areanum);
-		aasworld.reachability[i].facenum = LittleLong(aasworld.reachability[i].facenum);
-		aasworld.reachability[i].edgenum = LittleLong(aasworld.reachability[i].edgenum);
+	for (i = 0; i < (*aasworld).reachabilitysize; i++) {
+		(*aasworld).reachability[i].areanum = LittleLong((*aasworld).reachability[i].areanum);
+		(*aasworld).reachability[i].facenum = LittleLong((*aasworld).reachability[i].facenum);
+		(*aasworld).reachability[i].edgenum = LittleLong((*aasworld).reachability[i].edgenum);
 
 		for (j = 0; j < 3; j++) {
-			aasworld.reachability[i].start[j] = LittleFloat(aasworld.reachability[i].start[j]);
-			aasworld.reachability[i].end[j] = LittleFloat(aasworld.reachability[i].end[j]);
+			(*aasworld).reachability[i].start[j] = LittleFloat((*aasworld).reachability[i].start[j]);
+			(*aasworld).reachability[i].end[j] = LittleFloat((*aasworld).reachability[i].end[j]);
 		}
 
-		aasworld.reachability[i].traveltype = LittleLong(aasworld.reachability[i].traveltype);
-		aasworld.reachability[i].traveltime = LittleShort(aasworld.reachability[i].traveltime);
+		(*aasworld).reachability[i].traveltype = LittleLong((*aasworld).reachability[i].traveltype);
+		(*aasworld).reachability[i].traveltime = LittleShort((*aasworld).reachability[i].traveltime);
 	}
 	// nodes
-	for (i = 0; i < aasworld.numnodes; i++) {
-		aasworld.nodes[i].planenum = LittleLong(aasworld.nodes[i].planenum);
-		aasworld.nodes[i].children[0] = LittleLong(aasworld.nodes[i].children[0]);
-		aasworld.nodes[i].children[1] = LittleLong(aasworld.nodes[i].children[1]);
+	for (i = 0; i < (*aasworld).numnodes; i++) {
+		(*aasworld).nodes[i].planenum = LittleLong((*aasworld).nodes[i].planenum);
+		(*aasworld).nodes[i].children[0] = LittleLong((*aasworld).nodes[i].children[0]);
+		(*aasworld).nodes[i].children[1] = LittleLong((*aasworld).nodes[i].children[1]);
 	}
 	// cluster portals
-	for (i = 0; i < aasworld.numportals; i++) {
-		aasworld.portals[i].areanum = LittleLong(aasworld.portals[i].areanum);
-		aasworld.portals[i].frontcluster = LittleLong(aasworld.portals[i].frontcluster);
-		aasworld.portals[i].backcluster = LittleLong(aasworld.portals[i].backcluster);
-		aasworld.portals[i].clusterareanum[0] = LittleLong(aasworld.portals[i].clusterareanum[0]);
-		aasworld.portals[i].clusterareanum[1] = LittleLong(aasworld.portals[i].clusterareanum[1]);
+	for (i = 0; i < (*aasworld).numportals; i++) {
+		(*aasworld).portals[i].areanum = LittleLong((*aasworld).portals[i].areanum);
+		(*aasworld).portals[i].frontcluster = LittleLong((*aasworld).portals[i].frontcluster);
+		(*aasworld).portals[i].backcluster = LittleLong((*aasworld).portals[i].backcluster);
+		(*aasworld).portals[i].clusterareanum[0] = LittleLong((*aasworld).portals[i].clusterareanum[0]);
+		(*aasworld).portals[i].clusterareanum[1] = LittleLong((*aasworld).portals[i].clusterareanum[1]);
 	}
 	// cluster portal index
-	for (i = 0; i < aasworld.portalindexsize; i++) {
-		aasworld.portalindex[i] = LittleLong(aasworld.portalindex[i]);
+	for (i = 0; i < (*aasworld).portalindexsize; i++) {
+		(*aasworld).portalindex[i] = LittleLong((*aasworld).portalindex[i]);
 	}
 	// cluster
-	for (i = 0; i < aasworld.numclusters; i++) {
-		aasworld.clusters[i].numareas = LittleLong(aasworld.clusters[i].numareas);
-		aasworld.clusters[i].numreachabilityareas = LittleLong(aasworld.clusters[i].numreachabilityareas);
-		aasworld.clusters[i].numportals = LittleLong(aasworld.clusters[i].numportals);
-		aasworld.clusters[i].firstportal = LittleLong(aasworld.clusters[i].firstportal);
+	for (i = 0; i < (*aasworld).numclusters; i++) {
+		(*aasworld).clusters[i].numareas = LittleLong((*aasworld).clusters[i].numareas);
+		(*aasworld).clusters[i].numreachabilityareas = LittleLong((*aasworld).clusters[i].numreachabilityareas);
+		(*aasworld).clusters[i].numportals = LittleLong((*aasworld).clusters[i].numportals);
+		(*aasworld).clusters[i].firstportal = LittleLong((*aasworld).clusters[i].firstportal);
 	}
 }
 
@@ -169,108 +169,108 @@
 */
 void AAS_DumpAASData(void) {
 
-	aasworld.numbboxes = 0;
+	(*aasworld).numbboxes = 0;
 
-	if (aasworld.bboxes) {
-		FreeMemory(aasworld.bboxes);
+	if ((*aasworld).bboxes) {
+		FreeMemory((*aasworld).bboxes);
 	}
 
-	aasworld.bboxes = NULL;
-	aasworld.numvertexes = 0;
+	(*aasworld).bboxes = NULL;
+	(*aasworld).numvertexes = 0;
 
-	if (aasworld.vertexes) {
-		FreeMemory(aasworld.vertexes);
+	if ((*aasworld).vertexes) {
+		FreeMemory((*aasworld).vertexes);
 	}
 
-	aasworld.vertexes = NULL;
-	aasworld.numplanes = 0;
+	(*aasworld).vertexes = NULL;
+	(*aasworld).numplanes = 0;
 
-	if (aasworld.planes) {
-		FreeMemory(aasworld.planes);
+	if ((*aasworld).planes) {
+		FreeMemory((*aasworld).planes);
 	}
 
-	aasworld.planes = NULL;
-	aasworld.numedges = 0;
+	(*aasworld).planes = NULL;
+	(*aasworld).numedges = 0;
 
-	if (aasworld.edges) {
-		FreeMemory(aasworld.edges);
+	if ((*aasworld).edges) {
+		FreeMemory((*aasworld).edges);
 	}
 
-	aasworld.edges = NULL;
-	aasworld.edgeindexsize = 0;
+	(*aasworld).edges = NULL;
+	(*aasworld).edgeindexsize = 0;
 
-	if (aasworld.edgeindex) {
-		FreeMemory(aasworld.edgeindex);
+	if ((*aasworld).edgeindex) {
+		FreeMemory((*aasworld).edgeindex);
 	}
 
-	aasworld.edgeindex = NULL;
-	aasworld.numfaces = 0;
+	(*aasworld).edgeindex = NULL;
+	(*aasworld).numfaces = 0;
 
-	if (aasworld.faces) {
-		FreeMemory(aasworld.faces);
+	if ((*aasworld).faces) {
+		FreeMemory((*aasworld).faces);
 	}
 
-	aasworld.faces = NULL;
-	aasworld.faceindexsize = 0;
+	(*aasworld).faces = NULL;
+	(*aasworld).faceindexsize = 0;
 
-	if (aasworld.faceindex) {
-		FreeMemory(aasworld.faceindex);
+	if ((*aasworld).faceindex) {
+		FreeMemory((*aasworld).faceindex);
 	}
 
-	aasworld.faceindex = NULL;
-	aasworld.numareas = 0;
+	(*aasworld).faceindex = NULL;
+	(*aasworld).numareas = 0;
 
-	if (aasworld.areas) {
-		FreeMemory(aasworld.areas);
+	if ((*aasworld).areas) {
+		FreeMemory((*aasworld).areas);
 	}
 
-	aasworld.areas = NULL;
-	aasworld.numareasettings = 0;
+	(*aasworld).areas = NULL;
+	(*aasworld).numareasettings = 0;
 
-	if (aasworld.areasettings) {
-		FreeMemory(aasworld.areasettings);
+	if ((*aasworld).areasettings) {
+		FreeMemory((*aasworld).areasettings);
 	}
 
-	aasworld.areasettings = NULL;
-	aasworld.reachabilitysize = 0;
+	(*aasworld).areasettings = NULL;
+	(*aasworld).reachabilitysize = 0;
 
-	if (aasworld.reachability) {
-		FreeMemory(aasworld.reachability);
+	if ((*aasworld).reachability) {
+		FreeMemory((*aasworld).reachability);
 	}
 
-	aasworld.reachability = NULL;
-	aasworld.numnodes = 0;
+	(*aasworld).reachability = NULL;
+	(*aasworld).numnodes = 0;
 
-	if (aasworld.nodes) {
-		FreeMemory(aasworld.nodes);
+	if ((*aasworld).nodes) {
+		FreeMemory((*aasworld).nodes);
 	}
 
-	aasworld.nodes = NULL;
-	aasworld.numportals = 0;
+	(*aasworld).nodes = NULL;
+	(*aasworld).numportals = 0;
 
-	if (aasworld.portals) {
-		FreeMemory(aasworld.portals);
+	if ((*aasworld).portals) {
+		FreeMemory((*aasworld).portals);
 	}
 
-	aasworld.portals = NULL;
-	aasworld.numportals = 0;
+	(*aasworld).portals = NULL;
+	(*aasworld).numportals = 0;
 
-	if (aasworld.portalindex) {
-		FreeMemory(aasworld.portalindex);
+	if ((*aasworld).portalindex) {
+		FreeMemory((*aasworld).portalindex);
 	}
 
-	aasworld.portalindex = NULL;
-	aasworld.portalindexsize = 0;
+	(*aasworld).portalindex = NULL;
+	(*aasworld).portalindexsize = 0;
 
-	if (aasworld.clusters) {
-		FreeMemory(aasworld.clusters);
+	if ((*aasworld).clusters) {
+		FreeMemory((*aasworld).clusters);
 	}
 
-	aasworld.clusters = NULL;
-	aasworld.numclusters = 0;
-	aasworld.loaded = qfalse;
-	aasworld.initialized = qfalse;
-	aasworld.savefile = qfalse;
+	(*aasworld).clusters = NULL;
+	(*aasworld).numclusters = 0;
+	(*aasworld).loaded = qfalse;
+	(*aasworld).initialized = qfalse;
+	(*aasworld).savefile = qfalse;
 }
 #ifdef AASFILEDEBUG
 /*
@@ -282,36 +282,36 @@
 	int i, n, optimized;
 
 	botimport.Print(PRT_MESSAGE, "version = %d\n", AASVERSION);
-	botimport.Print(PRT_MESSAGE, "numvertexes = %d\n", aasworld.numvertexes);
-	botimport.Print(PRT_MESSAGE, "numplanes = %d\n", aasworld.numplanes);
-	botimport.Print(PRT_MESSAGE, "numedges = %d\n", aasworld.numedges);
-	botimport.Print(PRT_MESSAGE, "edgeindexsize = %d\n", aasworld.edgeindexsize);
-	botimport.Print(PRT_MESSAGE, "numfaces = %d\n", aasworld.numfaces);
-	botimport.Print(PRT_MESSAGE, "faceindexsize = %d\n", aasworld.faceindexsize);
-	botimport.Print(PRT_MESSAGE, "numareas = %d\n", aasworld.numareas);
-	botimport.Print(PRT_MESSAGE, "numareasettings = %d\n", aasworld.numareasettings);
-	botimport.Print(PRT_MESSAGE, "reachabilitysize = %d\n", aasworld.reachabilitysize);
-	botimport.Print(PRT_MESSAGE, "numnodes = %d\n", aasworld.numnodes);
-	botimport.Print(PRT_MESSAGE, "numportals = %d\n", aasworld.numportals);
-	botimport.Print(PRT_MESSAGE, "portalindexsize = %d\n", aasworld.portalindexsize);
-	botimport.Print(PRT_MESSAGE, "numclusters = %d\n", aasworld.numclusters);
+	botimport.Print(PRT_MESSAGE, "numvertexes = %d\n", (*aasworld).numvertexes);
+	botimport.Print(PRT_MESSAGE, "numplanes = %d\n", (*aasworld).numplanes);
+	botimport.Print(PRT_MESSAGE, "numedges = %d\n", (*aasworld).numedges);
+	botimport.Print(PRT_MESSAGE, "edgeindexsize = %d\n", (*aasworld).edgeindexsize);
+	botimport.Print(PRT_MESSAGE, "numfaces = %d\n", (*aasworld).numfaces);
+	botimport.Print(PRT_MESSAGE, "faceindexsize = %d\n", (*aasworld).faceindexsize);
+	botimport.Print(PRT_MESSAGE, "numareas = %d\n", (*aasworld).numareas);
+	botimport.Print(PRT_MESSAGE, "numareasettings = %d\n", (*aasworld).numareasettings);
+	botimport.Print(PRT_MESSAGE, "reachabilitysize = %d\n", (*aasworld).reachabilitysize);
+	botimport.Print(PRT_MESSAGE, "numnodes = %d\n", (*aasworld).numnodes);
+	botimport.Print(PRT_MESSAGE, "numportals = %d\n", (*aasworld).numportals);
+	botimport.Print(PRT_MESSAGE, "portalindexsize = %d\n", (*aasworld).portalindexsize);
+	botimport.Print(PRT_MESSAGE, "numclusters = %d\n", (*aasworld).numclusters);
 
-	for (n = 0, i = 0; i < aasworld.numareasettings; i++) {
-		if (aasworld.areasettings[i].areaflags & AREA_GROUNDED) {
+	for (n = 0, i = 0; i < (*aasworld).numareasettings; i++) {
+		if ((*aasworld).areasettings[i].areaflags & AREA_GROUNDED) {
 			n++;
 		}
 	}
 
 	botimport.Print(PRT_MESSAGE, "num grounded areas = %d\n", n);
-	botimport.Print(PRT_MESSAGE, "planes size %d bytes\n", aasworld.numplanes * sizeof(aas_plane_t));
-	botimport.Print(PRT_MESSAGE, "areas size %d bytes\n", aasworld.numareas * sizeof(aas_area_t));
-	botimport.Print(PRT_MESSAGE, "areasettings size %d bytes\n", aasworld.numareasettings * sizeof(aas_areasettings_t));
-	botimport.Print(PRT_MESSAGE, "nodes size %d bytes\n", aasworld.numnodes * sizeof(aas_node_t));
-	botimport.Print(PRT_MESSAGE, "reachability size %d bytes\n", aasworld.reachabilitysize * sizeof(aas_reachability_t));
-	botimport.Print(PRT_MESSAGE, "portals size %d bytes\n", aasworld.numportals * sizeof(aas_portal_t));
-	botimport.Print(PRT_MESSAGE, "clusters size %d bytes\n", aasworld.numclusters * sizeof(aas_cluster_t));
+	botimport.Print(PRT_MESSAGE, "planes size %d bytes\n", (*aasworld).numplanes * sizeof(aas_plane_t));
+	botimport.Print(PRT_MESSAGE, "areas size %d bytes\n", (*aasworld).numareas * sizeof(aas_area_t));
+	botimport.Print(PRT_MESSAGE, "areasettings size %d bytes\n", (*aasworld).numareasettings * sizeof(aas_areasettings_t));
+	botimport.Print(PRT_MESSAGE, "nodes size %d bytes\n", (*aasworld).numnodes * sizeof(aas_node_t));
+	botimport.Print(PRT_MESSAGE, "reachability size %d bytes\n", (*aasworld).reachabilitysize * sizeof(aas_reachability_t));
+	botimport.Print(PRT_MESSAGE, "portals size %d bytes\n", (*aasworld).numportals * sizeof(aas_portal_t));
+	botimport.Print(PRT_MESSAGE, "clusters size %d bytes\n", (*aasworld).numclusters * sizeof(aas_cluster_t));
 
-	optimized = aasworld.numplanes * sizeof(aas_plane_t) + aasworld.numareas * sizeof(aas_area_t) + aasworld.numareasettings * sizeof(aas_areasettings_t) + aasworld.numnodes * sizeof(aas_node_t) + aasworld.reachabilitysize * sizeof(aas_reachability_t) + aasworld.numportals * sizeof(aas_portal_t) + aasworld.numclusters * sizeof(aas_cluster_t);
+	optimized = (*aasworld).numplanes * sizeof(aas_plane_t) + (*aasworld).numareas * sizeof(aas_area_t) + (*aasworld).numareasettings * sizeof(aas_areasettings_t) + (*aasworld).numnodes * sizeof(aas_node_t) + (*aasworld).reachabilitysize * sizeof(aas_reachability_t) + (*aasworld).numportals * sizeof(aas_portal_t) + (*aasworld).numclusters * sizeof(aas_cluster_t);
 	botimport.Print(PRT_MESSAGE, "optimized size %d KB\n", optimized >> 10);
 }
 #endif // AASFILEDEBUG
@@ -398,7 +398,7 @@
 	// check the version
 	header.version = LittleLong(header.version);
 
-	if (header.version != AASVERSION_OLD && header.version != AASVERSION) {
+	if (header.version != AASVERSION) {
 		AAS_Error("aas file %s is version %i, not %i\n", filename, header.version, AASVERSION);
 		botimport.FS_FCloseFile(fp);
 		return BLERR_WRONGAASFILEVERSION;
@@ -409,9 +409,9 @@
 	}
 // Tobias HACK: temporarely stop checking AAS/BSP checksums
 /*
-	aasworld.bspchecksum = atoi(LibVarGetString("sv_mapChecksum"));
+	(*aasworld).bspchecksum = atoi(LibVarGetString("sv_mapChecksum"));
 
-	if (LittleLong(header.bspchecksum) != aasworld.bspchecksum) {
+	if (LittleLong(header.bspchecksum) != (*aasworld).bspchecksum) {
 		AAS_Error("aas file %s is out of date\n", filename);
 		botimport.FS_FCloseFile(fp);
 		return BLERR_WRONGAASFILEVERSION;
@@ -422,133 +422,133 @@
 	// bounding boxes
 	offset = LittleLong(header.lumps[AASLUMP_BBOXES].fileofs);
 	length = LittleLong(header.lumps[AASLUMP_BBOXES].filelen);
-	aasworld.bboxes = (aas_bbox_t *)AAS_LoadAASLump(fp, offset, length, &lastoffset, sizeof(aas_bbox_t));
-	aasworld.numbboxes = length / sizeof(aas_bbox_t);
+	(*aasworld).bboxes = (aas_bbox_t *)AAS_LoadAASLump(fp, offset, length, &lastoffset, sizeof(aas_bbox_t));
+	(*aasworld).numbboxes = length / sizeof(aas_bbox_t);
 
-	if (aasworld.numbboxes && !aasworld.bboxes) {
+	if ((*aasworld).numbboxes && !(*aasworld).bboxes) {
 		return BLERR_CANNOTREADAASLUMP;
 	}
 	// vertexes
 	offset = LittleLong(header.lumps[AASLUMP_VERTEXES].fileofs);
 	length = LittleLong(header.lumps[AASLUMP_VERTEXES].filelen);
-	aasworld.vertexes = (aas_vertex_t *)AAS_LoadAASLump(fp, offset, length, &lastoffset, sizeof(aas_vertex_t));
-	aasworld.numvertexes = length / sizeof(aas_vertex_t);
+	(*aasworld).vertexes = (aas_vertex_t *)AAS_LoadAASLump(fp, offset, length, &lastoffset, sizeof(aas_vertex_t));
+	(*aasworld).numvertexes = length / sizeof(aas_vertex_t);
 
-	if (aasworld.numvertexes && !aasworld.vertexes) {
+	if ((*aasworld).numvertexes && !(*aasworld).vertexes) {
 		return BLERR_CANNOTREADAASLUMP;
 	}
 	// planes
 	offset = LittleLong(header.lumps[AASLUMP_PLANES].fileofs);
 	length = LittleLong(header.lumps[AASLUMP_PLANES].filelen);
-	aasworld.planes = (aas_plane_t *)AAS_LoadAASLump(fp, offset, length, &lastoffset, sizeof(aas_plane_t));
-	aasworld.numplanes = length / sizeof(aas_plane_t);
+	(*aasworld).planes = (aas_plane_t *)AAS_LoadAASLump(fp, offset, length, &lastoffset, sizeof(aas_plane_t));
+	(*aasworld).numplanes = length / sizeof(aas_plane_t);
 
-	if (aasworld.numplanes && !aasworld.planes) {
+	if ((*aasworld).numplanes && !(*aasworld).planes) {
 		return BLERR_CANNOTREADAASLUMP;
 	}
 	// edges
 	offset = LittleLong(header.lumps[AASLUMP_EDGES].fileofs);
 	length = LittleLong(header.lumps[AASLUMP_EDGES].filelen);
-	aasworld.edges = (aas_edge_t *)AAS_LoadAASLump(fp, offset, length, &lastoffset, sizeof(aas_edge_t));
-	aasworld.numedges = length / sizeof(aas_edge_t);
+	(*aasworld).edges = (aas_edge_t *)AAS_LoadAASLump(fp, offset, length, &lastoffset, sizeof(aas_edge_t));
+	(*aasworld).numedges = length / sizeof(aas_edge_t);
 
-	if (aasworld.numedges && !aasworld.edges) {
+	if ((*aasworld).numedges && !(*aasworld).edges) {
 		return BLERR_CANNOTREADAASLUMP;
 	}
 	// edgeindex
 	offset = LittleLong(header.lumps[AASLUMP_EDGEINDEX].fileofs);
 	length = LittleLong(header.lumps[AASLUMP_EDGEINDEX].filelen);
-	aasworld.edgeindex = (aas_edgeindex_t *)AAS_LoadAASLump(fp, offset, length, &lastoffset, sizeof(aas_edgeindex_t));
-	aasworld.edgeindexsize = length / sizeof(aas_edgeindex_t);
+	(*aasworld).edgeindex = (aas_edgeindex_t *)AAS_LoadAASLump(fp, offset, length, &lastoffset, sizeof(aas_edgeindex_t));
+	(*aasworld).edgeindexsize = length / sizeof(aas_edgeindex_t);
 
-	if (aasworld.edgeindexsize && !aasworld.edgeindex) {
+	if ((*aasworld).edgeindexsize && !(*aasworld).edgeindex) {
 		return BLERR_CANNOTREADAASLUMP;
 	}
 	// faces
 	offset = LittleLong(header.lumps[AASLUMP_FACES].fileofs);
 	length = LittleLong(header.lumps[AASLUMP_FACES].filelen);
-	aasworld.faces = (aas_face_t *)AAS_LoadAASLump(fp, offset, length, &lastoffset, sizeof(aas_face_t));
-	aasworld.numfaces = length / sizeof(aas_face_t);
+	(*aasworld).faces = (aas_face_t *)AAS_LoadAASLump(fp, offset, length, &lastoffset, sizeof(aas_face_t));
+	(*aasworld).numfaces = length / sizeof(aas_face_t);
 
-	if (aasworld.numfaces && !aasworld.faces) {
+	if ((*aasworld).numfaces && !(*aasworld).faces) {
 		return BLERR_CANNOTREADAASLUMP;
 	}
 	// faceindex
 	offset = LittleLong(header.lumps[AASLUMP_FACEINDEX].fileofs);
 	length = LittleLong(header.lumps[AASLUMP_FACEINDEX].filelen);
-	aasworld.faceindex = (aas_faceindex_t *)AAS_LoadAASLump(fp, offset, length, &lastoffset, sizeof(aas_faceindex_t));
-	aasworld.faceindexsize = length / sizeof(aas_faceindex_t);
+	(*aasworld).faceindex = (aas_faceindex_t *)AAS_LoadAASLump(fp, offset, length, &lastoffset, sizeof(aas_faceindex_t));
+	(*aasworld).faceindexsize = length / sizeof(aas_faceindex_t);
 
-	if (aasworld.faceindexsize && !aasworld.faceindex) {
+	if ((*aasworld).faceindexsize && !(*aasworld).faceindex) {
 		return BLERR_CANNOTREADAASLUMP;
 	}
 	// convex areas
 	offset = LittleLong(header.lumps[AASLUMP_AREAS].fileofs);
 	length = LittleLong(header.lumps[AASLUMP_AREAS].filelen);
-	aasworld.areas = (aas_area_t *)AAS_LoadAASLump(fp, offset, length, &lastoffset, sizeof(aas_area_t));
-	aasworld.numareas = length / sizeof(aas_area_t);
+	(*aasworld).areas = (aas_area_t *)AAS_LoadAASLump(fp, offset, length, &lastoffset, sizeof(aas_area_t));
+	(*aasworld).numareas = length / sizeof(aas_area_t);
 
-	if (aasworld.numareas && !aasworld.areas) {
+	if ((*aasworld).numareas && !(*aasworld).areas) {
 		return BLERR_CANNOTREADAASLUMP;
 	}
 	// area settings
 	offset = LittleLong(header.lumps[AASLUMP_AREASETTINGS].fileofs);
 	length = LittleLong(header.lumps[AASLUMP_AREASETTINGS].filelen);
-	aasworld.areasettings = (aas_areasettings_t *)AAS_LoadAASLump(fp, offset, length, &lastoffset, sizeof(aas_areasettings_t));
-	aasworld.numareasettings = length / sizeof(aas_areasettings_t);
+	(*aasworld).areasettings = (aas_areasettings_t *)AAS_LoadAASLump(fp, offset, length, &lastoffset, sizeof(aas_areasettings_t));
+	(*aasworld).numareasettings = length / sizeof(aas_areasettings_t);
 
-	if (aasworld.numareasettings && !aasworld.areasettings) {
+	if ((*aasworld).numareasettings && !(*aasworld).areasettings) {
 		return BLERR_CANNOTREADAASLUMP;
 	}
 	// reachability list
 	offset = LittleLong(header.lumps[AASLUMP_REACHABILITY].fileofs);
 	length = LittleLong(header.lumps[AASLUMP_REACHABILITY].filelen);
-	aasworld.reachability = (aas_reachability_t *)AAS_LoadAASLump(fp, offset, length, &lastoffset, sizeof(aas_reachability_t));
-	aasworld.reachabilitysize = length / sizeof(aas_reachability_t);
+	(*aasworld).reachability = (aas_reachability_t *)AAS_LoadAASLump(fp, offset, length, &lastoffset, sizeof(aas_reachability_t));
+	(*aasworld).reachabilitysize = length / sizeof(aas_reachability_t);
 
-	if (aasworld.reachabilitysize && !aasworld.reachability) {
+	if ((*aasworld).reachabilitysize && !(*aasworld).reachability) {
 		return BLERR_CANNOTREADAASLUMP;
 	}
 	// nodes
 	offset = LittleLong(header.lumps[AASLUMP_NODES].fileofs);
 	length = LittleLong(header.lumps[AASLUMP_NODES].filelen);
-	aasworld.nodes = (aas_node_t *)AAS_LoadAASLump(fp, offset, length, &lastoffset, sizeof(aas_node_t));
-	aasworld.numnodes = length / sizeof(aas_node_t);
+	(*aasworld).nodes = (aas_node_t *)AAS_LoadAASLump(fp, offset, length, &lastoffset, sizeof(aas_node_t));
+	(*aasworld).numnodes = length / sizeof(aas_node_t);
 
-	if (aasworld.numnodes && !aasworld.nodes) {
+	if ((*aasworld).numnodes && !(*aasworld).nodes) {
 		return BLERR_CANNOTREADAASLUMP;
 	}
 	// cluster portals
 	offset = LittleLong(header.lumps[AASLUMP_PORTALS].fileofs);
 	length = LittleLong(header.lumps[AASLUMP_PORTALS].filelen);
-	aasworld.portals = (aas_portal_t *)AAS_LoadAASLump(fp, offset, length, &lastoffset, sizeof(aas_portal_t));
-	aasworld.numportals = length / sizeof(aas_portal_t);
+	(*aasworld).portals = (aas_portal_t *)AAS_LoadAASLump(fp, offset, length, &lastoffset, sizeof(aas_portal_t));
+	(*aasworld).numportals = length / sizeof(aas_portal_t);
 
-	if (aasworld.numportals && !aasworld.portals) {
+	if ((*aasworld).numportals && !(*aasworld).portals) {
 		return BLERR_CANNOTREADAASLUMP;
 	}
 	// cluster portal index
 	offset = LittleLong(header.lumps[AASLUMP_PORTALINDEX].fileofs);
 	length = LittleLong(header.lumps[AASLUMP_PORTALINDEX].filelen);
-	aasworld.portalindex = (aas_portalindex_t *)AAS_LoadAASLump(fp, offset, length, &lastoffset, sizeof(aas_portalindex_t));
-	aasworld.portalindexsize = length / sizeof(aas_portalindex_t);
+	(*aasworld).portalindex = (aas_portalindex_t *)AAS_LoadAASLump(fp, offset, length, &lastoffset, sizeof(aas_portalindex_t));
+	(*aasworld).portalindexsize = length / sizeof(aas_portalindex_t);
 
-	if (aasworld.portalindexsize && !aasworld.portalindex) {
+	if ((*aasworld).portalindexsize && !(*aasworld).portalindex) {
 		return BLERR_CANNOTREADAASLUMP;
 	}
 	// clusters
 	offset = LittleLong(header.lumps[AASLUMP_CLUSTERS].fileofs);
 	length = LittleLong(header.lumps[AASLUMP_CLUSTERS].filelen);
-	aasworld.clusters = (aas_cluster_t *)AAS_LoadAASLump(fp, offset, length, &lastoffset, sizeof(aas_cluster_t));
-	aasworld.numclusters = length / sizeof(aas_cluster_t);
+	(*aasworld).clusters = (aas_cluster_t *)AAS_LoadAASLump(fp, offset, length, &lastoffset, sizeof(aas_cluster_t));
+	(*aasworld).numclusters = length / sizeof(aas_cluster_t);
 
-	if (aasworld.numclusters && !aasworld.clusters) {
+	if ((*aasworld).numclusters && !(*aasworld).clusters) {
 		return BLERR_CANNOTREADAASLUMP;
 	}
 	// swap everything
 	AAS_SwapAASData();
 	// aas file is loaded
-	aasworld.loaded = qtrue;
+	(*aasworld).loaded = qtrue;
 	// close the file
 	botimport.FS_FCloseFile(fp);
 #ifdef AASFILEDEBUG
@@ -598,7 +598,7 @@
 
 	header.ident = LittleLong(AASID);
 	header.version = LittleLong(AASVERSION);
-	header.bspchecksum = LittleLong(aasworld.bspchecksum);
+	header.bspchecksum = LittleLong((*aasworld).bspchecksum);
 	// open a new file
 	botimport.FS_FOpenFile(filename, &fp, FS_WRITE);
 
@@ -611,59 +611,59 @@
 
 	AAS_WriteAASLump_offset = sizeof(aas_header_t);
 	// add the data lumps to the file
-	if (!AAS_WriteAASLump(fp, &header, AASLUMP_BBOXES, aasworld.bboxes, aasworld.numbboxes * sizeof(aas_bbox_t))) {
+	if (!AAS_WriteAASLump(fp, &header, AASLUMP_BBOXES, (*aasworld).bboxes, (*aasworld).numbboxes * sizeof(aas_bbox_t))) {
 		return qfalse;
 	}
 
-	if (!AAS_WriteAASLump(fp, &header, AASLUMP_VERTEXES, aasworld.vertexes, aasworld.numvertexes * sizeof(aas_vertex_t))) {
+	if (!AAS_WriteAASLump(fp, &header, AASLUMP_VERTEXES, (*aasworld).vertexes, (*aasworld).numvertexes * sizeof(aas_vertex_t))) {
 		return qfalse;
 	}
 
-	if (!AAS_WriteAASLump(fp, &header, AASLUMP_PLANES, aasworld.planes, aasworld.numplanes * sizeof(aas_plane_t))) {
+	if (!AAS_WriteAASLump(fp, &header, AASLUMP_PLANES, (*aasworld).planes, (*aasworld).numplanes * sizeof(aas_plane_t))) {
 		return qfalse;
 	}
 
-	if (!AAS_WriteAASLump(fp, &header, AASLUMP_EDGES, aasworld.edges, aasworld.numedges * sizeof(aas_edge_t))) {
+	if (!AAS_WriteAASLump(fp, &header, AASLUMP_EDGES, (*aasworld).edges, (*aasworld).numedges * sizeof(aas_edge_t))) {
 		return qfalse;
 	}
 
-	if (!AAS_WriteAASLump(fp, &header, AASLUMP_EDGEINDEX, aasworld.edgeindex, aasworld.edgeindexsize * sizeof(aas_edgeindex_t))) {
+	if (!AAS_WriteAASLump(fp, &header, AASLUMP_EDGEINDEX, (*aasworld).edgeindex, (*aasworld).edgeindexsize * sizeof(aas_edgeindex_t))) {
 		return qfalse;
 	}
 
-	if (!AAS_WriteAASLump(fp, &header, AASLUMP_FACES, aasworld.faces, aasworld.numfaces * sizeof(aas_face_t))) {
+	if (!AAS_WriteAASLump(fp, &header, AASLUMP_FACES, (*aasworld).faces, (*aasworld).numfaces * sizeof(aas_face_t))) {
 		return qfalse;
 	}
 
-	if (!AAS_WriteAASLump(fp, &header, AASLUMP_FACEINDEX, aasworld.faceindex, aasworld.faceindexsize * sizeof(aas_faceindex_t))) {
+	if (!AAS_WriteAASLump(fp, &header, AASLUMP_FACEINDEX, (*aasworld).faceindex, (*aasworld).faceindexsize * sizeof(aas_faceindex_t))) {
 		return qfalse;
 	}
 
-	if (!AAS_WriteAASLump(fp, &header, AASLUMP_AREAS, aasworld.areas, aasworld.numareas * sizeof(aas_area_t))) {
+	if (!AAS_WriteAASLump(fp, &header, AASLUMP_AREAS, (*aasworld).areas, (*aasworld).numareas * sizeof(aas_area_t))) {
 		return qfalse;
 	}
 
-	if (!AAS_WriteAASLump(fp, &header, AASLUMP_AREASETTINGS, aasworld.areasettings, aasworld.numareasettings * sizeof(aas_areasettings_t))) {
+	if (!AAS_WriteAASLump(fp, &header, AASLUMP_AREASETTINGS, (*aasworld).areasettings, (*aasworld).numareasettings * sizeof(aas_areasettings_t))) {
 		return qfalse;
 	}
 
-	if (!AAS_WriteAASLump(fp, &header, AASLUMP_REACHABILITY, aasworld.reachability, aasworld.reachabilitysize * sizeof(aas_reachability_t))) {
+	if (!AAS_WriteAASLump(fp, &header, AASLUMP_REACHABILITY, (*aasworld).reachability, (*aasworld).reachabilitysize * sizeof(aas_reachability_t))) {
 		return qfalse;
 	}
 
-	if (!AAS_WriteAASLump(fp, &header, AASLUMP_NODES, aasworld.nodes, aasworld.numnodes * sizeof(aas_node_t))) {
+	if (!AAS_WriteAASLump(fp, &header, AASLUMP_NODES, (*aasworld).nodes, (*aasworld).numnodes * sizeof(aas_node_t))) {
 		return qfalse;
 	}
 
-	if (!AAS_WriteAASLump(fp, &header, AASLUMP_PORTALS, aasworld.portals, aasworld.numportals * sizeof(aas_portal_t))) {
+	if (!AAS_WriteAASLump(fp, &header, AASLUMP_PORTALS, (*aasworld).portals, (*aasworld).numportals * sizeof(aas_portal_t))) {
 		return qfalse;
 	}
 
-	if (!AAS_WriteAASLump(fp, &header, AASLUMP_PORTALINDEX, aasworld.portalindex, aasworld.portalindexsize * sizeof(aas_portalindex_t))) {
+	if (!AAS_WriteAASLump(fp, &header, AASLUMP_PORTALINDEX, (*aasworld).portalindex, (*aasworld).portalindexsize * sizeof(aas_portalindex_t))) {
 		return qfalse;
 	}
 
-	if (!AAS_WriteAASLump(fp, &header, AASLUMP_CLUSTERS, aasworld.clusters, aasworld.numclusters * sizeof(aas_cluster_t))) {
+	if (!AAS_WriteAASLump(fp, &header, AASLUMP_CLUSTERS, (*aasworld).clusters, (*aasworld).numclusters * sizeof(aas_cluster_t))) {
 		return qfalse;
 	}
 	// rewrite the header with the added lumps
Index: code/botlib/be_aas_main.c
===================================================================
--- code/botlib/be_aas_main.c	(revision 1306)
+++ code/botlib/be_aas_main.c	(working copy)
@@ -41,7 +41,8 @@
 #include "be_interface.h"
 #include "be_aas_def.h"
 
-aas_t aasworld;
+aas_t aasworlds[MAX_AAS_WORLDS];
+aas_t *aasworld;
 
 libvar_t *saveroutingcache;
 
@@ -67,7 +68,7 @@
 =======================================================================================================================================
 */
 int AAS_Loaded(void) {
-	return aasworld.loaded;
+	return (*aasworld).loaded;
 }
 
 /*
@@ -76,7 +77,7 @@
 =======================================================================================================================================
 */
 int AAS_Initialized(void) {
-	return aasworld.initialized;
+	return (*aasworld).initialized;
 }
 
 /*
@@ -86,7 +87,7 @@
 */
 void AAS_SetInitialized(void) {
 
-	aasworld.initialized = qtrue;
+	(*aasworld).initialized = qtrue;
 	botimport.Print(PRT_MESSAGE, "AAS initialized.\n");
 #ifdef DEBUG
 	// create all the routing cache
@@ -103,11 +104,11 @@
 void AAS_ContinueInit(float time) {
 
 	// if no AAS file loaded
-	if (!aasworld.loaded) {
+	if (!(*aasworld).loaded) {
 		return;
 	}
 	// if AAS is already initialized
-	if (aasworld.initialized) {
+	if ((*aasworld).initialized) {
 		return;
 	}
 	// calculate reachability, if not finished return
@@ -117,16 +118,16 @@
 	// initialize clustering for the new map
 	AAS_InitClustering();
 	// if reachability has been calculated and an AAS file should be written or there is a forced data optimization
-	if (aasworld.savefile || ((int)LibVarGetValue("forcewrite"))) {
+	if ((*aasworld).savefile || ((int)LibVarGetValue("forcewrite"))) {
 		// optimize the AAS data
 		if ((int)LibVarValue("aasoptimize", "0")) {
 			AAS_Optimize();
 		}
 		// save the AAS file
-		if (AAS_WriteAASFile(aasworld.filename)) {
-			botimport.Print(PRT_MESSAGE, "%s written successfully\n", aasworld.filename);
+		if (AAS_WriteAASFile((*aasworld).filename)) {
+			botimport.Print(PRT_MESSAGE, "%s written successfully\n", (*aasworld).filename);
 		} else {
-			botimport.Print(PRT_ERROR, "couldn't write %s\n", aasworld.filename);
+			botimport.Print(PRT_ERROR, "couldn't write %s\n", (*aasworld).filename);
 		}
 	}
 	// initialize the routing
@@ -143,40 +144,46 @@
 =======================================================================================================================================
 */
 int AAS_StartFrame(float time) {
+	int i;
 
-	aasworld.time = time;
-	// unlink all entities that were not updated last frame
-	AAS_UnlinkInvalidEntities();
-	// invalidate the entities
-	AAS_InvalidateEntities();
-	// initialize AAS
-	AAS_ContinueInit(time);
+	// do each of the aasworlds
+	for (i = 0; i < MAX_AAS_WORLDS; i++) {
+		AAS_SetCurrentWorld(i);
 
-	aasworld.frameroutingupdates = 0;
+		(*aasworld).time = time;
+		// unlink all entities that were not updated last frame
+		AAS_UnlinkInvalidEntities();
+		// invalidate the entities
+		AAS_InvalidateEntities();
+		// initialize AAS
+		AAS_ContinueInit(time);
 
-	if (botDeveloper) {
-		if (LibVarGetValue("showcacheupdates")) {
-			AAS_RoutingInfo();
-			LibVarSet("showcacheupdates", "0");
-		}
+		(*aasworld).frameroutingupdates = 0;
 
-		if (LibVarGetValue("showmemoryusage")) {
-			PrintUsedMemorySize();
-			LibVarSet("showmemoryusage", "0");
+		if (botDeveloper) {
+			if (LibVarGetValue("showcacheupdates")) {
+				AAS_RoutingInfo();
+				LibVarSet("showcacheupdates", "0");
+			}
+
+			if (LibVarGetValue("showmemoryusage")) {
+				PrintUsedMemorySize();
+				LibVarSet("showmemoryusage", "0");
+			}
+
+			if (LibVarGetValue("memorydump")) {
+				PrintMemoryLabels();
+				LibVarSet("memorydump", "0");
+			}
 		}
 
-		if (LibVarGetValue("memorydump")) {
-			PrintMemoryLabels();
-			LibVarSet("memorydump", "0");
+		if (saveroutingcache->value) {
+			AAS_WriteRouteCache();
+			LibVarSet("saveroutingcache", "0");
 		}
 	}
 
-	if (saveroutingcache->value) {
-		AAS_WriteRouteCache();
-		LibVarSet("saveroutingcache", "0");
-	}
-
-	aasworld.numframes++;
+	(*aasworld).numframes++;
 	return BLERR_NOERROR;
 }
 
@@ -186,7 +193,7 @@
 =======================================================================================================================================
 */
 float AAS_Time(void) {
-	return aasworld.time;
+	return (*aasworld).time;
 }
 
 /*
@@ -213,7 +220,7 @@
 	int errnum;
 	char aasfile[MAX_QPATH];
 
-	Q_strncpyz(aasworld.mapname, mapname, sizeof(aasworld.mapname));
+	Q_strncpyz((*aasworld).mapname, mapname, sizeof((*aasworld).mapname));
 	// NOTE: first reset the entity links into the AAS areas and BSP leaves
 	// the AAS link heap and BSP link heap are reset after respectively the AAS file and BSP file are loaded
 	AAS_ResetEntityLinks();
@@ -230,10 +237,11 @@
 
 	botimport.Print(PRT_MESSAGE, "loaded %s\n", aasfile);
 
-	Q_strncpyz(aasworld.filename, aasfile, sizeof(aasworld.filename));
+	Q_strncpyz((*aasworld).filename, aasfile, sizeof((*aasworld).filename));
 	return BLERR_NOERROR;
 }
 
+#define MAPNAME_LEN 256
 /*
 =======================================================================================================================================
 AAS_LoadMap
@@ -242,34 +250,55 @@
 =======================================================================================================================================
 */
 int AAS_LoadMap(const char *mapname) {
-	int errnum;
+	int missingErrNum, i, errnum;
+	char this_mapname[MAPNAME_LEN], intstr[4];
+	qboolean loaded;
 
-	// if no mapname is provided then the string indexes are updated
-	if (!mapname) {
-		return 0;
-	}
+	loaded = qfalse;
+	missingErrNum = 0;
 
-	aasworld.initialized = qfalse;
-	// NOTE: free the routing caches before loading a new map because to free the caches the old number of areas, number of clusters
-	// and number of areas in a clusters must be available
-	AAS_FreeRoutingCaches();
-	// load the map
-	errnum = AAS_LoadFiles(mapname);
+	for (i = 0; i < MAX_AAS_WORLDS; i++) {
+		AAS_SetCurrentWorld(i);
 
-	if (errnum != BLERR_NOERROR) {
-		aasworld.loaded = qfalse;
-		return errnum;
+		Q_strncpyz(this_mapname, mapname, sizeof(this_mapname));
+		Q_strcat(this_mapname, sizeof(this_mapname) - strlen(this_mapname) - 1, "_b");
+		Com_sprintf(intstr, sizeof(intstr), "%i", i);
+		Q_strcat(this_mapname, sizeof(this_mapname) - strlen(this_mapname) - 1, intstr);
+		// if no mapname is provided then the string indexes are updated
+		if (!mapname) {
+			return 0;
+		}
+
+		(*aasworld).initialized = qfalse;
+		// NOTE: free the routing caches before loading a new map because to free the caches the old number of areas, number of clusters
+		// and number of areas in a clusters must be available
+		AAS_FreeRoutingCaches();
+		// load the map
+		errnum = AAS_LoadFiles(this_mapname);
+
+		if (errnum != BLERR_NOERROR) {
+			(*aasworld).loaded = qfalse;
+			// we are allowed to skip one of the files, but not both
+			missingErrNum = errnum;
+			continue;
+		}
+
+		loaded = qtrue;
+
+		AAS_InitSettings();
+		// initialize the AAS link heap for the new map
+		AAS_InitAASLinkHeap();
+		// initialize the AAS linked entities for the new map
+		AAS_InitAASLinkedEntities();
+		// initialize reachability for the new map
+		AAS_InitReachability();
+		// initialize the alternative routing
+		AAS_InitAlternativeRouting();
 	}
 
-	AAS_InitSettings();
-	// initialize the AAS link heap for the new map
-	AAS_InitAASLinkHeap();
-	// initialize the AAS linked entities for the new map
-	AAS_InitAASLinkedEntities();
-	// initialize reachability for the new map
-	AAS_InitReachability();
-	// initialize the alternative routing
-	AAS_InitAlternativeRouting();
+	if (!loaded) {
+		return missingErrNum;
+	}
 	// everything went ok
 	return 0;
 }
@@ -283,50 +312,78 @@
 */
 int AAS_Setup(void) {
 
-	aasworld.maxclients = (int)LibVarValue("maxclients", "128");
-	aasworld.maxentities = (int)LibVarValue("maxentities", "1024");
+	// just use the default world for entities
+	AAS_SetCurrentWorld(0);
+
+	(*aasworlds).maxclients = (int)LibVarValue("maxclients", "128");
+	(*aasworlds).maxentities = (int)LibVarValue("maxentities", "2048");
 	// as soon as it's set to 1 the routing cache will be saved
 	saveroutingcache = LibVar("saveroutingcache", "0");
 	// allocate memory for the entities
-	if (aasworld.entities) {
-		FreeMemory(aasworld.entities);
+	if ((*aasworld).entities) {
+		FreeMemory((*aasworld).entities);
 	}
 
-	aasworld.entities = (aas_entity_t *)GetClearedHunkMemory(aasworld.maxentities * sizeof(aas_entity_t));
+	(*aasworld).entities = (aas_entity_t *)GetClearedHunkMemory((*aasworld).maxentities * sizeof(aas_entity_t));
 	// invalidate all the entities
 	AAS_InvalidateEntities();
 	// force some recalculations
 	//LibVarSet("forceclustering", "1"); // force clustering calculation
 	//LibVarSet("forcereachability", "1"); // force reachability calculation
-	aasworld.numframes = 0;
+	(*aasworld).numframes = 0;
 	return BLERR_NOERROR;
 }
 
 /*
 =======================================================================================================================================
+AAS_SetCurrentWorld
+
+Multiple AAS worlds.
+=======================================================================================================================================
+*/
+void AAS_SetCurrentWorld(int index) {
+
+	if (index >= MAX_AAS_WORLDS || index < 0) {
+		AAS_Error("AAS_SetCurrentWorld: index out of range\n");
+		return;
+	}
+	// set the current world pointer
+	aasworld = &aasworlds[index];
+}
+
+/*
+=======================================================================================================================================
 AAS_Shutdown
 =======================================================================================================================================
 */
 void AAS_Shutdown(void) {
+	int i;
 
-	AAS_ShutdownAlternativeRouting();
-	AAS_DumpBSPData();
-	// free routing caches
-	AAS_FreeRoutingCaches();
-	// free aas link heap
-	AAS_FreeAASLinkHeap();
-	// free aas linked entities
-	AAS_FreeAASLinkedEntities();
-	// free the aas data
-	AAS_DumpAASData();
-	// free the entities
-	if (aasworld.entities) {
-		FreeMemory(aasworld.entities);
+	// do each of the worlds
+	for (i = 0; i < MAX_AAS_WORLDS; i++) {
+		AAS_SetCurrentWorld(i);
+		AAS_ShutdownAlternativeRouting();
+		AAS_DumpBSPData();
+		// free routing caches
+		AAS_FreeRoutingCaches();
+		// free aas link heap
+		AAS_FreeAASLinkHeap();
+		// free aas linked entities
+		AAS_FreeAASLinkedEntities();
+		// free the aas data
+		AAS_DumpAASData();
+
+		if (i == 0) {
+			// free the entities
+			if ((*aasworld).entities) {
+				FreeMemory((*aasworld).entities);
+			}
+		}
+		// clear the (*aasworld) structure
+		Com_Memset(&(*aasworld), 0, sizeof(aas_t));
+		// aas has not been initialized
+		(*aasworld).initialized = qfalse;
 	}
-	// clear the aasworld structure
-	Com_Memset(&aasworld, 0, sizeof(aas_t));
-	// aas has not been initialized
-	aasworld.initialized = qfalse;
 	// NOTE: as soon as a new .bsp file is loaded the .bsp file memory is freed and reallocated, so there's no need to free that memory here
 	// print shutdown
 	botimport.Print(PRT_MESSAGE, "AAS shutdown.\n");
Index: code/botlib/be_aas_main.h
===================================================================
--- code/botlib/be_aas_main.h	(revision 1306)
+++ code/botlib/be_aas_main.h	(working copy)
@@ -23,7 +23,7 @@
 */
 
 #ifdef AASINTERN
-extern aas_t aasworld;
+extern aas_t (*aasworld);
 // AAS error message
 void QDECL AAS_Error(char *fmt, ...) __attribute__((format(printf, 1, 2)));
 // set AAS initialized
@@ -44,3 +44,4 @@
 // returns the current time
 float AAS_Time(void);
 void AAS_ProjectPointOntoVector(vec3_t point, vec3_t vStart, vec3_t vEnd, vec3_t vProj);
+void AAS_SetCurrentWorld(int index);
Index: code/botlib/be_aas_move.c
===================================================================
--- code/botlib/be_aas_move.c	(revision 1306)
+++ code/botlib/be_aas_move.c	(working copy)
@@ -162,26 +162,26 @@
 		return qfalse;
 	}
 	// if not in a ladder area
-	if (!(aasworld.areasettings[areanum].areaflags & AREA_LADDER)) {
+	if (!((*aasworld).areasettings[areanum].areaflags & AREA_LADDER)) {
 		return qfalse;
 	}
 	// if a crouch only area
-	if (!(aasworld.areasettings[areanum].presencetype & PRESENCE_NORMAL)) {
+	if (!((*aasworld).areasettings[areanum].presencetype & PRESENCE_NORMAL)) {
 		return qfalse;
 	}
 
-	area = &aasworld.areas[areanum];
+	area = &(*aasworld).areas[areanum];
 
 	for (i = 0; i < area->numfaces; i++) {
-		facenum = aasworld.faceindex[area->firstface + i];
+		facenum = (*aasworld).faceindex[area->firstface + i];
 		side = facenum < 0;
-		face = &aasworld.faces[abs(facenum)];
+		face = &(*aasworld).faces[abs(facenum)];
 		// if the face isn't a ladder face
 		if (!(face->faceflags & FACE_LADDER)) {
 			continue;
 		}
 		// get the plane the face is in
-		plane = &aasworld.planes[face->planenum ^ side];
+		plane = &(*aasworld).planes[face->planenum ^ side];
 		// if the origin is pretty close to the plane
 		if (fabsf(DotProduct(plane->normal, origin) - plane->dist) < 3) {
 			if (AAS_PointInsideFace(abs(facenum), origin, 0.1f)) {
@@ -525,7 +525,7 @@
 		trace->lastarea = 0;
 		trace->planenum = 0;
 		// ZTM: TODO: use the plane of collision
-		trace->plane = aasworld.planes[trace->planenum];
+		trace->plane = (*aasworld).planes[trace->planenum];
 		// trace endpos
 		for (j = 0; j < 3; j++) {
 			trace->endpos[j] = start[j] + dir[j] * frac;
@@ -751,7 +751,7 @@
 					}
 
 					if (stopevent & SE_TOUCHCLUSTERPORTAL) {
-						if (aasworld.areasettings[areas[i]].contents & AREACONTENTS_CLUSTERPORTAL) {
+						if ((*aasworld).areasettings[areas[i]].contents & AREACONTENTS_CLUSTERPORTAL) {
 							VectorCopy(points[i], move->endpos);
 							VectorScale(frame_test_vel, 1 / frametime, move->velocity);
 
@@ -767,7 +767,7 @@
 					}
 
 					if (stopevent & SE_TOUCHTELEPORTER) {
-						if (aasworld.areasettings[areas[i]].contents & AREACONTENTS_TELEPORTER) {
+						if ((*aasworld).areasettings[areas[i]].contents & AREACONTENTS_TELEPORTER) {
 							VectorCopy(points[i], move->endpos);
 							VectorScale(frame_test_vel, 1 / frametime, move->velocity);
 
@@ -783,7 +783,7 @@
 					}
 					// NOTE: if not the first frame
 					if ((stopevent & SE_TOUCHJUMPPAD) && n) {
-						if (aasworld.areasettings[areas[i]].contents & AREACONTENTS_JUMPPAD) {
+						if ((*aasworld).areasettings[areas[i]].contents & AREACONTENTS_JUMPPAD) {
 							VectorCopy(points[i], move->endpos);
 							VectorScale(frame_test_vel, 1 / frametime, move->velocity);
 
@@ -974,15 +974,15 @@
 
 			areanum = AAS_PointAreaNum(org);
 
-			if (aasworld.areasettings[areanum].contents & AREACONTENTS_WATER) {
+			if ((*aasworld).areasettings[areanum].contents & AREACONTENTS_WATER) {
 				event |= SE_ENTERWATER;
 			}
 
-			if (aasworld.areasettings[areanum].contents & AREACONTENTS_LAVA) {
+			if ((*aasworld).areasettings[areanum].contents & AREACONTENTS_LAVA) {
 				event |= SE_ENTERLAVA;
 			}
 
-			if (aasworld.areasettings[areanum].contents & AREACONTENTS_SLIME) {
+			if ((*aasworld).areasettings[areanum].contents & AREACONTENTS_SLIME) {
 				event |= SE_ENTERSLIME;
 			}
 			// if in lava or slime
Index: code/botlib/be_aas_optimize.c
===================================================================
--- code/botlib/be_aas_optimize.c	(revision 1306)
+++ code/botlib/be_aas_optimize.c	(working copy)
@@ -81,7 +81,7 @@
 	int i, optedgenum;
 	aas_edge_t *edge, *optedge;
 
-	edge = &aasworld.edges[abs(edgenum)];
+	edge = &(*aasworld).edges[abs(edgenum)];
 
 	if (!AAS_KeepEdge(edge)) {
 		return 0;
@@ -104,7 +104,7 @@
 		if (optimized->vertexoptimizeindex[edge->v[i]]) {
 			optedge->v[i] = optimized->vertexoptimizeindex[edge->v[i]];
 		} else {
-			VectorCopy(aasworld.vertexes[edge->v[i]], optimized->vertexes[optimized->numvertexes]);
+			VectorCopy((*aasworld).vertexes[edge->v[i]], optimized->vertexes[optimized->numvertexes]);
 			optedge->v[i] = optimized->numvertexes;
 			optimized->vertexoptimizeindex[edge->v[i]] = optimized->numvertexes;
 			optimized->numvertexes++;
@@ -145,7 +145,7 @@
 	int i, edgenum, optedgenum, optfacenum;
 	aas_face_t *face, *optface;
 
-	face = &aasworld.faces[abs(facenum)];
+	face = &(*aasworld).faces[abs(facenum)];
 
 	if (!AAS_KeepFace(face)) {
 		return 0;
@@ -170,7 +170,7 @@
 	optface->firstedge = optimized->edgeindexsize;
 
 	for (i = 0; i < face->numedges; i++) {
-		edgenum = aasworld.edgeindex[face->firstedge + i];
+		edgenum = (*aasworld).edgeindex[face->firstedge + i];
 		optedgenum = AAS_OptimizeEdge(optimized, edgenum);
 
 		if (optedgenum) {
@@ -200,7 +200,7 @@
 	int i, facenum, optfacenum;
 	aas_area_t *area, *optarea;
 
-	area = &aasworld.areas[areanum];
+	area = &(*aasworld).areas[areanum];
 	optarea = &optimized->areas[areanum];
 
 	Com_Memcpy(optarea, area, sizeof(aas_area_t));
@@ -209,7 +209,7 @@
 	optarea->firstface = optimized->faceindexsize;
 
 	for (i = 0; i < area->numfaces; i++) {
-		facenum = aasworld.faceindex[area->firstface + i];
+		facenum = (*aasworld).faceindex[area->firstface + i];
 		optfacenum = AAS_OptimizeFace(optimized, facenum);
 
 		if (optfacenum) {
@@ -227,21 +227,21 @@
 */
 void AAS_OptimizeAlloc(optimized_t *optimized) {
 
-	optimized->vertexes = (aas_vertex_t *)GetClearedMemory(aasworld.numvertexes * sizeof(aas_vertex_t));
+	optimized->vertexes = (aas_vertex_t *)GetClearedMemory((*aasworld).numvertexes * sizeof(aas_vertex_t));
 	optimized->numvertexes = 0;
-	optimized->edges = (aas_edge_t *)GetClearedMemory(aasworld.numedges * sizeof(aas_edge_t));
+	optimized->edges = (aas_edge_t *)GetClearedMemory((*aasworld).numedges * sizeof(aas_edge_t));
 	optimized->numedges = 1; // edge zero is a dummy
-	optimized->edgeindex = (aas_edgeindex_t *)GetClearedMemory(aasworld.edgeindexsize * sizeof(aas_edgeindex_t));
+	optimized->edgeindex = (aas_edgeindex_t *)GetClearedMemory((*aasworld).edgeindexsize * sizeof(aas_edgeindex_t));
 	optimized->edgeindexsize = 0;
-	optimized->faces = (aas_face_t *)GetClearedMemory(aasworld.numfaces * sizeof(aas_face_t));
+	optimized->faces = (aas_face_t *)GetClearedMemory((*aasworld).numfaces * sizeof(aas_face_t));
 	optimized->numfaces = 1; // face zero is a dummy
-	optimized->faceindex = (aas_faceindex_t *)GetClearedMemory(aasworld.faceindexsize * sizeof(aas_faceindex_t));
+	optimized->faceindex = (aas_faceindex_t *)GetClearedMemory((*aasworld).faceindexsize * sizeof(aas_faceindex_t));
 	optimized->faceindexsize = 0;
-	optimized->areas = (aas_area_t *)GetClearedMemory(aasworld.numareas * sizeof(aas_area_t));
-	optimized->numareas = aasworld.numareas;
-	optimized->vertexoptimizeindex = (int *)GetClearedMemory(aasworld.numvertexes * sizeof(int));
-	optimized->edgeoptimizeindex = (int *)GetClearedMemory(aasworld.numedges * sizeof(int));
-	optimized->faceoptimizeindex = (int *)GetClearedMemory(aasworld.numfaces * sizeof(int));
+	optimized->areas = (aas_area_t *)GetClearedMemory((*aasworld).numareas * sizeof(aas_area_t));
+	optimized->numareas = (*aasworld).numareas;
+	optimized->vertexoptimizeindex = (int *)GetClearedMemory((*aasworld).numvertexes * sizeof(int));
+	optimized->edgeoptimizeindex = (int *)GetClearedMemory((*aasworld).numedges * sizeof(int));
+	optimized->faceoptimizeindex = (int *)GetClearedMemory((*aasworld).numfaces * sizeof(int));
 }
 
 /*
@@ -252,47 +252,47 @@
 void AAS_OptimizeStore(optimized_t *optimized) {
 
 	// store the optimized vertexes
-	if (aasworld.vertexes) {
-		FreeMemory(aasworld.vertexes);
+	if ((*aasworld).vertexes) {
+		FreeMemory((*aasworld).vertexes);
 	}
 
-	aasworld.vertexes = optimized->vertexes;
-	aasworld.numvertexes = optimized->numvertexes;
+	(*aasworld).vertexes = optimized->vertexes;
+	(*aasworld).numvertexes = optimized->numvertexes;
 	// store the optimized edges
-	if (aasworld.edges) {
-		FreeMemory(aasworld.edges);
+	if ((*aasworld).edges) {
+		FreeMemory((*aasworld).edges);
 	}
 
-	aasworld.edges = optimized->edges;
-	aasworld.numedges = optimized->numedges;
+	(*aasworld).edges = optimized->edges;
+	(*aasworld).numedges = optimized->numedges;
 	// store the optimized edge index
-	if (aasworld.edgeindex) {
-		FreeMemory(aasworld.edgeindex);
+	if ((*aasworld).edgeindex) {
+		FreeMemory((*aasworld).edgeindex);
 	}
 
-	aasworld.edgeindex = optimized->edgeindex;
-	aasworld.edgeindexsize = optimized->edgeindexsize;
+	(*aasworld).edgeindex = optimized->edgeindex;
+	(*aasworld).edgeindexsize = optimized->edgeindexsize;
 	// store the optimized faces
-	if (aasworld.faces) {
-		FreeMemory(aasworld.faces);
+	if ((*aasworld).faces) {
+		FreeMemory((*aasworld).faces);
 	}
 
-	aasworld.faces = optimized->faces;
-	aasworld.numfaces = optimized->numfaces;
+	(*aasworld).faces = optimized->faces;
+	(*aasworld).numfaces = optimized->numfaces;
 	// store the optimized face index
-	if (aasworld.faceindex) {
-		FreeMemory(aasworld.faceindex);
+	if ((*aasworld).faceindex) {
+		FreeMemory((*aasworld).faceindex);
 	}
 
-	aasworld.faceindex = optimized->faceindex;
-	aasworld.faceindexsize = optimized->faceindexsize;
+	(*aasworld).faceindex = optimized->faceindex;
+	(*aasworld).faceindexsize = optimized->faceindexsize;
 	// store the optimized areas
-	if (aasworld.areas) {
-		FreeMemory(aasworld.areas);
+	if ((*aasworld).areas) {
+		FreeMemory((*aasworld).areas);
 	}
 
-	aasworld.areas = optimized->areas;
-	aasworld.numareas = optimized->numareas;
+	(*aasworld).areas = optimized->areas;
+	(*aasworld).numareas = optimized->numareas;
 	// free optimize indexes
 	FreeMemory(optimized->vertexoptimizeindex);
 	FreeMemory(optimized->edgeoptimizeindex);
@@ -310,39 +310,39 @@
 
 	AAS_OptimizeAlloc(&optimized);
 
-	for (i = 1; i < aasworld.numareas; i++) {
+	for (i = 1; i < (*aasworld).numareas; i++) {
 		AAS_OptimizeArea(&optimized, i);
 	}
 	// reset the reachability face pointers
-	for (i = 0; i < aasworld.reachabilitysize; i++) {
+	for (i = 0; i < (*aasworld).reachabilitysize; i++) {
 		// NOTE: for TRAVEL_ELEVATOR the facenum is the model number of the elevator
-		if ((aasworld.reachability[i].traveltype & TRAVELTYPE_MASK) == TRAVEL_ELEVATOR) {
+		if (((*aasworld).reachability[i].traveltype & TRAVELTYPE_MASK) == TRAVEL_ELEVATOR) {
 			continue;
 		}
 		// NOTE: for TRAVEL_JUMPPAD the facenum is the Z velocity and the edgenum is the hor velocity
-		if ((aasworld.reachability[i].traveltype & TRAVELTYPE_MASK) == TRAVEL_JUMPPAD) {
+		if (((*aasworld).reachability[i].traveltype & TRAVELTYPE_MASK) == TRAVEL_JUMPPAD) {
 			continue;
 		}
 		// NOTE: for TRAVEL_FUNCBOB the facenum and edgenum contain other coded information
-		if ((aasworld.reachability[i].traveltype & TRAVELTYPE_MASK) == TRAVEL_FUNCBOB) {
+		if (((*aasworld).reachability[i].traveltype & TRAVELTYPE_MASK) == TRAVEL_FUNCBOB) {
 			continue;
 		}
 
-		sign = aasworld.reachability[i].facenum;
-		aasworld.reachability[i].facenum = optimized.faceoptimizeindex[abs(aasworld.reachability[i].facenum)];
+		sign = (*aasworld).reachability[i].facenum;
+		(*aasworld).reachability[i].facenum = optimized.faceoptimizeindex[abs((*aasworld).reachability[i].facenum)];
 
 		if (sign < 0) {
-			aasworld.reachability[i].facenum = -aasworld.reachability[i].facenum;
+			(*aasworld).reachability[i].facenum = -(*aasworld).reachability[i].facenum;
 		}
 
-		sign = aasworld.reachability[i].edgenum;
-		aasworld.reachability[i].edgenum = optimized.edgeoptimizeindex[abs(aasworld.reachability[i].edgenum)];
+		sign = (*aasworld).reachability[i].edgenum;
+		(*aasworld).reachability[i].edgenum = optimized.edgeoptimizeindex[abs((*aasworld).reachability[i].edgenum)];
 
 		if (sign < 0) {
-			aasworld.reachability[i].edgenum = -aasworld.reachability[i].edgenum;
+			(*aasworld).reachability[i].edgenum = -(*aasworld).reachability[i].edgenum;
 		}
 	}
-	// store the optimized AAS data into aasworld
+	// store the optimized AAS data into (*aasworld)
 	AAS_OptimizeStore(&optimized);
 	// print some nice stuff :)
 	botimport.Print(PRT_MESSAGE, "AAS data optimized.\n");
Index: code/botlib/be_aas_reach.c
===================================================================
--- code/botlib/be_aas_reach.c	(revision 1306)
+++ code/botlib/be_aas_reach.c	(working copy)
@@ -110,19 +110,19 @@
 	vec3_t d1, d2, cross;
 	aas_edge_t *edge;
 
-	edgenum = aasworld.edgeindex[face->firstedge];
+	edgenum = (*aasworld).edgeindex[face->firstedge];
 	side = edgenum < 0;
-	edge = &aasworld.edges[abs(edgenum)];
-	v = aasworld.vertexes[edge->v[side]];
+	edge = &(*aasworld).edges[abs(edgenum)];
+	v = (*aasworld).vertexes[edge->v[side]];
 	total = 0;
 
 	for (i = 1; i < face->numedges - 1; i++) {
-		edgenum = aasworld.edgeindex[face->firstedge + i];
+		edgenum = (*aasworld).edgeindex[face->firstedge + i];
 		side = edgenum < 0;
-		edge = &aasworld.edges[abs(edgenum)];
+		edge = &(*aasworld).edges[abs(edgenum)];
 
-		VectorSubtract(aasworld.vertexes[edge->v[side]], v, d1);
-		VectorSubtract(aasworld.vertexes[edge->v[!side]], v, d2);
+		VectorSubtract((*aasworld).vertexes[edge->v[side]], v, d1);
+		VectorSubtract((*aasworld).vertexes[edge->v[!side]], v, d2);
 		CrossProduct(d1, d2, cross);
 
 		total += 0.5 * VectorLength(cross);
@@ -147,21 +147,21 @@
 	aas_face_t *face;
 	aas_area_t *area;
 
-	area = &aasworld.areas[areanum];
-	facenum = aasworld.faceindex[area->firstface];
-	face = &aasworld.faces[abs(facenum)];
-	edgenum = aasworld.edgeindex[face->firstedge];
-	edge = &aasworld.edges[abs(edgenum)];
+	area = &(*aasworld).areas[areanum];
+	facenum = (*aasworld).faceindex[area->firstface];
+	face = &(*aasworld).faces[abs(facenum)];
+	edgenum = (*aasworld).edgeindex[face->firstedge];
+	edge = &(*aasworld).edges[abs(edgenum)];
 
-	VectorCopy(aasworld.vertexes[edge->v[0]], corner);
+	VectorCopy((*aasworld).vertexes[edge->v[0]], corner);
 	// make tetrahedrons to all other faces
 	volume = 0;
 
 	for (i = 0; i < area->numfaces; i++) {
-		facenum = abs(aasworld.faceindex[area->firstface + i]);
-		face = &aasworld.faces[facenum];
+		facenum = abs((*aasworld).faceindex[area->firstface + i]);
+		face = &(*aasworld).faces[facenum];
 		side = face->backarea != areanum;
-		plane = &aasworld.planes[face->planenum ^ side];
+		plane = &(*aasworld).planes[face->planenum ^ side];
 		d = -(DotProduct(corner, plane->normal) - plane->dist);
 		a = AAS_FaceArea(face);
 		volume += d * a;
@@ -386,7 +386,7 @@
 	vec3_t start, end;
 	aas_trace_t trace;
 
-	if (!aasworld.loaded) {
+	if (!(*aasworld).loaded) {
 		botimport.Print(PRT_ERROR, "AAS_BestReachableArea: aas not loaded\n");
 		return 0;
 	}
@@ -542,12 +542,12 @@
 */
 int AAS_AreaReachability(int areanum) {
 
-	if (areanum < 0 || areanum >= aasworld.numareas) {
+	if (areanum < 0 || areanum >= (*aasworld).numareas) {
 		AAS_Error("AAS_AreaReachability: areanum %d out of range\n", areanum);
 		return 0;
 	}
 
-	return aasworld.areasettings[areanum].numreachableareas;
+	return (*aasworld).areasettings[areanum].numreachableareas;
 }
 
 /*
@@ -564,10 +564,10 @@
 	aas_face_t *face;
 
 	total = 0;
-	area = &aasworld.areas[areanum];
+	area = &(*aasworld).areas[areanum];
 
 	for (i = 0; i < area->numfaces; i++) {
-		face = &aasworld.faces[abs(aasworld.faceindex[area->firstface + i])];
+		face = &(*aasworld).faces[abs((*aasworld).faceindex[area->firstface + i])];
 
 		if (!(face->faceflags & FACE_GROUND)) {
 			continue;
@@ -592,15 +592,15 @@
 	aas_face_t *face;
 	aas_edge_t *edge;
 
-	face = &aasworld.faces[facenum];
+	face = &(*aasworld).faces[facenum];
 
 	VectorClear(center);
 
 	for (i = 0; i < face->numedges; i++) {
-		edge = &aasworld.edges[abs(aasworld.edgeindex[face->firstedge + i])];
+		edge = &(*aasworld).edges[abs((*aasworld).edgeindex[face->firstedge + i])];
 
-		VectorAdd(center, aasworld.vertexes[edge->v[0]], center);
-		VectorAdd(center, aasworld.vertexes[edge->v[1]], center);
+		VectorAdd(center, (*aasworld).vertexes[edge->v[0]], center);
+		VectorAdd(center, (*aasworld).vertexes[edge->v[1]], center);
 	}
 
 	scale = 0.5 / face->numedges;
@@ -711,7 +711,7 @@
 */
 int AAS_AreaCrouch(int areanum) {
 
-	if (!(aasworld.areasettings[areanum].presencetype & PRESENCE_NORMAL)) {
+	if (!((*aasworld).areasettings[areanum].presencetype & PRESENCE_NORMAL)) {
 		return qtrue;
 	} else {
 		return qfalse;
@@ -727,7 +727,7 @@
 */
 int AAS_AreaSwim(int areanum) {
 
-	if (aasworld.areasettings[areanum].areaflags & AREA_LIQUID) {
+	if ((*aasworld).areasettings[areanum].areaflags & AREA_LIQUID) {
 		return qtrue;
 	} else {
 		return qfalse;
@@ -743,7 +743,7 @@
 */
 int AAS_AreaLiquid(int areanum) {
 
-	if (aasworld.areasettings[areanum].areaflags & AREA_LIQUID) {
+	if ((*aasworld).areasettings[areanum].areaflags & AREA_LIQUID) {
 		return qtrue;
 	} else {
 		return qfalse;
@@ -756,7 +756,7 @@
 =======================================================================================================================================
 */
 int AAS_AreaLava(int areanum) {
-	return (aasworld.areasettings[areanum].contents & AREACONTENTS_LAVA);
+	return ((*aasworld).areasettings[areanum].contents & AREACONTENTS_LAVA);
 }
 
 /*
@@ -765,7 +765,7 @@
 =======================================================================================================================================
 */
 int AAS_AreaSlime(int areanum) {
-	return (aasworld.areasettings[areanum].contents & AREACONTENTS_SLIME);
+	return ((*aasworld).areasettings[areanum].contents & AREACONTENTS_SLIME);
 }
 
 /*
@@ -776,7 +776,7 @@
 =======================================================================================================================================
 */
 int AAS_AreaGrounded(int areanum) {
-	return (aasworld.areasettings[areanum].areaflags & AREA_GROUNDED);
+	return ((*aasworld).areasettings[areanum].areaflags & AREA_GROUNDED);
 }
 
 /*
@@ -787,7 +787,7 @@
 =======================================================================================================================================
 */
 int AAS_AreaLadder(int areanum) {
-	return (aasworld.areasettings[areanum].areaflags & AREA_LADDER);
+	return ((*aasworld).areasettings[areanum].areaflags & AREA_LADDER);
 }
 
 /*
@@ -796,7 +796,7 @@
 =======================================================================================================================================
 */
 int AAS_AreaJumpPad(int areanum) {
-	return (aasworld.areasettings[areanum].contents & AREACONTENTS_JUMPPAD);
+	return ((*aasworld).areasettings[areanum].contents & AREACONTENTS_JUMPPAD);
 }
 
 /*
@@ -805,7 +805,7 @@
 =======================================================================================================================================
 */
 int AAS_AreaTeleporter(int areanum) {
-	return (aasworld.areasettings[areanum].contents & AREACONTENTS_TELEPORTER);
+	return ((*aasworld).areasettings[areanum].contents & AREACONTENTS_TELEPORTER);
 }
 
 /*
@@ -814,7 +814,7 @@
 =======================================================================================================================================
 */
 int AAS_AreaClusterPortal(int areanum) {
-	return (aasworld.areasettings[areanum].contents & AREACONTENTS_CLUSTERPORTAL);
+	return ((*aasworld).areasettings[areanum].contents & AREACONTENTS_CLUSTERPORTAL);
 }
 
 /*
@@ -823,7 +823,7 @@
 =======================================================================================================================================
 */
 int AAS_AreaDoNotEnter(int areanum) {
-	return (aasworld.areasettings[areanum].contents & AREACONTENTS_DONOTENTER);
+	return ((*aasworld).areasettings[areanum].contents & AREACONTENTS_DONOTENTER);
 }
 
 /*
@@ -917,12 +917,12 @@
 		return qfalse;
 	}
 	// if the second area is crouch only
-	if (!(aasworld.areasettings[area2num].presencetype & PRESENCE_NORMAL)) {
+	if (!((*aasworld).areasettings[area2num].presencetype & PRESENCE_NORMAL)) {
 		return qfalse;
 	}
 
-	area1 = &aasworld.areas[area1num];
-	area2 = &aasworld.areas[area2num];
+	area1 = &(*aasworld).areas[area1num];
+	area2 = &(*aasworld).areas[area2num];
 	// if the areas are not near enough
 	for (i = 0; i < 3; i++) {
 		if (area1->mins[i] > area2->maxs[i] + 10) {
@@ -935,18 +935,18 @@
 	}
 	// find a shared face and create a reachability link
 	for (i = 0; i < area1->numfaces; i++) {
-		face1num = aasworld.faceindex[area1->firstface + i];
+		face1num = (*aasworld).faceindex[area1->firstface + i];
 		side1 = face1num < 0;
 		face1num = abs(face1num);
 
 		for (j = 0; j < area2->numfaces; j++) {
-			face2num = abs(aasworld.faceindex[area2->firstface + j]);
+			face2num = abs((*aasworld).faceindex[area2->firstface + j]);
 
 			if (face1num == face2num) {
 				AAS_FaceCenter(face1num, start);
 
 				if (AAS_PointContents(start) & (CONTENTS_LAVA|CONTENTS_SLIME|CONTENTS_WATER)) {
-					face1 = &aasworld.faces[face1num];
+					face1 = &(*aasworld).faces[face1num];
 					// create a new reachability link
 					lreach = AAS_AllocReachability();
 
@@ -958,7 +958,7 @@
 					lreach->facenum = face1num;
 					lreach->edgenum = 0;
 
-					plane = &aasworld.planes[face1->planenum ^ side1];
+					plane = &(*aasworld).planes[face1->planenum ^ side1];
 
 					VectorCopy(start, lreach->start);
 					VectorMA(lreach->start, INSIDEUNITS_SWIM, plane->normal, lreach->end);
@@ -1008,8 +1008,8 @@
 		return qfalse;
 	}
 
-	area1 = &aasworld.areas[area1num];
-	area2 = &aasworld.areas[area2num];
+	area1 = &(*aasworld).areas[area1num];
+	area2 = &(*aasworld).areas[area2num];
 	// if the areas are not near enough in the x-y direction
 	for (i = 0; i < 2; i++) {
 		if (area1->mins[i] > area2->maxs[i] + 10) {
@@ -1036,7 +1036,7 @@
 	// check if the areas have ground faces with a common edge
 	// if existing use the lowest common edge for a reachability link
 	for (i = 0; i < area1->numfaces; i++) {
-		face1 = &aasworld.faces[abs(aasworld.faceindex[area1->firstface + i])];
+		face1 = &(*aasworld).faces[abs((*aasworld).faceindex[area1->firstface + i])];
 
 		if (!(face1->faceflags & FACE_GROUND)) {
 			continue;
@@ -1043,7 +1043,7 @@
 		}
 
 		for (j = 0; j < area2->numfaces; j++) {
-			face2 = &aasworld.faces[abs(aasworld.faceindex[area2->firstface + j])];
+			face2 = &(*aasworld).faces[abs((*aasworld).faceindex[area2->firstface + j])];
 
 			if (!(face2->faceflags & FACE_GROUND)) {
 				continue;
@@ -1051,26 +1051,26 @@
 			// if there is a common edge
 			for (edgenum1 = 0; edgenum1 < face1->numedges; edgenum1++) {
 				for (edgenum2 = 0; edgenum2 < face2->numedges; edgenum2++) {
-					if (abs(aasworld.edgeindex[face1->firstedge + edgenum1]) != abs(aasworld.edgeindex[face2->firstedge + edgenum2])) {
+					if (abs((*aasworld).edgeindex[face1->firstedge + edgenum1]) != abs((*aasworld).edgeindex[face2->firstedge + edgenum2])) {
 						continue;
 					}
 
-					edgenum = aasworld.edgeindex[face1->firstedge + edgenum1];
+					edgenum = (*aasworld).edgeindex[face1->firstedge + edgenum1];
 					side = edgenum < 0;
-					edge = &aasworld.edges[abs(edgenum)];
+					edge = &(*aasworld).edges[abs(edgenum)];
 					// get the length of the edge
-					VectorSubtract(aasworld.vertexes[edge->v[1]], aasworld.vertexes[edge->v[0]], dir);
+					VectorSubtract((*aasworld).vertexes[edge->v[1]], (*aasworld).vertexes[edge->v[0]], dir);
 
 					length = VectorLength(dir);
 					// get the start point
-					VectorAdd(aasworld.vertexes[edge->v[0]], aasworld.vertexes[edge->v[1]], start);
+					VectorAdd((*aasworld).vertexes[edge->v[0]], (*aasworld).vertexes[edge->v[1]], start);
 					VectorScale(start, 0.5, start);
 					VectorCopy(start, end);
 					// get the end point several units inside area2 and the start point several units inside area1
 					// NOTE: normal is pointing into area2 because the face edges are stored counter clockwise
-					VectorSubtract(aasworld.vertexes[edge->v[side]], aasworld.vertexes[edge->v[!side]], edgevec);
+					VectorSubtract((*aasworld).vertexes[edge->v[side]], (*aasworld).vertexes[edge->v[!side]], edgevec);
 
-					plane2 = &aasworld.planes[face2->planenum];
+					plane2 = &(*aasworld).planes[face2->planenum];
 
 					CrossProduct(edgevec, plane2->normal, normal);
 					VectorNormalize(normal);
@@ -1185,8 +1185,8 @@
 		return qfalse;
 	}
 
-	area1 = &aasworld.areas[area1num];
-	area2 = &aasworld.areas[area2num];
+	area1 = &(*aasworld).areas[area1num];
+	area2 = &(*aasworld).areas[area2num];
 	// if the first area contains a liquid
 	area1swim = AAS_AreaSwim(area1num);
 	// if the areas are not near enough in the x-y direction
@@ -1211,15 +1211,15 @@
 	water_bestarea2groundedgenum = 0;
 
 	for (i = 0; i < area1->numfaces; i++) {
-		groundface1num = aasworld.faceindex[area1->firstface + i];
+		groundface1num = (*aasworld).faceindex[area1->firstface + i];
 		faceside1 = groundface1num < 0;
-		groundface1 = &aasworld.faces[abs(groundface1num)];
+		groundface1 = &(*aasworld).faces[abs(groundface1num)];
 		// if this isn't a ground face
 		if (!(groundface1->faceflags & FACE_GROUND)) {
 			// if we can swim in the first area
 			if (area1swim) {
 				// face plane must be more or less horizontal
-				plane = &aasworld.planes[groundface1->planenum ^ (!faceside1)];
+				plane = &(*aasworld).planes[groundface1->planenum ^ (!faceside1)];
 
 				if (DotProduct(plane->normal, invgravity) < 0.7) {
 					continue;
@@ -1231,7 +1231,7 @@
 		}
 
 		for (k = 0; k < groundface1->numedges; k++) {
-			edge1num = aasworld.edgeindex[groundface1->firstedge + k];
+			edge1num = (*aasworld).edgeindex[groundface1->firstedge + k];
 			side1 = (edge1num < 0);
 			// NOTE: for water faces we must take the side area 1 is on into account because the face is shared and doesn't
 			// have to be oriented correctly
@@ -1240,10 +1240,10 @@
 			}
 
 			edge1num = abs(edge1num);
-			edge1 = &aasworld.edges[edge1num];
+			edge1 = &(*aasworld).edges[edge1num];
 			// vertexes of the edge
-			VectorCopy(aasworld.vertexes[edge1->v[!side1]], v1);
-			VectorCopy(aasworld.vertexes[edge1->v[side1]], v2);
+			VectorCopy((*aasworld).vertexes[edge1->v[!side1]], v1);
+			VectorCopy((*aasworld).vertexes[edge1->v[side1]], v2);
 			// get a vertical plane through the edge
 			// NOTE: normal is pointing into area 2 because the face edges are stored counter clockwise
 			VectorSubtract(v2, v1, edgevec);
@@ -1253,7 +1253,7 @@
 			dist = DotProduct(normal, v1);
 			// check the faces from the second area
 			for (j = 0; j < area2->numfaces; j++) {
-				groundface2 = &aasworld.faces[abs(aasworld.faceindex[area2->firstface + j])];
+				groundface2 = &(*aasworld).faces[abs((*aasworld).faceindex[area2->firstface + j])];
 				// must be a ground face
 				if (!(groundface2->faceflags & FACE_GROUND)) {
 					continue;
@@ -1260,11 +1260,11 @@
 				}
 				// check the edges of this ground face
 				for (l = 0; l < groundface2->numedges; l++) {
-					edge2num = abs(aasworld.edgeindex[groundface2->firstedge + l]);
-					edge2 = &aasworld.edges[edge2num];
+					edge2num = abs((*aasworld).edgeindex[groundface2->firstedge + l]);
+					edge2 = &(*aasworld).edges[edge2num];
 					// vertexes of the edge
-					VectorCopy(aasworld.vertexes[edge2->v[0]], v3);
-					VectorCopy(aasworld.vertexes[edge2->v[1]], v4);
+					VectorCopy((*aasworld).vertexes[edge2->v[0]], v3);
+					VectorCopy((*aasworld).vertexes[edge2->v[1]], v4);
 					// check the distance between the two points and the vertical plane through the edge of area1
 					diff = DotProduct(normal, v3) - dist;
 
@@ -1676,11 +1676,11 @@
 		// go down the maximum waterjump height
 		testpoint[2] -= aassettings.phys_maxwaterjump;
 		// if there IS water the phys_maxwaterjump height below the bestend point
-		if (aasworld.areasettings[AAS_PointAreaNum(testpoint)].areaflags & AREA_LIQUID) {
+		if ((*aasworld).areasettings[AAS_PointAreaNum(testpoint)].areaflags & AREA_LIQUID) {
 			// don't create ridiculous water jump reachabilities from areas very far below the water surface
 			if (water_bestdist < aassettings.phys_maxwaterjump + 24) {
 				// waterjumping from or towards a crouch only area is not possible
-				if ((aasworld.areasettings[area1num].presencetype & PRESENCE_NORMAL) && (aasworld.areasettings[area2num].presencetype & PRESENCE_NORMAL)) {
+				if (((*aasworld).areasettings[area1num].presencetype & PRESENCE_NORMAL) && ((*aasworld).areasettings[area2num].presencetype & PRESENCE_NORMAL)) {
 					// create a water jump reachability from area1 to area2
 					lreach = AAS_AllocReachability();
 
@@ -2252,8 +2252,8 @@
 		return qfalse;
 	}
 
-	area1 = &aasworld.areas[area1num];
-	area2 = &aasworld.areas[area2num];
+	area1 = &(*aasworld).areas[area1num];
+	area2 = &(*aasworld).areas[area2num];
 
 	phys_jumpvel = aassettings.phys_jumpvel;
 	// maximum distance a player can jump
@@ -2278,8 +2278,8 @@
 	bestdist = 999999;
 
 	for (i = 0; i < area1->numfaces; i++) {
-		face1num = aasworld.faceindex[area1->firstface + i];
-		face1 = &aasworld.faces[abs(face1num)];
+		face1num = (*aasworld).faceindex[area1->firstface + i];
+		face1 = &(*aasworld).faces[abs(face1num)];
 		// if not a ground face
 		if (!(face1->faceflags & FACE_GROUND)) {
 			continue;
@@ -2286,8 +2286,8 @@
 		}
 
 		for (j = 0; j < area2->numfaces; j++) {
-			face2num = aasworld.faceindex[area2->firstface + j];
-			face2 = &aasworld.faces[abs(face2num)];
+			face2num = (*aasworld).faceindex[area2->firstface + j];
+			face2 = &(*aasworld).faces[abs(face2num)];
 			// if not a ground face
 			if (!(face2->faceflags & FACE_GROUND)) {
 				continue;
@@ -2294,20 +2294,20 @@
 			}
 
 			for (k = 0; k < face1->numedges; k++) {
-				edge1num = abs(aasworld.edgeindex[face1->firstedge + k]);
-				edge1 = &aasworld.edges[edge1num];
+				edge1num = abs((*aasworld).edgeindex[face1->firstedge + k]);
+				edge1 = &(*aasworld).edges[edge1num];
 
 				for (l = 0; l < face2->numedges; l++) {
-					edge2num = abs(aasworld.edgeindex[face2->firstedge + l]);
-					edge2 = &aasworld.edges[edge2num];
+					edge2num = abs((*aasworld).edgeindex[face2->firstedge + l]);
+					edge2 = &(*aasworld).edges[edge2num];
 					// calculate the minimum distance between the two edges
-					v1 = aasworld.vertexes[edge1->v[0]];
-					v2 = aasworld.vertexes[edge1->v[1]];
-					v3 = aasworld.vertexes[edge2->v[0]];
-					v4 = aasworld.vertexes[edge2->v[1]];
+					v1 = (*aasworld).vertexes[edge1->v[0]];
+					v2 = (*aasworld).vertexes[edge1->v[1]];
+					v3 = (*aasworld).vertexes[edge2->v[0]];
+					v4 = (*aasworld).vertexes[edge2->v[1]];
 					// get the ground planes
-					plane1 = &aasworld.planes[face1->planenum];
-					plane2 = &aasworld.planes[face2->planenum];
+					plane1 = &(*aasworld).planes[face1->planenum];
+					plane2 = &(*aasworld).planes[face2->planenum];
 
 					bestdist = AAS_ClosestEdgePoints(v1, v2, v3, v4, plane1, plane2, beststart, bestend, beststart2, bestend2, bestdist);
 				}
@@ -2359,7 +2359,7 @@
 		}
 		// if something is hit
 		if (trace.fraction < 1.0f) {
-			plane = &aasworld.planes[trace.planenum];
+			plane = &(*aasworld).planes[trace.planenum];
 			// if the bot can stand on the surface
 			if (DotProduct(plane->normal, up) >= 0.7) {
 				// if no lava or slime below
@@ -2382,7 +2382,7 @@
 		}
 		// if something is hit
 		if (trace.fraction < 1.0f) {
-			plane = &aasworld.planes[trace.planenum];
+			plane = &(*aasworld).planes[trace.planenum];
 			// if the bot can stand on the surface
 			if (DotProduct(plane->normal, up) >= 0.7) {
 				// if no lava or slime below
@@ -2550,8 +2550,8 @@
 		return qfalse;
 	}
 
-	area1 = &aasworld.areas[area1num];
-	area2 = &aasworld.areas[area2num];
+	area1 = &(*aasworld).areas[area1num];
+	area2 = &(*aasworld).areas[area2num];
 
 	phys_jumpvelscout = aassettings.phys_jumpvelscout;
 	// maximum distance a player can jump
@@ -2576,8 +2576,8 @@
 	bestdist = 999999;
 
 	for (i = 0; i < area1->numfaces; i++) {
-		face1num = aasworld.faceindex[area1->firstface + i];
-		face1 = &aasworld.faces[abs(face1num)];
+		face1num = (*aasworld).faceindex[area1->firstface + i];
+		face1 = &(*aasworld).faces[abs(face1num)];
 		// if not a ground face
 		if (!(face1->faceflags & FACE_GROUND)) {
 			continue;
@@ -2584,8 +2584,8 @@
 		}
 
 		for (j = 0; j < area2->numfaces; j++) {
-			face2num = aasworld.faceindex[area2->firstface + j];
-			face2 = &aasworld.faces[abs(face2num)];
+			face2num = (*aasworld).faceindex[area2->firstface + j];
+			face2 = &(*aasworld).faces[abs(face2num)];
 			// if not a ground face
 			if (!(face2->faceflags & FACE_GROUND)) {
 				continue;
@@ -2592,20 +2592,20 @@
 			}
 
 			for (k = 0; k < face1->numedges; k++) {
-				edge1num = abs(aasworld.edgeindex[face1->firstedge + k]);
-				edge1 = &aasworld.edges[edge1num];
+				edge1num = abs((*aasworld).edgeindex[face1->firstedge + k]);
+				edge1 = &(*aasworld).edges[edge1num];
 
 				for (l = 0; l < face2->numedges; l++) {
-					edge2num = abs(aasworld.edgeindex[face2->firstedge + l]);
-					edge2 = &aasworld.edges[edge2num];
+					edge2num = abs((*aasworld).edgeindex[face2->firstedge + l]);
+					edge2 = &(*aasworld).edges[edge2num];
 					// calculate the minimum distance between the two edges
-					v1 = aasworld.vertexes[edge1->v[0]];
-					v2 = aasworld.vertexes[edge1->v[1]];
-					v3 = aasworld.vertexes[edge2->v[0]];
-					v4 = aasworld.vertexes[edge2->v[1]];
+					v1 = (*aasworld).vertexes[edge1->v[0]];
+					v2 = (*aasworld).vertexes[edge1->v[1]];
+					v3 = (*aasworld).vertexes[edge2->v[0]];
+					v4 = (*aasworld).vertexes[edge2->v[1]];
 					// get the ground planes
-					plane1 = &aasworld.planes[face1->planenum];
-					plane2 = &aasworld.planes[face2->planenum];
+					plane1 = &(*aasworld).planes[face1->planenum];
+					plane2 = &(*aasworld).planes[face2->planenum];
 
 					bestdist = AAS_ClosestEdgePoints(v1, v2, v3, v4, plane1, plane2, beststart, bestend, beststart2, bestend2, bestdist);
 				}
@@ -2661,7 +2661,7 @@
 		}
 
 		if (trace.fraction < 1) {
-			plane = &aasworld.planes[trace.planenum];
+			plane = &(*aasworld).planes[trace.planenum];
 			// if the bot can stand on the surface
 			if (DotProduct(plane->normal, up) >= 0.7) {
 				// if no lava or slime below
@@ -2684,7 +2684,7 @@
 		}
 
 		if (trace.fraction < 1) {
-			plane = &aasworld.planes[trace.planenum];
+			plane = &(*aasworld).planes[trace.planenum];
 			// if the bot can stand on the surface
 			if (DotProduct(plane->normal, up) >= 0.7) {
 				// if no lava or slime below
@@ -2850,12 +2850,12 @@
 	// maximum height a player can jump with the given initial z velocity
 	maxjumpheight = AAS_MaxJumpHeight(phys_jumpvel);
 
-	area1 = &aasworld.areas[area1num];
-	area2 = &aasworld.areas[area2num];
+	area1 = &(*aasworld).areas[area1num];
+	area2 = &(*aasworld).areas[area2num];
 
 	for (i = 0; i < area1->numfaces; i++) {
-		face1num = aasworld.faceindex[area1->firstface + i];
-		face1 = &aasworld.faces[abs(face1num)];
+		face1num = (*aasworld).faceindex[area1->firstface + i];
+		face1 = &(*aasworld).faces[abs(face1num)];
 		// if not a ladder face
 		if (!(face1->faceflags & FACE_LADDER)) {
 			continue;
@@ -2862,8 +2862,8 @@
 		}
 
 		for (j = 0; j < area2->numfaces; j++) {
-			face2num = aasworld.faceindex[area2->firstface + j];
-			face2 = &aasworld.faces[abs(face2num)];
+			face2num = (*aasworld).faceindex[area2->firstface + j];
+			face2 = &(*aasworld).faces[abs(face2num)];
 			// if not a ladder face
 			if (!(face2->faceflags & FACE_LADDER)) {
 				continue;
@@ -2870,10 +2870,10 @@
 			}
 			// check if the faces share an edge
 			for (k = 0; k < face1->numedges; k++) {
-				edge1num = aasworld.edgeindex[face1->firstedge + k];
+				edge1num = (*aasworld).edgeindex[face1->firstedge + k];
 
 				for (l = 0; l < face2->numedges; l++) {
-					edge2num = aasworld.edgeindex[face2->firstedge + l];
+					edge2num = (*aasworld).edgeindex[face2->firstedge + l];
 
 					if (abs(edge1num) == abs(edge2num)) {
 						// get the face with the largest area
@@ -2903,17 +2903,17 @@
 
 	if (ladderface1 && ladderface2) {
 		// get the middle of the shared edge
-		sharededge = &aasworld.edges[abs(sharededgenum)];
+		sharededge = &(*aasworld).edges[abs(sharededgenum)];
 		firstv = sharededgenum < 0;
 
-		VectorCopy(aasworld.vertexes[sharededge->v[firstv]], v1);
-		VectorCopy(aasworld.vertexes[sharededge->v[!firstv]], v2);
+		VectorCopy((*aasworld).vertexes[sharededge->v[firstv]], v1);
+		VectorCopy((*aasworld).vertexes[sharededge->v[!firstv]], v2);
 		VectorAdd(v1, v2, area1point);
 		VectorScale(area1point, 0.5, area1point);
 		VectorCopy(area1point, area2point);
 		// if the face plane in area 1 is pretty much vertical
-		plane1 = &aasworld.planes[ladderface1->planenum ^ (ladderface1num < 0)];
-		plane2 = &aasworld.planes[ladderface2->planenum ^ (ladderface2num < 0)];
+		plane1 = &(*aasworld).planes[ladderface1->planenum ^ (ladderface1num < 0)];
+		plane2 = &(*aasworld).planes[ladderface2->planenum ^ (ladderface2num < 0)];
 		// get the points really into the areas
 		VectorSubtract(v2, v1, sharededgevec);
 		CrossProduct(plane1->normal, sharededgevec, dir);
@@ -3033,11 +3033,11 @@
 			lowestpoint[2] = 99999;
 
 			for (i = 0; i < ladderface1->numedges; i++) {
-				edge1num = abs(aasworld.edgeindex[ladderface1->firstedge + i]);
-				edge1 = &aasworld.edges[edge1num];
+				edge1num = abs((*aasworld).edgeindex[ladderface1->firstedge + i]);
+				edge1 = &(*aasworld).edges[edge1num];
 
-				VectorCopy(aasworld.vertexes[edge1->v[0]], v1);
-				VectorCopy(aasworld.vertexes[edge1->v[1]], v2);
+				VectorCopy((*aasworld).vertexes[edge1->v[0]], v1);
+				VectorCopy((*aasworld).vertexes[edge1->v[1]], v2);
 				VectorAdd(v1, v2, mid);
 				VectorScale(mid, 0.5, mid);
 
@@ -3047,7 +3047,7 @@
 				}
 			}
 
-			plane1 = &aasworld.planes[ladderface1->planenum];
+			plane1 = &(*aasworld).planes[ladderface1->planenum];
 			// trace down in the middle of this edge
 			VectorMA(lowestpoint, 5, plane1->normal, start);
 			VectorCopy(start, end);
@@ -3063,14 +3063,14 @@
 #endif // REACH_DEBUG
 			trace.endpos[2] += 1;
 			area2num = AAS_PointAreaNum(trace.endpos);
-			area2 = &aasworld.areas[area2num];
+			area2 = &(*aasworld).areas[area2num];
 
 			for (i = 0; i < area2->numfaces; i++) {
-				face2num = aasworld.faceindex[area2->firstface + i];
-				face2 = &aasworld.faces[abs(face2num)];
+				face2num = (*aasworld).faceindex[area2->firstface + i];
+				face2 = &(*aasworld).faces[abs(face2num)];
 
 				if (face2->faceflags & FACE_LADDER) {
-					plane2 = &aasworld.planes[face2->planenum];
+					plane2 = &(*aasworld).planes[face2->planenum];
 
 					if (fabsf(DotProduct(plane2->normal, up)) < 0.1) {
 						break;
@@ -3138,7 +3138,7 @@
 			}
 			/*// if lava or slime below the ladder
 			// try jump reachability from far towards the ladder
-			if (aasworld.areasettings[area2num].contents & (AREACONTENTS_LAVA|AREACONTENTS_SLIME)) {
+			if ((*aasworld).areasettings[area2num].contents & (AREACONTENTS_LAVA|AREACONTENTS_SLIME)) {
 				for (i = 20; i <= 120; i += 20) {
 					// trace down in the middle of this edge
 					VectorMA(lowestpoint, i, plane1->normal, start);
@@ -3164,7 +3164,7 @@
 						continue;
 					}
 
-					if (aasworld.areasettings[area2num].contents & (AREACONTENTS_LAVA|AREACONTENTS_SLIME)) {
+					if ((*aasworld).areasettings[area2num].contents & (AREACONTENTS_LAVA|AREACONTENTS_SLIME)) {
 						continue;
 					}
 					// create a new reachability link
@@ -3717,27 +3717,27 @@
 	bestfacenum = 0;
 	bestfaceplane = NULL;
 
-	for (i = 1; i < aasworld.numareas; i++) {
-		area = &aasworld.areas[i];
+	for (i = 1; i < (*aasworld).numareas; i++) {
+		area = &(*aasworld).areas[i];
 		// get the shortest distance between one of the func_bobbing start edges and one of the face edges of area1
 		bestdist = 999999;
 
 		for (j = 0; j < area->numfaces; j++) {
-			facenum = aasworld.faceindex[area->firstface + j];
-			face = &aasworld.faces[abs(facenum)];
+			facenum = (*aasworld).faceindex[area->firstface + j];
+			face = &(*aasworld).faces[abs(facenum)];
 			// if not a ground face
 			if (!(face->faceflags & FACE_GROUND)) {
 				continue;
 			}
 			// get the ground planes
-			faceplane = &aasworld.planes[face->planenum];
+			faceplane = &(*aasworld).planes[face->planenum];
 
 			for (k = 0; k < face->numedges; k++) {
-				edgenum = abs(aasworld.edgeindex[face->firstedge + k]);
-				edge = &aasworld.edges[edgenum];
+				edgenum = abs((*aasworld).edgeindex[face->firstedge + k]);
+				edge = &(*aasworld).edges[edgenum];
 				// calculate the minimum distance between the two edges
-				v1 = aasworld.vertexes[edge->v[0]];
-				v2 = aasworld.vertexes[edge->v[1]];
+				v1 = (*aasworld).vertexes[edge->v[0]];
+				v2 = (*aasworld).vertexes[edge->v[1]];
 
 				for (l = 0; l < numpoints; l++) {
 					v3 = facepoints[l];
@@ -4312,7 +4312,7 @@
 			continue;
 		}
 		// check for areas we can reach with air control
-		for (area2num = 1; area2num < aasworld.numareas; area2num++) {
+		for (area2num = 1; area2num < (*aasworld).numareas; area2num++) {
 			visualize = qfalse;
 			/*
 			if (area2num == 3568) {
@@ -4341,11 +4341,11 @@
 				continue;
 			}
 
-			area2 = &aasworld.areas[area2num];
+			area2 = &(*aasworld).areas[area2num];
 
 			for (i = 0; i < area2->numfaces; i++) {
-				face2num = aasworld.faceindex[area2->firstface + i];
-				face2 = &aasworld.faces[abs(face2num)];
+				face2num = (*aasworld).faceindex[area2->firstface + i];
+				face2 = &(*aasworld).faces[abs(face2num)];
 				// if it is not a ground face
 				if (!(face2->faceflags & FACE_GROUND)) {
 					continue;
@@ -4467,7 +4467,7 @@
 				//areanum = AAS_PointAreaNum(origin);
 				areanum = AAS_BestReachableArea(origin, mins, maxs, origin);
 				// the bot may rocket jump towards this area
-				aasworld.areasettings[areanum].areaflags |= AREA_WEAPONJUMP;
+				(*aasworld).areasettings[areanum].areaflags |= AREA_WEAPONJUMP;
 
 				//if (!AAS_AreaGrounded(areanum))
 
@@ -4478,9 +4478,9 @@
 		}
 	}
 
-	for (i = 1; i < aasworld.numareas; i++) {
-		if (aasworld.areasettings[i].contents & AREACONTENTS_JUMPPAD) {
-			aasworld.areasettings[i].areaflags |= AREA_WEAPONJUMP;
+	for (i = 1; i < (*aasworld).numareas; i++) {
+		if ((*aasworld).areasettings[i].contents & AREACONTENTS_JUMPPAD) {
+			(*aasworld).areasettings[i].areaflags |= AREA_WEAPONJUMP;
 			weaponjumpareas++;
 		}
 	}
@@ -4525,18 +4525,18 @@
 		return qfalse;
 	}
 	// NOTE: only weapon jump towards areas with an interesting item in it??
-	if (!(aasworld.areasettings[area2num].areaflags & AREA_WEAPONJUMP)) {
+	if (!((*aasworld).areasettings[area2num].areaflags & AREA_WEAPONJUMP)) {
 		return qfalse;
 	}
 
-	area1 = &aasworld.areas[area1num];
-	area2 = &aasworld.areas[area2num];
+	area1 = &(*aasworld).areas[area1num];
+	area2 = &(*aasworld).areas[area2num];
 	// don't weapon jump towards way lower areas
 	if (area2->maxs[2] < area1->mins[2]) {
 		return qfalse;
 	}
 
-	VectorCopy(aasworld.areas[area1num].center, start);
+	VectorCopy((*aasworld).areas[area1num].center, start);
 	// if not a swim area
 	if (!AAS_PointAreaNum(start)) {
 		Log_Write("area %d center %f %f %f in solid?\r\n", area1num, start[0], start[1], start[2]);
@@ -4554,8 +4554,8 @@
 	VectorCopy(trace.endpos, areastart);
 	// areastart is now the start point
 	for (i = 0; i < area2->numfaces; i++) {
-		face2num = aasworld.faceindex[area2->firstface + i];
-		face2 = &aasworld.faces[abs(face2num)];
+		face2num = (*aasworld).faceindex[area2->firstface + i];
+		face2 = &(*aasworld).faces[abs(face2num)];
 		// if it is not a solid face
 		if (!(face2->faceflags & FACE_GROUND)) {
 			continue;
@@ -4649,11 +4649,11 @@
 		return;
 	}
 
-	area = &aasworld.areas[areanum];
+	area = &(*aasworld).areas[areanum];
 
 	for (i = 0; i < area->numfaces; i++) {
-		face1num = aasworld.faceindex[area->firstface + i];
-		face1 = &aasworld.faces[abs(face1num)];
+		face1num = (*aasworld).faceindex[area->firstface + i];
+		face1 = &(*aasworld).faces[abs(face1num)];
 		// face 1 must be a ground face
 		if (!(face1->faceflags & FACE_GROUND)) {
 			continue;
@@ -4660,11 +4660,11 @@
 		}
 		// go through all the edges of this ground face
 		for (k = 0; k < face1->numedges; k++) {
-			edge1num = aasworld.edgeindex[face1->firstedge + k];
+			edge1num = (*aasworld).edgeindex[face1->firstedge + k];
 			// find another not ground face using this same edge
 			for (j = 0; j < area->numfaces; j++) {
-				face2num = aasworld.faceindex[area->firstface + j];
-				face2 = &aasworld.faces[abs(face2num)];
+				face2num = (*aasworld).faceindex[area->firstface + j];
+				face2 = &(*aasworld).faces[abs(face2num)];
 				// face 2 may not be a ground face
 				if (face2->faceflags & FACE_GROUND) {
 					continue;
@@ -4671,7 +4671,7 @@
 				}
 				// compare all the edges
 				for (l = 0; l < face2->numedges; l++) {
-					edge2num = aasworld.edgeindex[face2->firstedge + l];
+					edge2num = (*aasworld).edgeindex[face2->firstedge + l];
 
 					if (abs(edge1num) == abs(edge2num)) {
 						// get the area at the other side of the face
@@ -4681,23 +4681,23 @@
 							otherareanum = face2->frontarea;
 						}
 
-						area2 = &aasworld.areas[otherareanum];
+						area2 = &(*aasworld).areas[otherareanum];
 						// if the other area is grounded!
-						if (aasworld.areasettings[otherareanum].areaflags & AREA_GROUNDED) {
+						if ((*aasworld).areasettings[otherareanum].areaflags & AREA_GROUNDED) {
 							// check for a possible gap
 							gap = qfalse;
 
 							for (n = 0; n < area2->numfaces; n++) {
-								face3num = aasworld.faceindex[area2->firstface + n];
+								face3num = (*aasworld).faceindex[area2->firstface + n];
 								// may not be the shared face of the two areas
 								if (abs(face3num) == abs(face2num)) {
 									continue;
 								}
 
-								face3 = &aasworld.faces[abs(face3num)];
+								face3 = &(*aasworld).faces[abs(face3num)];
 								// find an edge shared by all three faces
 								for (m = 0; m < face3->numedges; m++) {
-									edge3num = aasworld.edgeindex[face3->firstedge + m];
+									edge3num = (*aasworld).edgeindex[face3->firstedge + m];
 									// but the edge should be shared by all three faces
 									if (abs(edge3num) == abs(edge1num)) {
 										if (!(face3->faceflags & FACE_SOLID)) {
@@ -4725,13 +4725,13 @@
 							}
 						}
 						// check for a walk off ledge reachability
-						edge = &aasworld.edges[abs(edge1num)];
+						edge = &(*aasworld).edges[abs(edge1num)];
 						side = edge1num < 0;
 
-						v1 = aasworld.vertexes[edge->v[side]];
-						v2 = aasworld.vertexes[edge->v[!side]];
+						v1 = (*aasworld).vertexes[edge->v[side]];
+						v2 = (*aasworld).vertexes[edge->v[!side]];
 
-						plane = &aasworld.planes[face1->planenum];
+						plane = &(*aasworld).planes[face1->planenum];
 						// get the points really into the areas
 						VectorSubtract(v2, v1, sharededgevec);
 						CrossProduct(plane->normal, sharededgevec, dir);
@@ -4766,7 +4766,7 @@
 							break;
 						}
 
-						if (aasworld.areasettings[reachareanum].contents & (AREACONTENTS_LAVA|AREACONTENTS_SLIME)) {
+						if ((*aasworld).areasettings[reachareanum].contents & (AREACONTENTS_LAVA|AREACONTENTS_SLIME)) {
 							//Log_Write("area %d, reach area %d: lava or slime\r\n", areanum, reachareanum);
 							break;
 						}
@@ -4834,20 +4834,20 @@
 	aas_lreachability_t *lreach;
 	aas_reachability_t *reach;
 
-	if (aasworld.reachability) {
-		FreeMemory(aasworld.reachability);
+	if ((*aasworld).reachability) {
+		FreeMemory((*aasworld).reachability);
 	}
 
-	aasworld.reachability = (aas_reachability_t *)GetClearedMemory((numlreachabilities + 10) * sizeof(aas_reachability_t));
-	aasworld.reachabilitysize = 1;
+	(*aasworld).reachability = (aas_reachability_t *)GetClearedMemory((numlreachabilities + 10) * sizeof(aas_reachability_t));
+	(*aasworld).reachabilitysize = 1;
 
-	for (i = 0; i < aasworld.numareas; i++) {
-		areasettings = &aasworld.areasettings[i];
-		areasettings->firstreachablearea = aasworld.reachabilitysize;
+	for (i = 0; i < (*aasworld).numareas; i++) {
+		areasettings = &(*aasworld).areasettings[i];
+		areasettings->firstreachablearea = (*aasworld).reachabilitysize;
 		areasettings->numreachableareas = 0;
 
 		for (lreach = areareachability[i]; lreach; lreach = lreach->next) {
-			reach = &aasworld.reachability[areasettings->firstreachablearea + areasettings->numreachableareas];
+			reach = &(*aasworld).reachability[areasettings->firstreachablearea + areasettings->numreachableareas];
 
 			reach->areanum = lreach->areanum;
 			reach->facenum = lreach->facenum;
@@ -4862,7 +4862,7 @@
 			areasettings->numreachableareas++;
 		}
 
-		aasworld.reachabilitysize += areasettings->numreachableareas;
+		(*aasworld).reachabilitysize += areasettings->numreachableareas;
 	}
 }
 
@@ -4896,15 +4896,15 @@
 	static float framereachability, reachability_delay;
 	static int lastpercentage;
 
-	if (!aasworld.loaded) {
+	if (!(*aasworld).loaded) {
 		return qfalse;
 	}
 	// if reachability is calculated for all areas
-	if (aasworld.numreachabilityareas >= aasworld.numareas + 2) {
+	if ((*aasworld).numreachabilityareas >= (*aasworld).numareas + 2) {
 		return qfalse;
 	}
 	// if starting with area 1 (area 0 is a dummy)
-	if (aasworld.numreachabilityareas == 1) {
+	if ((*aasworld).numreachabilityareas == 1) {
 		botimport.Print(PRT_MESSAGE, "calculating reachability...\n");
 		lastpercentage = 0;
 		framereachability = 2000;
@@ -4911,23 +4911,23 @@
 		reachability_delay = 1000;
 	}
 	// number of areas to calculate reachability for this cycle
-	todo = aasworld.numreachabilityareas + (int)framereachability;
+	todo = (*aasworld).numreachabilityareas + (int)framereachability;
 	start_time = botimport.MilliSeconds();
 	// loop over the areas
-	for (i = aasworld.numreachabilityareas; i < aasworld.numareas && i < todo; i++) {
-		aasworld.numreachabilityareas++;
+	for (i = (*aasworld).numreachabilityareas; i < (*aasworld).numareas && i < todo; i++) {
+		(*aasworld).numreachabilityareas++;
 		// only create jumppad reachabilities from jumppad areas
-		if (aasworld.areasettings[i].contents & AREACONTENTS_JUMPPAD) {
+		if ((*aasworld).areasettings[i].contents & AREACONTENTS_JUMPPAD) {
 			continue;
 		}
 		// loop over the areas
-		for (j = 1; j < aasworld.numareas; j++) {
+		for (j = 1; j < (*aasworld).numareas; j++) {
 			if (i == j) {
 				continue;
 			}
 			// never create reachabilities from teleporter or jumppad areas to regular areas
-			if (aasworld.areasettings[i].contents & (AREACONTENTS_TELEPORTER|AREACONTENTS_JUMPPAD)) {
-				if (!(aasworld.areasettings[j].contents & (AREACONTENTS_TELEPORTER|AREACONTENTS_JUMPPAD))) {
+			if ((*aasworld).areasettings[i].contents & (AREACONTENTS_TELEPORTER|AREACONTENTS_JUMPPAD)) {
+				if (!((*aasworld).areasettings[j].contents & (AREACONTENTS_TELEPORTER|AREACONTENTS_JUMPPAD))) {
 					continue;
 				}
 			}
@@ -4963,11 +4963,11 @@
 			}
 		}
 		// never create these reachabilities from teleporter or jumppad areas
-		if (aasworld.areasettings[i].contents & (AREACONTENTS_TELEPORTER|AREACONTENTS_JUMPPAD)) {
+		if ((*aasworld).areasettings[i].contents & (AREACONTENTS_TELEPORTER|AREACONTENTS_JUMPPAD)) {
 			continue;
 		}
 		// loop over the areas
-		for (j = 1; j < aasworld.numareas; j++) {
+		for (j = 1; j < (*aasworld).numareas; j++) {
 			if (i == j) {
 				continue;
 			}
@@ -4983,21 +4983,21 @@
 			break;
 		}
 
-		if (aasworld.numreachabilityareas * 1000 / aasworld.numareas > lastpercentage) {
+		if ((*aasworld).numreachabilityareas * 1000 / (*aasworld).numareas > lastpercentage) {
 			break;
 		}
 	}
 
-	if (aasworld.numreachabilityareas == aasworld.numareas) {
+	if ((*aasworld).numreachabilityareas == (*aasworld).numareas) {
 		botimport.Print(PRT_MESSAGE, "\r%6.1f%%", (float)100.0);
 		botimport.Print(PRT_MESSAGE, "\nplease wait while storing reachability...\n");
-		aasworld.numreachabilityareas++;
+		(*aasworld).numreachabilityareas++;
 	// if this is the last step in the reachability calculations
-	} else if (aasworld.numreachabilityareas == aasworld.numareas + 1) {
+	} else if ((*aasworld).numreachabilityareas == (*aasworld).numareas + 1) {
 		// create additional walk off ledge reachabilities for every area
-		for (i = 1; i < aasworld.numareas; i++) {
+		for (i = 1; i < (*aasworld).numareas; i++) {
 			// only create jumppad reachabilities from jumppad areas
-			if (aasworld.areasettings[i].contents & AREACONTENTS_JUMPPAD) {
+			if ((*aasworld).areasettings[i].contents & AREACONTENTS_JUMPPAD) {
 				continue;
 			}
 
@@ -5036,11 +5036,11 @@
 
 		FreeMemory(areareachability);
 
-		aasworld.numreachabilityareas++;
+		(*aasworld).numreachabilityareas++;
 
 		botimport.Print(PRT_MESSAGE, "calculating clusters...\n");
 	} else {
-		lastpercentage = aasworld.numreachabilityareas * 1000 / aasworld.numareas;
+		lastpercentage = (*aasworld).numreachabilityareas * 1000 / (*aasworld).numareas;
 		botimport.Print(PRT_MESSAGE, "\r%6.1f%%", (float)lastpercentage / 10);
 	}
 	// not yet finished
@@ -5054,18 +5054,18 @@
 */
 void AAS_InitReachability(void) {
 
-	if (!aasworld.loaded) {
+	if (!(*aasworld).loaded) {
 		return;
 	}
 
-	if (aasworld.reachabilitysize) {
+	if ((*aasworld).reachabilitysize) {
 #ifndef BSPC
 		if (!((int)LibVarGetValue("forcereachability"))) {
-			aasworld.numreachabilityareas = aasworld.numareas + 2;
+			(*aasworld).numreachabilityareas = (*aasworld).numareas + 2;
 			return;
 		}
 #else
-		aasworld.numreachabilityareas = aasworld.numareas + 2;
+		(*aasworld).numreachabilityareas = (*aasworld).numareas + 2;
 		return;
 #endif // BSPC
 	}
@@ -5072,14 +5072,14 @@
 #ifndef BSPC
 	calcscoutreach = LibVarGetValue("scoutreach");
 #endif
-	aasworld.savefile = qtrue;
+	(*aasworld).savefile = qtrue;
 	// start with area 1 because area zero is a dummy
-	aasworld.numreachabilityareas = 1;
-	//aasworld.numreachabilityareas = aasworld.numareas + 1; // only calculate entity reachabilities
+	(*aasworld).numreachabilityareas = 1;
+	//(*aasworld).numreachabilityareas = (*aasworld).numareas + 1; // only calculate entity reachabilities
 	// setup the heap with reachability links
 	AAS_SetupReachabilityHeap();
 	// allocate area reachability link array
-	areareachability = (aas_lreachability_t **)GetClearedMemory(aasworld.numareas * sizeof(aas_lreachability_t *));
+	areareachability = (aas_lreachability_t **)GetClearedMemory((*aasworld).numareas * sizeof(aas_lreachability_t *));
 
 	AAS_SetWeaponJumpAreaFlags();
 }
Index: code/botlib/be_aas_route.c
===================================================================
--- code/botlib/be_aas_route.c	(revision 1306)
+++ code/botlib/be_aas_route.c	(working copy)
@@ -57,13 +57,13 @@
   this goal area is in this same cluster and could be a cluster portal
   for every cluster there's a list with routing cache for every area
   in that cluster (including the portals of that cluster)
-  area cache stores aasworld.clusters[?].numreachabilityareas travel times
+  area cache stores (*aasworld).clusters[?].numreachabilityareas travel times
 
   portal routing cache:
   stores the distances of all portals to a specific goal area
   this goal area could be in any cluster and could also be a cluster portal
-  for every area (aasworld.numareas) the portal cache stores
-  aasworld.numportals travel times
+  for every area ((*aasworld).numareas) the portal cache stores
+  (*aasworld).numportals travel times
 */
 #ifdef ROUTING_DEBUG
 int numareacacheupdates;
@@ -94,20 +94,20 @@
 static ID_INLINE int AAS_ClusterAreaNum(int cluster, int areanum) {
 	int side, areacluster;
 
-	areacluster = aasworld.areasettings[areanum].cluster;
+	areacluster = (*aasworld).areasettings[areanum].cluster;
 
 	if (areacluster > 0) {
-		return aasworld.areasettings[areanum].clusterareanum;
+		return (*aasworld).areasettings[areanum].clusterareanum;
 	} else {
 /*
 #ifdef ROUTING_DEBUG
-		if (aasworld.portals[-areacluster].frontcluster != cluster && aasworld.portals[-areacluster].backcluster != cluster) {
+		if ((*aasworld).portals[-areacluster].frontcluster != cluster && (*aasworld).portals[-areacluster].backcluster != cluster) {
 			botimport.Print(PRT_ERROR, "portal %d: does not belong to cluster %d\n", -areacluster, cluster);
 		}
 #endif // ROUTING_DEBUG
 */
-		side = aasworld.portals[-areacluster].frontcluster != cluster;
-		return aasworld.portals[-areacluster].clusterareanum[side];
+		side = (*aasworld).portals[-areacluster].frontcluster != cluster;
+		return (*aasworld).portals[-areacluster].clusterareanum[side];
 	}
 }
 
@@ -120,37 +120,37 @@
 	int i;
 
 	for (i = 0; i < MAX_TRAVELTYPES; i++) {
-		aasworld.travelflagfortype[i] = TFL_INVALID;
+		(*aasworld).travelflagfortype[i] = TFL_INVALID;
 	}
 
-	aasworld.travelflagfortype[TRAVEL_INVALID] = TFL_INVALID;
-	aasworld.travelflagfortype[TRAVEL_WALK] = TFL_WALK;
-	aasworld.travelflagfortype[TRAVEL_CROUCH] = TFL_CROUCH;
-	aasworld.travelflagfortype[TRAVEL_PRONE] = TFL_PRONE;
-	aasworld.travelflagfortype[TRAVEL_JUMP] = TFL_JUMP;
-	aasworld.travelflagfortype[TRAVEL_BARRIERJUMP] = TFL_BARRIERJUMP;
-	aasworld.travelflagfortype[TRAVEL_WALKOFFLEDGE] = TFL_WALKOFFLEDGE;
-	aasworld.travelflagfortype[TRAVEL_SWIM] = TFL_SWIM;
-	aasworld.travelflagfortype[TRAVEL_WATERJUMP] = TFL_WATERJUMP;
-	aasworld.travelflagfortype[TRAVEL_SCOUTJUMP] = TFL_SCOUTJUMP;
-	aasworld.travelflagfortype[TRAVEL_SCOUTBARRIER] = TFL_SCOUTBARRIER;
-	aasworld.travelflagfortype[TRAVEL_ROCKETJUMP] = TFL_ROCKETJUMP;
-	aasworld.travelflagfortype[TRAVEL_BFGJUMP] = TFL_BFGJUMP;
-	aasworld.travelflagfortype[TRAVEL_TELEPORT] = TFL_TELEPORT;
-	aasworld.travelflagfortype[TRAVEL_JUMPPAD] = TFL_JUMPPAD;
-	aasworld.travelflagfortype[TRAVEL_FUNCBOB] = TFL_FUNCBOB;
-	aasworld.travelflagfortype[TRAVEL_ELEVATOR] = TFL_ELEVATOR;
-	aasworld.travelflagfortype[TRAVEL_LADDER] = TFL_LADDER;
-	aasworld.travelflagfortype[TRAVEL_BRIDGE] = TFL_BRIDGE;
-	aasworld.travelflagfortype[TRAVEL_NOTTEAM1] = TFL_NOTTEAM1;
-	aasworld.travelflagfortype[TRAVEL_NOTTEAM2] = TFL_NOTTEAM2;
-	aasworld.travelflagfortype[TRAVEL_DONOTENTER] = TFL_DONOTENTER;
-	aasworld.travelflagfortype[TRAVEL_DONOTENTER_LARGE] = TFL_DONOTENTER_LARGE;
-	aasworld.travelflagfortype[TRAVEL_WATER] = TFL_WATER;
-	aasworld.travelflagfortype[TRAVEL_LAVA] = TFL_LAVA;
-	aasworld.travelflagfortype[TRAVEL_SLIME] = TFL_SLIME;
-	aasworld.travelflagfortype[TRAVEL_AIR] = TFL_AIR;
-	aasworld.travelflagfortype[TRAVEL_FLIGHT] = TFL_FLIGHT;
+	(*aasworld).travelflagfortype[TRAVEL_INVALID] = TFL_INVALID;
+	(*aasworld).travelflagfortype[TRAVEL_WALK] = TFL_WALK;
+	(*aasworld).travelflagfortype[TRAVEL_CROUCH] = TFL_CROUCH;
+	(*aasworld).travelflagfortype[TRAVEL_PRONE] = TFL_PRONE;
+	(*aasworld).travelflagfortype[TRAVEL_JUMP] = TFL_JUMP;
+	(*aasworld).travelflagfortype[TRAVEL_BARRIERJUMP] = TFL_BARRIERJUMP;
+	(*aasworld).travelflagfortype[TRAVEL_WALKOFFLEDGE] = TFL_WALKOFFLEDGE;
+	(*aasworld).travelflagfortype[TRAVEL_SWIM] = TFL_SWIM;
+	(*aasworld).travelflagfortype[TRAVEL_WATERJUMP] = TFL_WATERJUMP;
+	(*aasworld).travelflagfortype[TRAVEL_SCOUTJUMP] = TFL_SCOUTJUMP;
+	(*aasworld).travelflagfortype[TRAVEL_SCOUTBARRIER] = TFL_SCOUTBARRIER;
+	(*aasworld).travelflagfortype[TRAVEL_ROCKETJUMP] = TFL_ROCKETJUMP;
+	(*aasworld).travelflagfortype[TRAVEL_BFGJUMP] = TFL_BFGJUMP;
+	(*aasworld).travelflagfortype[TRAVEL_TELEPORT] = TFL_TELEPORT;
+	(*aasworld).travelflagfortype[TRAVEL_JUMPPAD] = TFL_JUMPPAD;
+	(*aasworld).travelflagfortype[TRAVEL_FUNCBOB] = TFL_FUNCBOB;
+	(*aasworld).travelflagfortype[TRAVEL_ELEVATOR] = TFL_ELEVATOR;
+	(*aasworld).travelflagfortype[TRAVEL_LADDER] = TFL_LADDER;
+	(*aasworld).travelflagfortype[TRAVEL_BRIDGE] = TFL_BRIDGE;
+	(*aasworld).travelflagfortype[TRAVEL_NOTTEAM1] = TFL_NOTTEAM1;
+	(*aasworld).travelflagfortype[TRAVEL_NOTTEAM2] = TFL_NOTTEAM2;
+	(*aasworld).travelflagfortype[TRAVEL_DONOTENTER] = TFL_DONOTENTER;
+	(*aasworld).travelflagfortype[TRAVEL_DONOTENTER_LARGE] = TFL_DONOTENTER_LARGE;
+	(*aasworld).travelflagfortype[TRAVEL_WATER] = TFL_WATER;
+	(*aasworld).travelflagfortype[TRAVEL_LAVA] = TFL_LAVA;
+	(*aasworld).travelflagfortype[TRAVEL_SLIME] = TFL_SLIME;
+	(*aasworld).travelflagfortype[TRAVEL_AIR] = TFL_AIR;
+	(*aasworld).travelflagfortype[TRAVEL_FLIGHT] = TFL_FLIGHT;
 }
 
 /*
@@ -177,7 +177,7 @@
 		return TFL_INVALID;
 	}
 
-	tfl |= aasworld.travelflagfortype[traveltype];
+	tfl |= (*aasworld).travelflagfortype[traveltype];
 	return tfl;
 }
 
@@ -200,13 +200,13 @@
 	if (cache->time_next) {
 		cache->time_next->time_prev = cache->time_prev;
 	} else {
-		aasworld.newestcache = cache->time_prev;
+		(*aasworld).newestcache = cache->time_prev;
 	}
 
 	if (cache->time_prev) {
 		cache->time_prev->time_next = cache->time_next;
 	} else {
-		aasworld.oldestcache = cache->time_next;
+		(*aasworld).oldestcache = cache->time_next;
 	}
 
 	cache->time_next = NULL;
@@ -220,16 +220,16 @@
 */
 void AAS_LinkCache(aas_routingcache_t *cache) {
 
-	if (aasworld.newestcache) {
-		aasworld.newestcache->time_next = cache;
-		cache->time_prev = aasworld.newestcache;
+	if ((*aasworld).newestcache) {
+		(*aasworld).newestcache->time_next = cache;
+		cache->time_prev = (*aasworld).newestcache;
 	} else {
-		aasworld.oldestcache = cache;
+		(*aasworld).oldestcache = cache;
 		cache->time_prev = NULL;
 	}
 
 	cache->time_next = NULL;
-	aasworld.newestcache = cache;
+	(*aasworld).newestcache = cache;
 }
 
 /*
@@ -256,19 +256,19 @@
 	aas_routingcache_t *cache, *nextcache;
 	aas_cluster_t *cluster;
 
-	if (!aasworld.clusterareacache) {
+	if (!(*aasworld).clusterareacache) {
 		return;
 	}
 
-	cluster = &aasworld.clusters[clusternum];
+	cluster = &(*aasworld).clusters[clusternum];
 
 	for (i = 0; i < cluster->numareas; i++) {
-		for (cache = aasworld.clusterareacache[clusternum][i]; cache; cache = nextcache) {
+		for (cache = (*aasworld).clusterareacache[clusternum][i]; cache; cache = nextcache) {
 			nextcache = cache->next;
 			AAS_FreeRoutingCache(cache);
 		}
 
-		aasworld.clusterareacache[clusternum][i] = NULL;
+		(*aasworld).clusterareacache[clusternum][i] = NULL;
 	}
 }
 
@@ -281,7 +281,7 @@
 	int i, clusternum;
 	aas_routingcache_t *cache, *nextcache;
 
-	clusternum = aasworld.areasettings[areanum].cluster;
+	clusternum = (*aasworld).areasettings[areanum].cluster;
 
 	if (clusternum > 0) {
 		// remove all the cache in the cluster the area is in
@@ -288,18 +288,18 @@
 		AAS_RemoveRoutingCacheInCluster(clusternum);
 	} else {
 		// if this is a portal remove all cache in both the front and back cluster
-		AAS_RemoveRoutingCacheInCluster(aasworld.portals[-clusternum].frontcluster);
-		AAS_RemoveRoutingCacheInCluster(aasworld.portals[-clusternum].backcluster);
+		AAS_RemoveRoutingCacheInCluster((*aasworld).portals[-clusternum].frontcluster);
+		AAS_RemoveRoutingCacheInCluster((*aasworld).portals[-clusternum].backcluster);
 	}
 	// remove all portal cache
-	for (i = 0; i < aasworld.numareas; i++) {
+	for (i = 0; i < (*aasworld).numareas; i++) {
 		// refresh portal cache
-		for (cache = aasworld.portalcache[i]; cache; cache = nextcache) {
+		for (cache = (*aasworld).portalcache[i]; cache; cache = nextcache) {
 			nextcache = cache->next;
 			AAS_FreeRoutingCache(cache);
 		}
 
-		aasworld.portalcache[i] = NULL;
+		(*aasworld).portalcache[i] = NULL;
 	}
 }
 
@@ -311,7 +311,7 @@
 int AAS_EnableRoutingArea(int areanum, int enable) {
 	int flags;
 
-	if (areanum <= 0 || areanum >= aasworld.numareas) {
+	if (areanum <= 0 || areanum >= (*aasworld).numareas) {
 		if (botDeveloper) {
 			botimport.Print(PRT_ERROR, "AAS_EnableRoutingArea: areanum %d out of range\n", areanum);
 		}
@@ -319,7 +319,7 @@
 		return 0;
 	}
 
-	flags = aasworld.areasettings[areanum].areaflags & AREA_DISABLED;
+	flags = (*aasworld).areasettings[areanum].areaflags & AREA_DISABLED;
 
 	if (enable < 0) {
 		return !flags;
@@ -326,12 +326,12 @@
 	}
 
 	if (enable) {
-		aasworld.areasettings[areanum].areaflags &= ~AREA_DISABLED;
+		(*aasworld).areasettings[areanum].areaflags &= ~AREA_DISABLED;
 	} else {
-		aasworld.areasettings[areanum].areaflags |= AREA_DISABLED;
+		(*aasworld).areasettings[areanum].areaflags |= AREA_DISABLED;
 	}
 	// if the status of the area changed
-	if ((flags & AREA_DISABLED) != (aasworld.areasettings[areanum].areaflags & AREA_DISABLED)) {
+	if ((flags & AREA_DISABLED) != ((*aasworld).areasettings[areanum].areaflags & AREA_DISABLED)) {
 		// remove all routing cache involving this area
 		AAS_RemoveRoutingCacheUsingArea(areanum);
 	}
@@ -356,10 +356,10 @@
 int AAS_GetAreaContentsTravelFlags(int areanum) {
 	int contents, tfl;
 
-	contents = aasworld.areasettings[areanum].contents;
+	contents = (*aasworld).areasettings[areanum].contents;
 	tfl = 0;
 
-	if (aasworld.areasettings[areanum].areaflags & AREA_BRIDGE) {
+	if ((*aasworld).areasettings[areanum].areaflags & AREA_BRIDGE) {
 		tfl |= TFL_BRIDGE;
 	}
 
@@ -394,7 +394,7 @@
 =======================================================================================================================================
 */
 static ID_INLINE int AAS_AreaContentsTravelFlags_inline(int areanum) {
-	return aasworld.areacontentstravelflags[areanum];
+	return (*aasworld).areacontentstravelflags[areanum];
 }
 
 /*
@@ -403,7 +403,7 @@
 =======================================================================================================================================
 */
 int AAS_AreaContentsTravelFlags(int areanum) {
-	return aasworld.areacontentstravelflags[areanum];
+	return (*aasworld).areacontentstravelflags[areanum];
 }
 
 /*
@@ -414,14 +414,14 @@
 void AAS_InitAreaContentsTravelFlags(void) {
 	int i;
 
-	if (aasworld.areacontentstravelflags) {
-		FreeMemory(aasworld.areacontentstravelflags);
+	if ((*aasworld).areacontentstravelflags) {
+		FreeMemory((*aasworld).areacontentstravelflags);
 	}
 
-	aasworld.areacontentstravelflags = (int *)GetClearedMemory(aasworld.numareas * sizeof(int));
+	(*aasworld).areacontentstravelflags = (int *)GetClearedMemory((*aasworld).numareas * sizeof(int));
 
-	for (i = 0; i < aasworld.numareas; i++) {
-		aasworld.areacontentstravelflags[i] = AAS_GetAreaContentsTravelFlags(i);
+	for (i = 0; i < (*aasworld).numareas; i++) {
+		(*aasworld).areacontentstravelflags[i] = AAS_GetAreaContentsTravelFlags(i);
 	}
 }
 
@@ -442,18 +442,18 @@
 	starttime = botimport.MilliSeconds();
 #endif
 	// free reversed links that have already been created
-	if (aasworld.reversedreachability) {
-		FreeMemory(aasworld.reversedreachability);
+	if ((*aasworld).reversedreachability) {
+		FreeMemory((*aasworld).reversedreachability);
 	}
 	// allocate memory for the reversed reachability links
-	ptr = (char *)GetClearedMemory(aasworld.numareas * sizeof(aas_reversedreachability_t) + aasworld.reachabilitysize * sizeof(aas_reversedlink_t));
-	aasworld.reversedreachability = (aas_reversedreachability_t *)ptr;
+	ptr = (char *)GetClearedMemory((*aasworld).numareas * sizeof(aas_reversedreachability_t) + (*aasworld).reachabilitysize * sizeof(aas_reversedlink_t));
+	(*aasworld).reversedreachability = (aas_reversedreachability_t *)ptr;
 	// pointer to the memory for the reversed links
-	ptr += aasworld.numareas * sizeof(aas_reversedreachability_t);
+	ptr += (*aasworld).numareas * sizeof(aas_reversedreachability_t);
 	// check all reachabilities of all areas
-	for (i = 1; i < aasworld.numareas; i++) {
+	for (i = 1; i < (*aasworld).numareas; i++) {
 		// settings of the area
-		settings = &aasworld.areasettings[i];
+		settings = &(*aasworld).areasettings[i];
 
 		if (settings->numreachableareas > 128) {
 			botimport.Print(PRT_WARNING, "area %d has more than 128 reachabilities\n", i);
@@ -461,14 +461,14 @@
 		// create reversed links for the reachabilities
 		for (n = 0; n < settings->numreachableareas && n < 128; n++) {
 			// reachability link
-			reach = &aasworld.reachability[settings->firstreachablearea + n];
+			reach = &(*aasworld).reachability[settings->firstreachablearea + n];
 			revlink = (aas_reversedlink_t *)ptr;
 			ptr += sizeof(aas_reversedlink_t);
 			revlink->areanum = i;
 			revlink->linknum = settings->firstreachablearea + n;
-			revlink->next = aasworld.reversedreachability[reach->areanum].first;
-			aasworld.reversedreachability[reach->areanum].first = revlink;
-			aasworld.reversedreachability[reach->areanum].numlinks++;
+			revlink->next = (*aasworld).reversedreachability[reach->areanum].first;
+			(*aasworld).reversedreachability[reach->areanum].first = revlink;
+			(*aasworld).reversedreachability[reach->areanum].numlinks++;
 		}
 	}
 #ifdef DEBUG
@@ -528,41 +528,41 @@
 	starttime = botimport.MilliSeconds();
 #endif
 	// if there are still area travel times, free the memory
-	if (aasworld.areatraveltimes) {
-		FreeMemory(aasworld.areatraveltimes);
+	if ((*aasworld).areatraveltimes) {
+		FreeMemory((*aasworld).areatraveltimes);
 	}
 	// get the total size of all the area travel times
-	size = aasworld.numareas * sizeof(unsigned short **);
+	size = (*aasworld).numareas * sizeof(unsigned short **);
 
-	for (i = 0; i < aasworld.numareas; i++) {
-		revreach = &aasworld.reversedreachability[i];
+	for (i = 0; i < (*aasworld).numareas; i++) {
+		revreach = &(*aasworld).reversedreachability[i];
 		// settings of the area
-		settings = &aasworld.areasettings[i];
+		settings = &(*aasworld).areasettings[i];
 		size += settings->numreachableareas * sizeof(unsigned short *);
 		size += settings->numreachableareas * PAD(revreach->numlinks, sizeof(long)) * sizeof(unsigned short);
 	}
 	// allocate memory for the area travel times
 	ptr = (char *)GetClearedMemory(size);
-	aasworld.areatraveltimes = (unsigned short ***)ptr;
-	ptr += aasworld.numareas * sizeof(unsigned short **);
+	(*aasworld).areatraveltimes = (unsigned short ***)ptr;
+	ptr += (*aasworld).numareas * sizeof(unsigned short **);
 	// calcluate the travel times for all the areas
-	for (i = 0; i < aasworld.numareas; i++) {
+	for (i = 0; i < (*aasworld).numareas; i++) {
 		// reversed reachabilities of this area
-		revreach = &aasworld.reversedreachability[i];
+		revreach = &(*aasworld).reversedreachability[i];
 		// settings of the area
-		settings = &aasworld.areasettings[i];
-		aasworld.areatraveltimes[i] = (unsigned short **)ptr;
+		settings = &(*aasworld).areasettings[i];
+		(*aasworld).areatraveltimes[i] = (unsigned short **)ptr;
 		ptr += settings->numreachableareas * sizeof(unsigned short *);
 
 		for (l = 0; l < settings->numreachableareas; l++) {
-			aasworld.areatraveltimes[i][l] = (unsigned short *)ptr;
+			(*aasworld).areatraveltimes[i][l] = (unsigned short *)ptr;
 			ptr += PAD(revreach->numlinks, sizeof(long)) * sizeof(unsigned short);
 			// reachability link
-			reach = &aasworld.reachability[settings->firstreachablearea + l];
+			reach = &(*aasworld).reachability[settings->firstreachablearea + l];
 
 			for (n = 0, revlink = revreach->first; revlink; revlink = revlink->next, n++) {
-				VectorCopy(aasworld.reachability[revlink->linknum].end, end);
-				aasworld.areatraveltimes[i][l][n] = AAS_AreaTravelTime(i, end, reach->start);
+				VectorCopy((*aasworld).reachability[revlink->linknum].end, end);
+				(*aasworld).areatraveltimes[i][l][n] = AAS_AreaTravelTime(i, end, reach->start);
 			}
 		}
 	}
@@ -583,16 +583,16 @@
 	aas_reversedlink_t *revlink;
 	aas_areasettings_t *settings;
 
-	portal = &aasworld.portals[portalnum];
+	portal = &(*aasworld).portals[portalnum];
 	// reversed reachabilities of this portal area
-	revreach = &aasworld.reversedreachability[portal->areanum];
+	revreach = &(*aasworld).reversedreachability[portal->areanum];
 	// settings of the portal area
-	settings = &aasworld.areasettings[portal->areanum];
+	settings = &(*aasworld).areasettings[portal->areanum];
 	maxt = 0;
 
 	for (l = 0; l < settings->numreachableareas; l++) {
 		for (n = 0, revlink = revreach->first; revlink; revlink = revlink->next, n++) {
-			t = aasworld.areatraveltimes[portal->areanum][l][n];
+			t = (*aasworld).areatraveltimes[portal->areanum][l][n];
 
 			if (t > maxt) {
 				maxt = t;
@@ -611,15 +611,15 @@
 void AAS_InitPortalMaxTravelTimes(void) {
 	int i;
 
-	if (aasworld.portalmaxtraveltimes) {
-		FreeMemory(aasworld.portalmaxtraveltimes);
+	if ((*aasworld).portalmaxtraveltimes) {
+		FreeMemory((*aasworld).portalmaxtraveltimes);
 	}
 
-	aasworld.portalmaxtraveltimes = (int *)GetClearedMemory(aasworld.numportals * sizeof(int));
+	(*aasworld).portalmaxtraveltimes = (int *)GetClearedMemory((*aasworld).numportals * sizeof(int));
 
-	for (i = 0; i < aasworld.numportals; i++) {
-		aasworld.portalmaxtraveltimes[i] = AAS_PortalMaxTravelTime(i);
-		//botimport.Print(PRT_MESSAGE, "portal %d max tt = %d\n", i, aasworld.portalmaxtraveltimes[i]);
+	for (i = 0; i < (*aasworld).numportals; i++) {
+		(*aasworld).portalmaxtraveltimes[i] = AAS_PortalMaxTravelTime(i);
+		//botimport.Print(PRT_MESSAGE, "portal %d max tt = %d\n", i, (*aasworld).portalmaxtraveltimes[i]);
 	}
 }
 
@@ -640,11 +640,11 @@
 	bestcluster = 0;
 	bestarea = 0;
 	// refresh cluster cache
-	for (i = 0; i < aasworld.numclusters; i++) {
-		for (j = 0; j < aasworld.clusters[i].numareas; j++) {
-			for (cache = aasworld.clusterareacache[i][j]; cache; cache = cache->next) {
+	for (i = 0; i < (*aasworld).numclusters; i++) {
+		for (j = 0; j < (*aasworld).clusters[i].numareas; j++) {
+			for (cache = (*aasworld).clusterareacache[i][j]; cache; cache = cache->next) {
 				// never remove cache leading towards a portal
-				if (aasworld.areasettings[cache->areanum].cluster < 0) {
+				if ((*aasworld).areasettings[cache->areanum].cluster < 0) {
 					continue;
 				}
 				// if this cache is older than the cache we found so far
@@ -664,7 +664,7 @@
 		if (cache->prev) {
 			cache->prev->next = cache->next;
 		} else {
-			aasworld.clusterareacache[bestcluster][bestarea] = cache->next;
+			(*aasworld).clusterareacache[bestcluster][bestarea] = cache->next;
 		}
 
 		if (cache->next) {
@@ -680,9 +680,9 @@
 	bestcache = NULL;
 	bestarea = 0;
 
-	for (i = 0; i < aasworld.numareas; i++) {
+	for (i = 0; i < (*aasworld).numareas; i++) {
 		// refresh portal cache
-		for (cache = aasworld.portalcache[i]; cache; cache = cache->next) {
+		for (cache = (*aasworld).portalcache[i]; cache; cache = cache->next) {
 			if (cache->time < besttime) {
 				bestcache = cache;
 				bestarea = i;
@@ -697,7 +697,7 @@
 		if (cache->prev) {
 			cache->prev->next = cache->next;
 		} else {
-			aasworld.portalcache[bestarea] = cache->next;
+			(*aasworld).portalcache[bestarea] = cache->next;
 		}
 
 		if (cache->next) {
@@ -716,9 +716,9 @@
 	int clusterareanum;
 	aas_routingcache_t *cache;
 
-	for (cache = aasworld.oldestcache; cache; cache = cache->time_next) {
+	for (cache = (*aasworld).oldestcache; cache; cache = cache->time_next) {
 		// never free area cache leading towards a portal
-		if (cache->type == CACHETYPE_AREA && aasworld.areasettings[cache->areanum].cluster < 0) {
+		if (cache->type == CACHETYPE_AREA && (*aasworld).areasettings[cache->areanum].cluster < 0) {
 			continue;
 		}
 
@@ -734,7 +734,7 @@
 			if (cache->prev) {
 				cache->prev->next = cache->next;
 			} else {
-				aasworld.clusterareacache[cache->cluster][clusterareanum] = cache->next;
+				(*aasworld).clusterareacache[cache->cluster][clusterareanum] = cache->next;
 			}
 
 			if (cache->next) {
@@ -745,7 +745,7 @@
 			if (cache->prev) {
 				cache->prev->next = cache->next;
 			} else {
-				aasworld.portalcache[cache->areanum] = cache->next;
+				(*aasworld).portalcache[cache->areanum] = cache->next;
 			}
 
 			if (cache->next) {
@@ -788,26 +788,26 @@
 	aas_cluster_t *cluster;
 
 	// free all cluster cache if existing
-	if (!aasworld.clusterareacache) {
+	if (!(*aasworld).clusterareacache) {
 		return;
 	}
 	// free caches
-	for (i = 0; i < aasworld.numclusters; i++) {
-		cluster = &aasworld.clusters[i];
+	for (i = 0; i < (*aasworld).numclusters; i++) {
+		cluster = &(*aasworld).clusters[i];
 
 		for (j = 0; j < cluster->numareas; j++) {
-			for (cache = aasworld.clusterareacache[i][j]; cache; cache = nextcache) {
+			for (cache = (*aasworld).clusterareacache[i][j]; cache; cache = nextcache) {
 				nextcache = cache->next;
 				AAS_FreeRoutingCache(cache);
 			}
 
-			aasworld.clusterareacache[i][j] = NULL;
+			(*aasworld).clusterareacache[i][j] = NULL;
 		}
 	}
 	// free the cluster cache array
-	FreeMemory(aasworld.clusterareacache);
+	FreeMemory((*aasworld).clusterareacache);
 
-	aasworld.clusterareacache = NULL;
+	(*aasworld).clusterareacache = NULL;
 }
 
 /*
@@ -819,17 +819,17 @@
 	int i, size;
 	char *ptr;
 
-	for (size = 0, i = 0; i < aasworld.numclusters; i++) {
-		size += aasworld.clusters[i].numareas;
+	for (size = 0, i = 0; i < (*aasworld).numclusters; i++) {
+		size += (*aasworld).clusters[i].numareas;
 	}
 	// two dimensional array with pointers for every cluster to routing cache for every area in that cluster
-	ptr = (char *)GetClearedMemory(aasworld.numclusters * sizeof(aas_routingcache_t **) + size * sizeof(aas_routingcache_t *));
-	aasworld.clusterareacache = (aas_routingcache_t ***)ptr;
-	ptr += aasworld.numclusters * sizeof(aas_routingcache_t **);
+	ptr = (char *)GetClearedMemory((*aasworld).numclusters * sizeof(aas_routingcache_t **) + size * sizeof(aas_routingcache_t *));
+	(*aasworld).clusterareacache = (aas_routingcache_t ***)ptr;
+	ptr += (*aasworld).numclusters * sizeof(aas_routingcache_t **);
 
-	for (i = 0; i < aasworld.numclusters; i++) {
-		aasworld.clusterareacache[i] = (aas_routingcache_t **)ptr;
-		ptr += aasworld.clusters[i].numareas * sizeof(aas_routingcache_t *);
+	for (i = 0; i < (*aasworld).numclusters; i++) {
+		(*aasworld).clusterareacache[i] = (aas_routingcache_t **)ptr;
+		ptr += (*aasworld).clusters[i].numareas * sizeof(aas_routingcache_t *);
 	}
 }
 
@@ -843,22 +843,22 @@
 	aas_routingcache_t *cache, *nextcache;
 
 	// free all portal cache if existing
-	if (!aasworld.portalcache) {
+	if (!(*aasworld).portalcache) {
 		return;
 	}
 	// free portal caches
-	for (i = 0; i < aasworld.numareas; i++) {
-		for (cache = aasworld.portalcache[i]; cache; cache = nextcache) {
+	for (i = 0; i < (*aasworld).numareas; i++) {
+		for (cache = (*aasworld).portalcache[i]; cache; cache = nextcache) {
 			nextcache = cache->next;
 			AAS_FreeRoutingCache(cache);
 		}
 
-		aasworld.portalcache[i] = NULL;
+		(*aasworld).portalcache[i] = NULL;
 	}
 
-	FreeMemory(aasworld.portalcache);
+	FreeMemory((*aasworld).portalcache);
 
-	aasworld.portalcache = NULL;
+	(*aasworld).portalcache = NULL;
 }
 
 /*
@@ -867,7 +867,7 @@
 =======================================================================================================================================
 */
 void AAS_InitPortalCache(void) {
-	aasworld.portalcache = (aas_routingcache_t **)GetClearedMemory(aasworld.numareas * sizeof(aas_routingcache_t *));
+	(*aasworld).portalcache = (aas_routingcache_t **)GetClearedMemory((*aasworld).numareas * sizeof(aas_routingcache_t *));
 }
 
 /*
@@ -879,25 +879,25 @@
 	int i, maxreachabilityareas;
 
 	// free routing update fields if already existing
-	if (aasworld.areaupdate) {
-		FreeMemory(aasworld.areaupdate);
+	if ((*aasworld).areaupdate) {
+		FreeMemory((*aasworld).areaupdate);
 	}
 
 	maxreachabilityareas = 0;
 
-	for (i = 0; i < aasworld.numclusters; i++) {
-		if (aasworld.clusters[i].numreachabilityareas > maxreachabilityareas) {
-			maxreachabilityareas = aasworld.clusters[i].numreachabilityareas;
+	for (i = 0; i < (*aasworld).numclusters; i++) {
+		if ((*aasworld).clusters[i].numreachabilityareas > maxreachabilityareas) {
+			maxreachabilityareas = (*aasworld).clusters[i].numreachabilityareas;
 		}
 	}
 	// allocate memory for the routing update fields
-	aasworld.areaupdate = (aas_routingupdate_t *)GetClearedMemory(maxreachabilityareas * sizeof(aas_routingupdate_t));
+	(*aasworld).areaupdate = (aas_routingupdate_t *)GetClearedMemory(maxreachabilityareas * sizeof(aas_routingupdate_t));
 
-	if (aasworld.portalupdate) {
-		FreeMemory(aasworld.portalupdate);
+	if ((*aasworld).portalupdate) {
+		FreeMemory((*aasworld).portalupdate);
 	}
 	// allocate memory for the portal update fields
-	aasworld.portalupdate = (aas_routingupdate_t *)GetClearedMemory((aasworld.numportals + 1) * sizeof(aas_routingupdate_t));
+	(*aasworld).portalupdate = (aas_routingupdate_t *)GetClearedMemory(((*aasworld).numportals + 1) * sizeof(aas_routingupdate_t));
 }
 
 /*
@@ -909,15 +909,15 @@
 	int i, j;
 	//int t;
 
-	aasworld.initialized = qtrue;
+	(*aasworld).initialized = qtrue;
 	botimport.Print(PRT_MESSAGE, "AAS_CreateAllRoutingCache\n");
 
-	for (i = 1; i < aasworld.numareas; i++) {
+	for (i = 1; i < (*aasworld).numareas; i++) {
 		if (!AAS_AreaReachability(i)) {
 			continue;
 		}
 
-		for (j = 1; j < aasworld.numareas; j++) {
+		for (j = 1; j < (*aasworld).numareas; j++) {
 			if (i == j) {
 				continue;
 			}
@@ -926,13 +926,13 @@
 				continue;
 			}
 
-			AAS_AreaTravelTimeToGoalArea(i, aasworld.areas[i].center, j, TFL_DEFAULT);
-			//t = AAS_AreaTravelTimeToGoalArea(i, aasworld.areas[i].center, j, TFL_DEFAULT);
+			AAS_AreaTravelTimeToGoalArea(i, (*aasworld).areas[i].center, j, TFL_DEFAULT);
+			//t = AAS_AreaTravelTimeToGoalArea(i, (*aasworld).areas[i].center, j, TFL_DEFAULT);
 			//Log_Write("traveltime from %d to %d is %d", i, j, t);
 		}
 	}
 
-	aasworld.initialized = qfalse;
+	(*aasworld).initialized = qfalse;
 }
 
 // the route cache header
@@ -970,8 +970,8 @@
 
 	numportalcache = 0;
 
-	for (i = 0; i < aasworld.numareas; i++) {
-		for (cache = aasworld.portalcache[i]; cache; cache = cache->next) {
+	for (i = 0; i < (*aasworld).numareas; i++) {
+		for (cache = (*aasworld).portalcache[i]; cache; cache = cache->next) {
 			numportalcache++;
 		}
 	}
@@ -978,17 +978,17 @@
 
 	numareacache = 0;
 
-	for (i = 0; i < aasworld.numclusters; i++) {
-		cluster = &aasworld.clusters[i];
+	for (i = 0; i < (*aasworld).numclusters; i++) {
+		cluster = &(*aasworld).clusters[i];
 
 		for (j = 0; j < cluster->numareas; j++) {
-			for (cache = aasworld.clusterareacache[i][j]; cache; cache = cache->next) {
+			for (cache = (*aasworld).clusterareacache[i][j]; cache; cache = cache->next) {
 				numareacache++;
 			}
 		}
 	}
 	// open the file for writing
-	Com_sprintf(filename, MAX_QPATH, "maps/%s.rcd", aasworld.mapname);
+	Com_sprintf(filename, MAX_QPATH, "maps/%s.rcd", (*aasworld).mapname);
 
 	botimport.FS_FOpenFile(filename, &fp, FS_WRITE);
 
@@ -999,10 +999,10 @@
 	// create the header
 	routecacheheader.ident = RCID;
 	routecacheheader.version = RCVERSION;
-	routecacheheader.numareas = aasworld.numareas;
-	routecacheheader.numclusters = aasworld.numclusters;
-	routecacheheader.areacrc = CRC_ProcessString((unsigned char *)aasworld.areas, sizeof(aas_area_t) * aasworld.numareas);
-	routecacheheader.clustercrc = CRC_ProcessString((unsigned char *)aasworld.clusters, sizeof(aas_cluster_t) * aasworld.numclusters);
+	routecacheheader.numareas = (*aasworld).numareas;
+	routecacheheader.numclusters = (*aasworld).numclusters;
+	routecacheheader.areacrc = CRC_ProcessString((unsigned char *)(*aasworld).areas, sizeof(aas_area_t) * (*aasworld).numareas);
+	routecacheheader.clustercrc = CRC_ProcessString((unsigned char *)(*aasworld).clusters, sizeof(aas_cluster_t) * (*aasworld).numclusters);
 	routecacheheader.numportalcache = numportalcache;
 	routecacheheader.numareacache = numareacache;
 	// write the header
@@ -1010,18 +1010,18 @@
 
 	totalsize = 0;
 	// write all the cache
-	for (i = 0; i < aasworld.numareas; i++) {
-		for (cache = aasworld.portalcache[i]; cache; cache = cache->next) {
+	for (i = 0; i < (*aasworld).numareas; i++) {
+		for (cache = (*aasworld).portalcache[i]; cache; cache = cache->next) {
 			botimport.FS_Write(cache, cache->size, fp);
 			totalsize += cache->size;
 		}
 	}
 
-	for (i = 0; i < aasworld.numclusters; i++) {
-		cluster = &aasworld.clusters[i];
+	for (i = 0; i < (*aasworld).numclusters; i++) {
+		cluster = &(*aasworld).clusters[i];
 
 		for (j = 0; j < cluster->numareas; j++) {
-			for (cache = aasworld.clusterareacache[i][j]; cache; cache = cache->next) {
+			for (cache = (*aasworld).clusterareacache[i][j]; cache; cache = cache->next) {
 				botimport.FS_Write(cache, cache->size, fp);
 				totalsize += cache->size;
 			}
@@ -1029,19 +1029,19 @@
 	}
 	// write the visareas
 	/*
-	for (i = 0; i < aasworld.numareas; i++) {
-		if (!aasworld.areavisibility[i]) {
+	for (i = 0; i < (*aasworld).numareas; i++) {
+		if (!(*aasworld).areavisibility[i]) {
 			size = 0;
 			botimport.FS_Write(&size, sizeof(int), fp);
 			continue;
 		}
 
-		AAS_DecompressVis(aasworld.areavisibility[i], aasworld.numareas, aasworld.decompressedvis);
+		AAS_DecompressVis((*aasworld).areavisibility[i], (*aasworld).numareas, (*aasworld).decompressedvis);
 
-		size = AAS_CompressVis(aasworld.decompressedvis, aasworld.numareas, aasworld.decompressedvis);
+		size = AAS_CompressVis((*aasworld).decompressedvis, (*aasworld).numareas, (*aasworld).decompressedvis);
 
 		botimport.FS_Write(&size, sizeof(int), fp);
-		botimport.FS_Write(aasworld.decompressedvis, size, fp);
+		botimport.FS_Write((*aasworld).decompressedvis, size, fp);
 	}
 	*/
 	botimport.FS_FCloseFile(fp);
@@ -1078,7 +1078,7 @@
 	routecacheheader_t routecacheheader;
 	aas_routingcache_t *cache;
 
-	Com_sprintf(filename, MAX_QPATH, "maps/%s.rcd", aasworld.mapname);
+	Com_sprintf(filename, MAX_QPATH, "maps/%s.rcd", (*aasworld).mapname);
 	botimport.FS_FOpenFile(filename, &fp, FS_READ);
 
 	if (!fp) {
@@ -1097,22 +1097,22 @@
 		return qfalse;
 	}
 
-	if (routecacheheader.numareas != aasworld.numareas) {
+	if (routecacheheader.numareas != (*aasworld).numareas) {
 		//AAS_Error("route cache dump has wrong number of areas\n");
 		return qfalse;
 	}
 
-	if (routecacheheader.numclusters != aasworld.numclusters) {
+	if (routecacheheader.numclusters != (*aasworld).numclusters) {
 		//AAS_Error("route cache dump has wrong number of clusters\n");
 		return qfalse;
 	}
 
-	if (routecacheheader.areacrc != CRC_ProcessString((unsigned char *)aasworld.areas, sizeof(aas_area_t) * aasworld.numareas)) {
+	if (routecacheheader.areacrc != CRC_ProcessString((unsigned char *)(*aasworld).areas, sizeof(aas_area_t) * (*aasworld).numareas)) {
 		//AAS_Error("route cache dump area CRC incorrect\n");
 		return qfalse;
 	}
 
-	if (routecacheheader.clustercrc != CRC_ProcessString((unsigned char *)aasworld.clusters, sizeof(aas_cluster_t) * aasworld.numclusters)) {
+	if (routecacheheader.clustercrc != CRC_ProcessString((unsigned char *)(*aasworld).clusters, sizeof(aas_cluster_t) * (*aasworld).numclusters)) {
 		//AAS_Error("route cache dump cluster CRC incorrect\n");
 		return qfalse;
 	}
@@ -1119,39 +1119,39 @@
 	// read all the portal cache
 	for (i = 0; i < routecacheheader.numportalcache; i++) {
 		cache = AAS_ReadCache(fp);
-		cache->next = aasworld.portalcache[cache->areanum];
+		cache->next = (*aasworld).portalcache[cache->areanum];
 		cache->prev = NULL;
 
-		if (aasworld.portalcache[cache->areanum]) {
-			aasworld.portalcache[cache->areanum]->prev = cache;
+		if ((*aasworld).portalcache[cache->areanum]) {
+			(*aasworld).portalcache[cache->areanum]->prev = cache;
 		}
 
-		aasworld.portalcache[cache->areanum] = cache;
+		(*aasworld).portalcache[cache->areanum] = cache;
 	}
 	// read all the cluster area cache
 	for (i = 0; i < routecacheheader.numareacache; i++) {
 		cache = AAS_ReadCache(fp);
 		clusterareanum = AAS_ClusterAreaNum(cache->cluster, cache->areanum);
-		cache->next = aasworld.clusterareacache[cache->cluster][clusterareanum];
+		cache->next = (*aasworld).clusterareacache[cache->cluster][clusterareanum];
 		cache->prev = NULL;
 
-		if (aasworld.clusterareacache[cache->cluster][clusterareanum]) {
-			aasworld.clusterareacache[cache->cluster][clusterareanum]->prev = cache;
+		if ((*aasworld).clusterareacache[cache->cluster][clusterareanum]) {
+			(*aasworld).clusterareacache[cache->cluster][clusterareanum]->prev = cache;
 		}
 
-		aasworld.clusterareacache[cache->cluster][clusterareanum] = cache;
+		(*aasworld).clusterareacache[cache->cluster][clusterareanum] = cache;
 	}
 	// read the visareas
 	/*
-	aasworld.areavisibility = (byte **)GetClearedMemory(aasworld.numareas * sizeof(byte *));
-	aasworld.decompressedvis = (byte *)GetClearedMemory(aasworld.numareas * sizeof(byte));
+	(*aasworld).areavisibility = (byte **)GetClearedMemory((*aasworld).numareas * sizeof(byte *));
+	(*aasworld).decompressedvis = (byte *)GetClearedMemory((*aasworld).numareas * sizeof(byte));
 
-	for (i = 0; i < aasworld.numareas; i++) {
+	for (i = 0; i < (*aasworld).numareas; i++) {
 		botimport.FS_Read(&size, sizeof(size), fp);
 
 		if (size) {
-			aasworld.areavisibility[i] = (byte *)GetMemory(size);
-			botimport.FS_Read(aasworld.areavisibility[i], size, fp);
+			(*aasworld).areavisibility[i] = (byte *)GetMemory(size);
+			botimport.FS_Read((*aasworld).areavisibility[i], size, fp);
 		}
 	}
 	*/
@@ -1171,20 +1171,20 @@
 	aas_reachability_t *reach;
 	vec3_t start, end;
 
-	if (aasworld.reachabilityareas) {
-		FreeMemory(aasworld.reachabilityareas);
+	if ((*aasworld).reachabilityareas) {
+		FreeMemory((*aasworld).reachabilityareas);
 	}
 
-	if (aasworld.reachabilityareaindex) {
-		FreeMemory(aasworld.reachabilityareaindex);
+	if ((*aasworld).reachabilityareaindex) {
+		FreeMemory((*aasworld).reachabilityareaindex);
 	}
 
-	aasworld.reachabilityareas = (aas_reachabilityareas_t *)GetClearedMemory(aasworld.reachabilitysize * sizeof(aas_reachabilityareas_t));
-	aasworld.reachabilityareaindex = (int *)GetClearedMemory(aasworld.reachabilitysize * MAX_REACHABILITYPASSAREAS * sizeof(int));
+	(*aasworld).reachabilityareas = (aas_reachabilityareas_t *)GetClearedMemory((*aasworld).reachabilitysize * sizeof(aas_reachabilityareas_t));
+	(*aasworld).reachabilityareaindex = (int *)GetClearedMemory((*aasworld).reachabilitysize * MAX_REACHABILITYPASSAREAS * sizeof(int));
 	numreachareas = 0;
 
-	for (i = 0; i < aasworld.reachabilitysize; i++) {
-		reach = &aasworld.reachability[i];
+	for (i = 0; i < (*aasworld).reachabilitysize; i++) {
+		reach = &(*aasworld).reachability[i];
 		numareas = 0;
 
 		switch (reach->traveltype & TRAVELTYPE_MASK) {
@@ -1247,11 +1247,11 @@
 				break;
 		}
 
-		aasworld.reachabilityareas[i].firstarea = numreachareas;
-		aasworld.reachabilityareas[i].numareas = numareas;
+		(*aasworld).reachabilityareas[i].firstarea = numreachareas;
+		(*aasworld).reachabilityareas[i].numareas = numareas;
 
 		for (j = 0; j < numareas; j++) {
-			aasworld.reachabilityareaindex[numreachareas++] = areas[j];
+			(*aasworld).reachabilityareaindex[numreachareas++] = areas[j];
 		}
 	}
 }
@@ -1301,53 +1301,53 @@
 	// free all the existing portal cache
 	AAS_FreeAllPortalCache();
 	// free cached travel times within areas
-	if (aasworld.areatraveltimes) {
-		FreeMemory(aasworld.areatraveltimes);
+	if ((*aasworld).areatraveltimes) {
+		FreeMemory((*aasworld).areatraveltimes);
 	}
 
-	aasworld.areatraveltimes = NULL;
+	(*aasworld).areatraveltimes = NULL;
 	// free cached maximum travel time through cluster portals
-	if (aasworld.portalmaxtraveltimes) {
-		FreeMemory(aasworld.portalmaxtraveltimes);
+	if ((*aasworld).portalmaxtraveltimes) {
+		FreeMemory((*aasworld).portalmaxtraveltimes);
 	}
 
-	aasworld.portalmaxtraveltimes = NULL;
+	(*aasworld).portalmaxtraveltimes = NULL;
 	// free reversed reachability links
-	if (aasworld.reversedreachability) {
-		FreeMemory(aasworld.reversedreachability);
+	if ((*aasworld).reversedreachability) {
+		FreeMemory((*aasworld).reversedreachability);
 	}
 
-	aasworld.reversedreachability = NULL;
+	(*aasworld).reversedreachability = NULL;
 	// free routing algorithm memory
-	if (aasworld.areaupdate) {
-		FreeMemory(aasworld.areaupdate);
+	if ((*aasworld).areaupdate) {
+		FreeMemory((*aasworld).areaupdate);
 	}
 
-	aasworld.areaupdate = NULL;
+	(*aasworld).areaupdate = NULL;
 
-	if (aasworld.portalupdate) {
-		FreeMemory(aasworld.portalupdate);
+	if ((*aasworld).portalupdate) {
+		FreeMemory((*aasworld).portalupdate);
 	}
 
-	aasworld.portalupdate = NULL;
+	(*aasworld).portalupdate = NULL;
 	// free lists with areas the reachabilities go through
-	if (aasworld.reachabilityareas) {
-		FreeMemory(aasworld.reachabilityareas);
+	if ((*aasworld).reachabilityareas) {
+		FreeMemory((*aasworld).reachabilityareas);
 	}
 
-	aasworld.reachabilityareas = NULL;
+	(*aasworld).reachabilityareas = NULL;
 	// free the reachability area index
-	if (aasworld.reachabilityareaindex) {
-		FreeMemory(aasworld.reachabilityareaindex);
+	if ((*aasworld).reachabilityareaindex) {
+		FreeMemory((*aasworld).reachabilityareaindex);
 	}
 
-	aasworld.reachabilityareaindex = NULL;
+	(*aasworld).reachabilityareaindex = NULL;
 	// free area contents travel flags look up table
-	if (aasworld.areacontentstravelflags) {
-		FreeMemory(aasworld.areacontentstravelflags);
+	if ((*aasworld).areacontentstravelflags) {
+		FreeMemory((*aasworld).areacontentstravelflags);
 	}
 
-	aasworld.areacontentstravelflags = NULL;
+	(*aasworld).areacontentstravelflags = NULL;
 }
 
 /*
@@ -1372,10 +1372,10 @@
 	numareacacheupdates++;
 #endif // ROUTING_DEBUG
 	// number of reachability areas within this cluster
-	numreachabilityareas = aasworld.clusters[areacache->cluster].numreachabilityareas;
-	aasworld.frameroutingupdates++;
+	numreachabilityareas = (*aasworld).clusters[areacache->cluster].numreachabilityareas;
+	(*aasworld).frameroutingupdates++;
 	// clear the routing update fields
-	//Com_Memset(aasworld.areaupdate, 0, aasworld.numareas * sizeof(aas_routingupdate_t));
+	//Com_Memset((*aasworld).areaupdate, 0, (*aasworld).numareas * sizeof(aas_routingupdate_t));
 
 	badtravelflags = ~areacache->travelflags;
 	clusterareanum = AAS_ClusterAreaNum(areacache->cluster, areacache->areanum);
@@ -1386,7 +1386,7 @@
 
 	Com_Memset(startareatraveltimes, 0, sizeof(startareatraveltimes));
 
-	curupdate = &aasworld.areaupdate[clusterareanum];
+	curupdate = &(*aasworld).areaupdate[clusterareanum];
 	curupdate->areanum = areacache->areanum;
 	//VectorCopy(areacache->origin, curupdate->start);
 	curupdate->areatraveltimes = startareatraveltimes;
@@ -1412,17 +1412,17 @@
 		updateliststart = curupdate->next;
 		curupdate->inlist = qfalse;
 		// check all reversed reachability links
-		revreach = &aasworld.reversedreachability[curupdate->areanum];
+		revreach = &(*aasworld).reversedreachability[curupdate->areanum];
 
 		for (i = 0, revlink = revreach->first; revlink; revlink = revlink->next, i++) {
 			linknum = revlink->linknum;
-			reach = &aasworld.reachability[linknum];
+			reach = &(*aasworld).reachability[linknum];
 			// if there is used an undesired travel type
 			if (AAS_TravelFlagForType_inline(reach->traveltype) & badtravelflags) {
 				continue;
 			}
 			// if not allowed to enter the next area
-			if (aasworld.areasettings[reach->areanum].areaflags & AREA_DISABLED) {
+			if ((*aasworld).areasettings[reach->areanum].areaflags & AREA_DISABLED) {
 				continue;
 			}
 			// if the next area has a not allowed travel flag
@@ -1432,7 +1432,7 @@
 			// number of the area the reversed reachability leads to
 			nextareanum = revlink->areanum;
 			// get the cluster number of the area
-			cluster = aasworld.areasettings[nextareanum].cluster;
+			cluster = (*aasworld).areasettings[nextareanum].cluster;
 			// don't leave the cluster
 			if (cluster > 0 && cluster != areacache->cluster) {
 				continue;
@@ -1448,12 +1448,12 @@
 
 			if (!areacache->traveltimes[clusterareanum] || areacache->traveltimes[clusterareanum] > t) {
 				areacache->traveltimes[clusterareanum] = t;
-				areacache->reachabilities[clusterareanum] = linknum - aasworld.areasettings[nextareanum].firstreachablearea;
-				nextupdate = &aasworld.areaupdate[clusterareanum];
+				areacache->reachabilities[clusterareanum] = linknum - (*aasworld).areasettings[nextareanum].firstreachablearea;
+				nextupdate = &(*aasworld).areaupdate[clusterareanum];
 				nextupdate->areanum = nextareanum;
 				nextupdate->tmptraveltime = t;
 				//VectorCopy(reach->start, nextupdate->start);
-				nextupdate->areatraveltimes = aasworld.areatraveltimes[nextareanum][linknum - aasworld.areasettings[nextareanum].firstreachablearea];
+				nextupdate->areatraveltimes = (*aasworld).areatraveltimes[nextareanum][linknum - (*aasworld).areasettings[nextareanum].firstreachablearea];
 
 				if (!nextupdate->inlist) {
 					// we add the update to the end of the list
@@ -1487,7 +1487,7 @@
 	// number of the area in the cluster
 	clusterareanum = AAS_ClusterAreaNum(clusternum, areanum);
 	// pointer to the cache for the area in the cluster
-	clustercache = aasworld.clusterareacache[clusternum][clusterareanum];
+	clustercache = (*aasworld).clusterareacache[clusternum][clusterareanum];
 	// find the cache without undesired travel flags
 	for (cache = clustercache; cache; cache = cache->next) {
 		// if there aren't used any undesired travel types for the cache
@@ -1497,11 +1497,11 @@
 	}
 	// if there was no cache
 	if (!cache) {
-		cache = AAS_AllocRoutingCache(aasworld.clusters[clusternum].numreachabilityareas);
+		cache = AAS_AllocRoutingCache((*aasworld).clusters[clusternum].numreachabilityareas);
 		cache->cluster = clusternum;
 		cache->areanum = areanum;
 
-		VectorCopy(aasworld.areas[areanum].center, cache->origin);
+		VectorCopy((*aasworld).areas[areanum].center, cache->origin);
 
 		cache->starttraveltime = 1;
 		cache->travelflags = travelflags;
@@ -1512,7 +1512,7 @@
 			clustercache->prev = cache;
 		}
 
-		aasworld.clusterareacache[clusternum][clusterareanum] = cache;
+		(*aasworld).clusterareacache[clusternum][clusterareanum] = cache;
 
 		AAS_UpdateAreaRoutingCache(cache);
 	} else {
@@ -1542,14 +1542,14 @@
 	numportalcacheupdates++;
 #endif // ROUTING_DEBUG
 	// clear the routing update fields
-	//Com_Memset(aasworld.portalupdate, 0, (aasworld.numportals + 1) * sizeof(aas_routingupdate_t));
+	//Com_Memset((*aasworld).portalupdate, 0, ((*aasworld).numportals + 1) * sizeof(aas_routingupdate_t));
 
-	curupdate = &aasworld.portalupdate[aasworld.numportals];
+	curupdate = &(*aasworld).portalupdate[(*aasworld).numportals];
 	curupdate->cluster = portalcache->cluster;
 	curupdate->areanum = portalcache->areanum;
 	curupdate->tmptraveltime = portalcache->starttraveltime;
 	// if the start area is a cluster portal, store the travel time for that portal
-	clusternum = aasworld.areasettings[portalcache->areanum].cluster;
+	clusternum = (*aasworld).areasettings[portalcache->areanum].cluster;
 
 	if (clusternum < 0) {
 		portalcache->traveltimes[-clusternum] = portalcache->starttraveltime;
@@ -1573,12 +1573,12 @@
 		updateliststart = curupdate->next;
 		// current update is removed from the list
 		curupdate->inlist = qfalse;
-		cluster = &aasworld.clusters[curupdate->cluster];
+		cluster = &(*aasworld).clusters[curupdate->cluster];
 		cache = AAS_GetAreaRoutingCache(curupdate->cluster, curupdate->areanum, portalcache->travelflags);
 		// take all portals of the cluster
 		for (i = 0; i < cluster->numportals; i++) {
-			portalnum = aasworld.portalindex[cluster->firstportal + i];
-			portal = &aasworld.portals[portalnum];
+			portalnum = (*aasworld).portalindex[cluster->firstportal + i];
+			portal = &(*aasworld).portals[portalnum];
 			// if this is the portal of the current update continue
 			if (portal->areanum == curupdate->areanum) {
 				continue;
@@ -1600,7 +1600,7 @@
 
 			if (!portalcache->traveltimes[portalnum] || portalcache->traveltimes[portalnum] > t) {
 				portalcache->traveltimes[portalnum] = t;
-				nextupdate = &aasworld.portalupdate[portalnum];
+				nextupdate = &(*aasworld).portalupdate[portalnum];
 
 				if (portal->frontcluster == curupdate->cluster) {
 					nextupdate->cluster = portal->backcluster;
@@ -1610,7 +1610,7 @@
 
 				nextupdate->areanum = portal->areanum;
 				// add travel time through the actual portal area for the next update
-				nextupdate->tmptraveltime = t + aasworld.portalmaxtraveltimes[portalnum];
+				nextupdate->tmptraveltime = t + (*aasworld).portalmaxtraveltimes[portalnum];
 
 				if (!nextupdate->inlist) {
 					// we add the update to the end of the list
@@ -1641,7 +1641,7 @@
 	aas_routingcache_t *cache;
 
 	// find the cached portal routing if existing
-	for (cache = aasworld.portalcache[areanum]; cache; cache = cache->next) {
+	for (cache = (*aasworld).portalcache[areanum]; cache; cache = cache->next) {
 		if (cache->travelflags == travelflags) {
 			break;
 		}
@@ -1648,23 +1648,23 @@
 	}
 	// if the portal routing isn't cached
 	if (!cache) {
-		cache = AAS_AllocRoutingCache(aasworld.numportals);
+		cache = AAS_AllocRoutingCache((*aasworld).numportals);
 		cache->cluster = clusternum;
 		cache->areanum = areanum;
 
-		VectorCopy(aasworld.areas[areanum].center, cache->origin);
+		VectorCopy((*aasworld).areas[areanum].center, cache->origin);
 
 		cache->starttraveltime = 1;
 		cache->travelflags = travelflags;
 		// add the cache to the cache list
 		cache->prev = NULL;
-		cache->next = aasworld.portalcache[areanum];
+		cache->next = (*aasworld).portalcache[areanum];
 
-		if (aasworld.portalcache[areanum]) {
-			aasworld.portalcache[areanum]->prev = cache;
+		if ((*aasworld).portalcache[areanum]) {
+			(*aasworld).portalcache[areanum]->prev = cache;
 		}
 
-		aasworld.portalcache[areanum] = cache;
+		(*aasworld).portalcache[areanum] = cache;
 		// update the cache
 		AAS_UpdatePortalRoutingCache(cache);
 	} else {
@@ -1691,7 +1691,7 @@
 	aas_routingcache_t *areacache, *portalcache;
 	aas_reachability_t *reach;
 
-	if (!aasworld.initialized) {
+	if (!(*aasworld).initialized) {
 		return qfalse;
 	}
 
@@ -1701,7 +1701,7 @@
 		return qtrue;
 	}
 	// check !AAS_AreaReachability(areanum) with custom developer-only debug message
-	if (areanum <= 0 || areanum >= aasworld.numareas) {
+	if (areanum <= 0 || areanum >= (*aasworld).numareas) {
 		if (botDeveloper) {
 			botimport.Print(PRT_ERROR, "AAS_AreaTravelTimeToGoalArea: areanum %d out of range\n", areanum);
 		}
@@ -1709,7 +1709,7 @@
 		return qfalse;
 	}
 
-	if (goalareanum <= 0 || goalareanum >= aasworld.numareas) {
+	if (goalareanum <= 0 || goalareanum >= (*aasworld).numareas) {
 		if (botDeveloper) {
 			botimport.Print(PRT_ERROR, "AAS_AreaTravelTimeToGoalArea: goalareanum %d out of range\n", goalareanum);
 		}
@@ -1717,7 +1717,7 @@
 		return qfalse;
 	}
 
-	if (!aasworld.areasettings[areanum].numreachableareas || !aasworld.areasettings[goalareanum].numreachableareas) {
+	if (!(*aasworld).areasettings[areanum].numreachableareas || !(*aasworld).areasettings[goalareanum].numreachableareas) {
 		return qfalse;
 	}
 	// make sure the routing cache doesn't grow to large
@@ -1732,7 +1732,7 @@
 	}
 	// NOTE: the number of routing updates is limited per frame
 	/*
-	if (aasworld.frameroutingupdates > MAX_FRAMEROUTINGUPDATES) {
+	if ((*aasworld).frameroutingupdates > MAX_FRAMEROUTINGUPDATES) {
 #ifdef DEBUG
 		//Log_Write("WARNING: AAS_AreaTravelTimeToGoalArea: frame routing updates overflowed");
 #endif
@@ -1739,11 +1739,11 @@
 		return 0;
 	}
 	*/
-	clusternum = aasworld.areasettings[areanum].cluster;
-	goalclusternum = aasworld.areasettings[goalareanum].cluster;
+	clusternum = (*aasworld).areasettings[areanum].cluster;
+	goalclusternum = (*aasworld).areasettings[goalareanum].cluster;
 	// check if the area is a portal of the goal area cluster
 	if (clusternum < 0 && goalclusternum > 0) {
-		portal = &aasworld.portals[-clusternum];
+		portal = &(*aasworld).portals[-clusternum];
 
 		if (portal->frontcluster == goalclusternum || portal->backcluster == goalclusternum) {
 			clusternum = goalclusternum;
@@ -1750,7 +1750,7 @@
 		}
 	// check if the goalarea is a portal of the area cluster
 	} else if (clusternum > 0 && goalclusternum < 0) {
-		portal = &aasworld.portals[-goalclusternum];
+		portal = &(*aasworld).portals[-goalclusternum];
 
 		if (portal->frontcluster == clusternum || portal->backcluster == clusternum) {
 			goalclusternum = clusternum;
@@ -1763,7 +1763,7 @@
 		// the number of the area in the cluster
 		clusterareanum = AAS_ClusterAreaNum(clusternum, areanum);
 		// the cluster the area is in
-		cluster = &aasworld.clusters[clusternum];
+		cluster = &(*aasworld).clusters[clusternum];
 		// if the area is NOT a reachability area
 		if (clusterareanum >= cluster->numreachabilityareas) {
 			return 0;
@@ -1770,7 +1770,7 @@
 		}
 		// if it is possible to travel to the goal area through this cluster
 		if (areacache->traveltimes[clusterareanum] != 0) {
-			*reachnum = aasworld.areasettings[areanum].firstreachablearea + areacache->reachabilities[clusterareanum];
+			*reachnum = (*aasworld).areasettings[areanum].firstreachablearea + areacache->reachabilities[clusterareanum];
 
 			if (!origin) {
 				*traveltime = areacache->traveltimes[clusterareanum];
@@ -1777,18 +1777,18 @@
 				return qtrue;
 			}
 
-			reach = &aasworld.reachability[*reachnum];
+			reach = &(*aasworld).reachability[*reachnum];
 			*traveltime = areacache->traveltimes[clusterareanum] + AAS_AreaTravelTime(areanum, origin, reach->start);
 			return qtrue;
 		}
 	}
 
-	clusternum = aasworld.areasettings[areanum].cluster;
-	goalclusternum = aasworld.areasettings[goalareanum].cluster;
+	clusternum = (*aasworld).areasettings[areanum].cluster;
+	goalclusternum = (*aasworld).areasettings[goalareanum].cluster;
 	// if the goal area is a portal
 	if (goalclusternum < 0) {
 		// just assume the goal area is part of the front cluster
-		portal = &aasworld.portals[-goalclusternum];
+		portal = &(*aasworld).portals[-goalclusternum];
 		goalclusternum = portal->frontcluster;
 	}
 	// get the portal routing cache
@@ -1796,7 +1796,7 @@
 	// if the area is a cluster portal, read directly from the portal cache
 	if (clusternum < 0) {
 		*traveltime = portalcache->traveltimes[-clusternum];
-		*reachnum = aasworld.areasettings[areanum].firstreachablearea + portalcache->reachabilities[-clusternum];
+		*reachnum = (*aasworld).areasettings[areanum].firstreachablearea + portalcache->reachabilities[-clusternum];
 		return qtrue;
 	}
 
@@ -1803,16 +1803,16 @@
 	besttime = 0;
 	bestreachnum = -1;
 	// the cluster the area is in
-	cluster = &aasworld.clusters[clusternum];
+	cluster = &(*aasworld).clusters[clusternum];
 	// find the portal of the area cluster leading towards the goal area
 	for (i = 0; i < cluster->numportals; i++) {
-		portalnum = aasworld.portalindex[cluster->firstportal + i];
+		portalnum = (*aasworld).portalindex[cluster->firstportal + i];
 		// if the goal area isn't reachable from the portal
 		if (!portalcache->traveltimes[portalnum]) {
 			continue;
 		}
 
-		portal = &aasworld.portals[portalnum];
+		portal = &(*aasworld).portals[portalnum];
 		// get the cache of the portal area
 		areacache = AAS_GetAreaRoutingCache(clusternum, portal->areanum, travelflags);
 		// current area inside the current cluster
@@ -1832,11 +1832,11 @@
 		//		because we can't directly calculate the exact travel time
 		//		to be more specific we don't know which reachability was used to travel
 		//		into the portal area
-		t += aasworld.portalmaxtraveltimes[portalnum];
+		t += (*aasworld).portalmaxtraveltimes[portalnum];
 
 		if (origin) {
-			*reachnum = aasworld.areasettings[areanum].firstreachablearea + areacache->reachabilities[clusterareanum];
-			reach = aasworld.reachability + *reachnum;
+			*reachnum = (*aasworld).areasettings[areanum].firstreachablearea + areacache->reachabilities[clusterareanum];
+			reach = (*aasworld).reachability + *reachnum;
 			t += AAS_AreaTravelTime(areanum, origin, reach->start);
 		}
 		// if the time is better than the one already found
@@ -1884,7 +1884,7 @@
 	reachnum = 0;
 
 	if (AAS_AreaRouteToGoalArea(areanum, origin, goalareanum, travelflags, &traveltime, &reachnum)) {
-		reach = &aasworld.reachability[reachnum];
+		reach = &(*aasworld).reachability[reachnum];
 
 		if (loopareanum && reach->areanum == loopareanum) {
 			return 0; // going here will cause a looped route
@@ -1939,7 +1939,7 @@
 
 	VectorCopy(origin, curorigin);
 
-	for (i = 0; curareanum != goalareanum && (!maxareas || i < maxareas) && i < aasworld.numareas; i++) {
+	for (i = 0; curareanum != goalareanum && (!maxareas || i < maxareas) && i < (*aasworld).numareas; i++) {
 		reachnum = AAS_AreaReachabilityToGoalArea(curareanum, curorigin, goalareanum, travelflags);
 
 		if (!reachnum) {
@@ -1947,13 +1947,13 @@
 			return qfalse;
 		}
 
-		reach = &aasworld.reachability[reachnum];
+		reach = &(*aasworld).reachability[reachnum];
 
 		if (stopevent & RSE_USETRAVELTYPE) {
 			if (AAS_TravelFlagForType_inline(reach->traveltype) & stoptfl) {
 				route->stopevent = RSE_USETRAVELTYPE;
 				route->endarea = curareanum;
-				route->endcontents = aasworld.areasettings[curareanum].contents;
+				route->endcontents = (*aasworld).areasettings[curareanum].contents;
 				route->endtravelflags = AAS_TravelFlagForType_inline(reach->traveltype);
 
 				VectorCopy(reach->start, route->endpos);
@@ -1963,7 +1963,7 @@
 			if (AAS_AreaContentsTravelFlags_inline(reach->areanum) & stoptfl) {
 				route->stopevent = RSE_USETRAVELTYPE;
 				route->endarea = reach->areanum;
-				route->endcontents = aasworld.areasettings[reach->areanum].contents;
+				route->endcontents = (*aasworld).areasettings[reach->areanum].contents;
 				route->endtravelflags = AAS_AreaContentsTravelFlags_inline(reach->areanum);
 
 				VectorCopy(reach->end, route->endpos);
@@ -1974,20 +1974,20 @@
 			}
 		}
 
-		reachareas = &aasworld.reachabilityareas[reachnum];
+		reachareas = &(*aasworld).reachabilityareas[reachnum];
 
 		for (j = 0; j < reachareas->numareas + 1; j++) {
 			if (j >= reachareas->numareas) {
 				testareanum = reach->areanum;
 			} else {
-				testareanum = aasworld.reachabilityareaindex[reachareas->firstarea + j];
+				testareanum = (*aasworld).reachabilityareaindex[reachareas->firstarea + j];
 			}
 
 			if (stopevent & RSE_ENTERCONTENTS) {
-				if (aasworld.areasettings[testareanum].contents & stopcontents) {
+				if ((*aasworld).areasettings[testareanum].contents & stopcontents) {
 					route->stopevent = RSE_ENTERCONTENTS;
 					route->endarea = testareanum;
-					route->endcontents = aasworld.areasettings[testareanum].contents;
+					route->endcontents = (*aasworld).areasettings[testareanum].contents;
 
 					VectorCopy(reach->end, route->endpos);
 
@@ -2001,7 +2001,7 @@
 				if (testareanum == stopareanum) {
 					route->stopevent = RSE_ENTERAREA;
 					route->endarea = testareanum;
-					route->endcontents = aasworld.areasettings[testareanum].contents;
+					route->endcontents = (*aasworld).areasettings[testareanum].contents;
 
 					VectorCopy(reach->start, route->endpos);
 					return qtrue;
@@ -2012,7 +2012,7 @@
 		route->time += AAS_AreaTravelTime(areanum, origin, reach->start);
 		route->time += reach->traveltime;
 		route->endarea = reach->areanum;
-		route->endcontents = aasworld.areasettings[reach->areanum].contents;
+		route->endcontents = (*aasworld).areasettings[reach->areanum].contents;
 		route->endtravelflags = AAS_TravelFlagForType_inline(reach->traveltype);
 
 		VectorCopy(reach->end, route->endpos);
@@ -2049,17 +2049,17 @@
 */
 void AAS_ReachabilityFromNum(int num, struct aas_reachability_s *reach) {
 
-	if (!aasworld.initialized) {
+	if (!(*aasworld).initialized) {
 		Com_Memset(reach, 0, sizeof(aas_reachability_t));
 		return;
 	}
 
-	if (num < 0 || num >= aasworld.reachabilitysize) {
+	if (num < 0 || num >= (*aasworld).reachabilitysize) {
 		Com_Memset(reach, 0, sizeof(aas_reachability_t));
 		return;
 	}
 
-	Com_Memcpy(reach, &aasworld.reachability[num], sizeof(aas_reachability_t));
+	Com_Memcpy(reach, &(*aasworld).reachability[num], sizeof(aas_reachability_t));
 }
 
 /*
@@ -2070,16 +2070,16 @@
 int AAS_NextAreaReachability(int areanum, int reachnum) {
 	aas_areasettings_t *settings;
 
-	if (!aasworld.initialized) {
+	if (!(*aasworld).initialized) {
 		return 0;
 	}
 
-	if (areanum <= 0 || areanum >= aasworld.numareas) {
+	if (areanum <= 0 || areanum >= (*aasworld).numareas) {
 		botimport.Print(PRT_ERROR, "AAS_NextAreaReachability: areanum %d out of range\n", areanum);
 		return 0;
 	}
 
-	settings = &aasworld.areasettings[areanum];
+	settings = &(*aasworld).areasettings[areanum];
 
 	if (!reachnum) {
 		return settings->firstreachablearea;
@@ -2109,19 +2109,19 @@
 
 	if (num <= 0) {
 		num = 1;
-	} else if (num >= aasworld.reachabilitysize) {
+	} else if (num >= (*aasworld).reachabilitysize) {
 		return 0;
 	} else {
 		num++;
 	}
 
-	for (i = num; i < aasworld.reachabilitysize; i++) {
-		if ((aasworld.reachability[i].traveltype & TRAVELTYPE_MASK) == TRAVEL_ELEVATOR) {
-			if (aasworld.reachability[i].facenum == modelnum) {
+	for (i = num; i < (*aasworld).reachabilitysize; i++) {
+		if (((*aasworld).reachability[i].traveltype & TRAVELTYPE_MASK) == TRAVEL_ELEVATOR) {
+			if ((*aasworld).reachability[i].facenum == modelnum) {
 				return i;
 			}
-		} else if ((aasworld.reachability[i].traveltype & TRAVELTYPE_MASK) == TRAVEL_FUNCBOB) {
-			if ((aasworld.reachability[i].facenum & 0x0000FFFF) == modelnum) {
+		} else if (((*aasworld).reachability[i].traveltype & TRAVELTYPE_MASK) == TRAVEL_FUNCBOB) {
+			if (((*aasworld).reachability[i].facenum & 0x0000FFFF) == modelnum) {
 				return i;
 			}
 		}
@@ -2145,30 +2145,30 @@
 		return qfalse;
 	}
 
-	n = aasworld.numareas * random();
+	n = (*aasworld).numareas * random();
 
-	for (i = 0; i < aasworld.numareas; i++) {
+	for (i = 0; i < (*aasworld).numareas; i++) {
 		if (n <= 0) {
 			n = 1;
 		}
 
-		if (n >= aasworld.numareas) {
+		if (n >= (*aasworld).numareas) {
 			n = 1;
 		}
 
 		if (AAS_AreaReachability(n)) {
-			t = AAS_AreaTravelTimeToGoalArea(areanum, aasworld.areas[areanum].center, n, travelflags);
+			t = AAS_AreaTravelTimeToGoalArea(areanum, (*aasworld).areas[areanum].center, n, travelflags);
 			// if the goal is reachable
 			if (t > 0) {
 				if (AAS_AreaSwim(n)) {
 					*goalareanum = n;
 
-					VectorCopy(aasworld.areas[n].center, goalorigin);
+					VectorCopy((*aasworld).areas[n].center, goalorigin);
 					//botimport.Print(PRT_MESSAGE, "found random goal area %d\n", *goalareanum);
 					return qtrue;
 				}
 
-				VectorCopy(aasworld.areas[n].center, start);
+				VectorCopy((*aasworld).areas[n].center, start);
 
 				if (!AAS_PointAreaNum(start)) {
 					Log_Write("area %d center %f %f %f in solid?", n, start[0], start[1], start[2]);
@@ -2235,9 +2235,9 @@
 	qboolean startVisible;
 
 	if (!hidetraveltimes) {
-		hidetraveltimes = (unsigned short int *)GetClearedMemory(aasworld.numareas * sizeof(unsigned short int));
+		hidetraveltimes = (unsigned short int *)GetClearedMemory((*aasworld).numareas * sizeof(unsigned short int));
 	} else {
-		Com_Memset(hidetraveltimes, 0, aasworld.numareas * sizeof(unsigned short int));
+		Com_Memset(hidetraveltimes, 0, (*aasworld).numareas * sizeof(unsigned short int));
 	}
 
 	besttraveltime = 0;
@@ -2245,12 +2245,12 @@
 	// assume visible
 	startVisible = qtrue;
 	badtravelflags = ~travelflags;
-	curupdate = &aasworld.areaupdate[areanum];
+	curupdate = &(*aasworld).areaupdate[areanum];
 	curupdate->areanum = areanum;
 
 	VectorCopy(origin, curupdate->start);
 
-	curupdate->areatraveltimes = aasworld.areatraveltimes[areanum][0];
+	curupdate->areatraveltimes = (*aasworld).areatraveltimes[areanum][0];
 	curupdate->tmptraveltime = 0;
 	// put the area to start with in the current read list
 	curupdate->next = NULL;
@@ -2271,8 +2271,8 @@
 		updateliststart = curupdate->next;
 		curupdate->inlist = qfalse;
 		// check all reversed reachability links
-		numreach = aasworld.areasettings[curupdate->areanum].numreachableareas;
-		reach = &aasworld.reachability[aasworld.areasettings[curupdate->areanum].firstreachablearea];
+		numreach = (*aasworld).areasettings[curupdate->areanum].numreachableareas;
+		reach = &(*aasworld).reachability[(*aasworld).areasettings[curupdate->areanum].firstreachablearea];
 
 		for (i = 0; i < numreach; i++, reach++) {
 			// if an undesired travel type is used
@@ -2336,7 +2336,7 @@
 				}
 
 				hidetraveltimes[nextareanum] = t;
-				nextupdate = &aasworld.areaupdate[nextareanum];
+				nextupdate = &(*aasworld).areaupdate[nextareanum];
 				nextupdate->areanum = nextareanum;
 				nextupdate->tmptraveltime = t;
 				// remember where we entered this area
Index: code/botlib/be_aas_routealt.c
===================================================================
--- code/botlib/be_aas_routealt.c	(revision 1306)
+++ code/botlib/be_aas_routealt.c	(working copy)
@@ -69,10 +69,10 @@
 	// remove the area from the mid range areas
 	midrangeareas[areanum].valid = qfalse;
 	// flood to other areas through the faces of this area
-	area = &aasworld.areas[areanum];
+	area = &(*aasworld).areas[areanum];
 
 	for (i = 0; i < area->numfaces; i++) {
-		face = &aasworld.faces[abs(aasworld.faceindex[area->firstface + i])];
+		face = &(*aasworld).faces[abs((*aasworld).faceindex[area->firstface + i])];
 		// get the area at the other side of the face
 		if (face->frontarea == areanum) {
 			otherareanum = face->backarea;
@@ -117,15 +117,15 @@
 	// travel time towards the goal area
 	goaltraveltime = AAS_AreaTravelTimeToGoalArea(startareanum, start, goalareanum, travelflags);
 	// clear the midrange areas
-	Com_Memset(midrangeareas, 0, aasworld.numareas * sizeof(midrangearea_t));
+	Com_Memset(midrangeareas, 0, (*aasworld).numareas * sizeof(midrangearea_t));
 
 	numaltroutegoals = 0;
 	nummidrangeareas = 0;
 
-	for (i = 1; i < aasworld.numareas; i++) {
+	for (i = 1; i < (*aasworld).numareas; i++) {
 		if (!(type & ALTROUTEGOAL_ALL)) {
-			if (!(type & ALTROUTEGOAL_CLUSTERPORTALS && (aasworld.areasettings[i].contents & AREACONTENTS_CLUSTERPORTAL))) {
-				if (!(type & ALTROUTEGOAL_VIEWPORTALS && (aasworld.areasettings[i].contents & AREACONTENTS_VIEWPORTAL))) {
+			if (!(type & ALTROUTEGOAL_CLUSTERPORTALS && ((*aasworld).areasettings[i].contents & AREACONTENTS_CLUSTERPORTAL))) {
+				if (!(type & ALTROUTEGOAL_VIEWPORTALS && ((*aasworld).areasettings[i].contents & AREACONTENTS_VIEWPORTAL))) {
 					continue;
 				}
 			}
@@ -164,7 +164,7 @@
 		nummidrangeareas++;
 	}
 
-	for (i = 1; i < aasworld.numareas; i++) {
+	for (i = 1; i < (*aasworld).numareas; i++) {
 		if (!midrangeareas[i].valid) {
 			continue;
 		}
@@ -177,7 +177,7 @@
 		VectorClear(mid);
 
 		for (j = 0; j < numclusterareas; j++) {
-			VectorAdd(mid, aasworld.areas[clusterareas[j]].center, mid);
+			VectorAdd(mid, (*aasworld).areas[clusterareas[j]].center, mid);
 		}
 
 		VectorScale(mid, 1.0 / numclusterareas, mid);
@@ -186,7 +186,7 @@
 		bestareanum = 0;
 
 		for (j = 0; j < numclusterareas; j++) {
-			VectorSubtract(mid, aasworld.areas[clusterareas[j]].center, dir);
+			VectorSubtract(mid, (*aasworld).areas[clusterareas[j]].center, dir);
 
 			dist = VectorLength(dir);
 
@@ -197,7 +197,7 @@
 		}
 		// now we've got an area for an alternative route
 		// FIXME: add alternative goal origin
-		VectorCopy(aasworld.areas[bestareanum].center, altroutegoals[numaltroutegoals].origin);
+		VectorCopy((*aasworld).areas[bestareanum].center, altroutegoals[numaltroutegoals].origin);
 
 		altroutegoals[numaltroutegoals].areanum = bestareanum;
 		altroutegoals[numaltroutegoals].starttraveltime = midrangeareas[bestareanum].starttime;
@@ -231,13 +231,13 @@
 		FreeMemory(midrangeareas);
 	}
 
-	midrangeareas = (midrangearea_t *)GetMemory(aasworld.numareas * sizeof(midrangearea_t));
+	midrangeareas = (midrangearea_t *)GetMemory((*aasworld).numareas * sizeof(midrangearea_t));
 
 	if (clusterareas) {
 		FreeMemory(clusterareas);
 	}
 
-	clusterareas = (int *)GetMemory(aasworld.numareas * sizeof(int));
+	clusterareas = (int *)GetMemory((*aasworld).numareas * sizeof(int));
 #endif
 }
 
Index: code/botlib/be_aas_sample.c
===================================================================
--- code/botlib/be_aas_sample.c	(revision 1306)
+++ code/botlib/be_aas_sample.c	(working copy)
@@ -87,9 +87,9 @@
 void AAS_InitAASLinkHeap(void) {
 	int i, max_aaslinks;
 
-	max_aaslinks = aasworld.linkheapsize;
+	max_aaslinks = (*aasworld).linkheapsize;
 	// if there's no link heap present
-	if (!aasworld.linkheap) {
+	if (!(*aasworld).linkheap) {
 #ifdef BSPC
 		max_aaslinks = 6144;
 #else
@@ -99,22 +99,22 @@
 			max_aaslinks = 0;
 		}
 
-		aasworld.linkheapsize = max_aaslinks;
-		aasworld.linkheap = (aas_link_t *)GetHunkMemory(max_aaslinks * sizeof(aas_link_t));
+		(*aasworld).linkheapsize = max_aaslinks;
+		(*aasworld).linkheap = (aas_link_t *)GetHunkMemory(max_aaslinks * sizeof(aas_link_t));
 	}
 	// link the links on the heap
-	aasworld.linkheap[0].prev_ent = NULL;
-	aasworld.linkheap[0].next_ent = &aasworld.linkheap[1];
+	(*aasworld).linkheap[0].prev_ent = NULL;
+	(*aasworld).linkheap[0].next_ent = &(*aasworld).linkheap[1];
 
 	for (i = 1; i < max_aaslinks - 1; i++) {
-		aasworld.linkheap[i].prev_ent = &aasworld.linkheap[i - 1];
-		aasworld.linkheap[i].next_ent = &aasworld.linkheap[i + 1];
+		(*aasworld).linkheap[i].prev_ent = &(*aasworld).linkheap[i - 1];
+		(*aasworld).linkheap[i].next_ent = &(*aasworld).linkheap[i + 1];
 	}
 
-	aasworld.linkheap[max_aaslinks - 1].prev_ent = &aasworld.linkheap[max_aaslinks - 2];
-	aasworld.linkheap[max_aaslinks - 1].next_ent = NULL;
+	(*aasworld).linkheap[max_aaslinks - 1].prev_ent = &(*aasworld).linkheap[max_aaslinks - 2];
+	(*aasworld).linkheap[max_aaslinks - 1].next_ent = NULL;
 	// pointer to the first free link
-	aasworld.freelinks = &aasworld.linkheap[0];
+	(*aasworld).freelinks = &(*aasworld).linkheap[0];
 
 	numaaslinks = max_aaslinks;
 }
@@ -126,12 +126,12 @@
 */
 void AAS_FreeAASLinkHeap(void) {
 
-	if (aasworld.linkheap) {
-		FreeMemory(aasworld.linkheap);
+	if ((*aasworld).linkheap) {
+		FreeMemory((*aasworld).linkheap);
 	}
 
-	aasworld.linkheap = NULL;
-	aasworld.linkheapsize = 0;
+	(*aasworld).linkheap = NULL;
+	(*aasworld).linkheapsize = 0;
 }
 
 /*
@@ -142,7 +142,7 @@
 aas_link_t *AAS_AllocAASLink(void) {
 	aas_link_t *link;
 
-	link = aasworld.freelinks;
+	link = (*aasworld).freelinks;
 
 	if (!link) {
 #ifndef BSPC
@@ -155,12 +155,12 @@
 		return NULL;
 	}
 
-	if (aasworld.freelinks) {
-		aasworld.freelinks = aasworld.freelinks->next_ent;
+	if ((*aasworld).freelinks) {
+		(*aasworld).freelinks = (*aasworld).freelinks->next_ent;
 	}
 
-	if (aasworld.freelinks) {
-		aasworld.freelinks->prev_ent = NULL;
+	if ((*aasworld).freelinks) {
+		(*aasworld).freelinks->prev_ent = NULL;
 	}
 
 	numaaslinks--;
@@ -174,16 +174,16 @@
 */
 void AAS_DeAllocAASLink(aas_link_t *link) {
 
-	if (aasworld.freelinks) {
-		aasworld.freelinks->prev_ent = link;
+	if ((*aasworld).freelinks) {
+		(*aasworld).freelinks->prev_ent = link;
 	}
 
 	link->prev_ent = NULL;
-	link->next_ent = aasworld.freelinks;
+	link->next_ent = (*aasworld).freelinks;
 	link->prev_area = NULL;
 	link->next_area = NULL;
 
-	aasworld.freelinks = link;
+	(*aasworld).freelinks = link;
 	numaaslinks++;
 }
 
@@ -194,15 +194,15 @@
 */
 void AAS_InitAASLinkedEntities(void) {
 
-	if (!aasworld.loaded) {
+	if (!(*aasworld).loaded) {
 		return;
 	}
 
-	if (aasworld.arealinkedentities) {
-		FreeMemory(aasworld.arealinkedentities);
+	if ((*aasworld).arealinkedentities) {
+		FreeMemory((*aasworld).arealinkedentities);
 	}
 
-	aasworld.arealinkedentities = (aas_link_t **)GetClearedHunkMemory(aasworld.numareas * sizeof(aas_link_t *));
+	(*aasworld).arealinkedentities = (aas_link_t **)GetClearedHunkMemory((*aasworld).numareas * sizeof(aas_link_t *));
 }
 
 /*
@@ -212,11 +212,11 @@
 */
 void AAS_FreeAASLinkedEntities(void) {
 
-	if (aasworld.arealinkedentities) {
-		FreeMemory(aasworld.arealinkedentities);
+	if ((*aasworld).arealinkedentities) {
+		FreeMemory((*aasworld).arealinkedentities);
 	}
 
-	aasworld.arealinkedentities = NULL;
+	(*aasworld).arealinkedentities = NULL;
 }
 
 /*
@@ -232,7 +232,7 @@
 	aas_node_t *node;
 	aas_plane_t *plane;
 
-	if (!aasworld.loaded) {
+	if (!(*aasworld).loaded) {
 		botimport.Print(PRT_ERROR, "AAS_PointAreaNum: aas not loaded\n");
 		return 0;
 	}
@@ -242,19 +242,19 @@
 	while (nodenum > 0) {
 		//botimport.Print(PRT_MESSAGE, "[%d]", nodenum);
 #ifdef AAS_SAMPLE_DEBUG
-		if (nodenum >= aasworld.numnodes) {
-			botimport.Print(PRT_ERROR, "nodenum = %d >= aasworld.numnodes = %d\n", nodenum, aasworld.numnodes);
+		if (nodenum >= (*aasworld).numnodes) {
+			botimport.Print(PRT_ERROR, "nodenum = %d >= (*aasworld).numnodes = %d\n", nodenum, (*aasworld).numnodes);
 			return 0;
 		}
 #endif // AAS_SAMPLE_DEBUG
-		node = &aasworld.nodes[nodenum];
+		node = &(*aasworld).nodes[nodenum];
 #ifdef AAS_SAMPLE_DEBUG
-		if (node->planenum < 0 || node->planenum >= aasworld.numplanes) {
-			botimport.Print(PRT_ERROR, "node->planenum = %d >= aasworld.numplanes = %d\n", node->planenum, aasworld.numplanes);
+		if (node->planenum < 0 || node->planenum >= (*aasworld).numplanes) {
+			botimport.Print(PRT_ERROR, "node->planenum = %d >= (*aasworld).numplanes = %d\n", node->planenum, (*aasworld).numplanes);
 			return 0;
 		}
 #endif // AAS_SAMPLE_DEBUG
-		plane = &aasworld.planes[node->planenum];
+		plane = &(*aasworld).planes[node->planenum];
 		dist = DotProduct(origin, plane->normal) - plane->dist;
 
 		if (dist > 0) {
@@ -282,7 +282,7 @@
 int AAS_PointReachabilityAreaIndex(vec3_t origin) {
 	int areanum, cluster, i, index;
 
-	if (!aasworld.initialized) {
+	if (!(*aasworld).initialized) {
 		return 0;
 	}
 
@@ -289,8 +289,8 @@
 	if (!origin) {
 		index = 0;
 
-		for (i = 0; i < aasworld.numclusters; i++) {
-			index += aasworld.clusters[i].numreachabilityareas;
+		for (i = 0; i < (*aasworld).numclusters; i++) {
+			index += (*aasworld).clusters[i].numreachabilityareas;
 		}
 
 		return index;
@@ -302,18 +302,18 @@
 		return 0;
 	}
 
-	cluster = aasworld.areasettings[areanum].cluster;
-	areanum = aasworld.areasettings[areanum].clusterareanum;
+	cluster = (*aasworld).areasettings[areanum].cluster;
+	areanum = (*aasworld).areasettings[areanum].clusterareanum;
 
 	if (cluster < 0) {
-		cluster = aasworld.portals[-cluster].frontcluster;
-		areanum = aasworld.portals[-cluster].clusterareanum[0];
+		cluster = (*aasworld).portals[-cluster].frontcluster;
+		areanum = (*aasworld).portals[-cluster].clusterareanum[0];
 	}
 
 	index = 0;
 
 	for (i = 0; i < cluster; i++) {
-		index += aasworld.clusters[i].numreachabilityareas;
+		index += (*aasworld).clusters[i].numreachabilityareas;
 	}
 
 	index += areanum;
@@ -327,12 +327,12 @@
 */
 int AAS_AreaCluster(int areanum) {
 
-	if (areanum <= 0 || areanum >= aasworld.numareas) {
+	if (areanum <= 0 || areanum >= (*aasworld).numareas) {
 		botimport.Print(PRT_ERROR, "AAS_AreaCluster: invalid area number\n");
 		return 0;
 	}
 
-	return aasworld.areasettings[areanum].cluster;
+	return (*aasworld).areasettings[areanum].cluster;
 }
 
 /*
@@ -344,16 +344,16 @@
 */
 int AAS_AreaPresenceType(int areanum) {
 
-	if (!aasworld.loaded) {
+	if (!(*aasworld).loaded) {
 		return 0;
 	}
 
-	if (areanum <= 0 || areanum >= aasworld.numareas) {
+	if (areanum <= 0 || areanum >= (*aasworld).numareas) {
 		botimport.Print(PRT_ERROR, "AAS_AreaPresenceType: invalid area number\n");
 		return 0;
 	}
 
-	return aasworld.areasettings[areanum].presencetype;
+	return (*aasworld).areasettings[areanum].presencetype;
 }
 
 /*
@@ -366,7 +366,7 @@
 int AAS_PointPresenceType(vec3_t origin) {
 	int areanum;
 
-	if (!aasworld.loaded) {
+	if (!(*aasworld).loaded) {
 		return 0;
 	}
 
@@ -376,7 +376,7 @@
 		return PRESENCE_NONE;
 	}
 
-	return aasworld.areasettings[areanum].presencetype;
+	return (*aasworld).areasettings[areanum].presencetype;
 }
 
 /*
@@ -446,7 +446,7 @@
 	bsptrace.fraction = 1;
 	collision = qfalse;
 
-	for (link = aasworld.arealinkedentities[areanum]; link; link = link->next_ent) {
+	for (link = (*aasworld).arealinkedentities[areanum]; link; link = link->next_ent) {
 		// ignore the pass entity
 		if (link->entnum == passent) {
 			continue;
@@ -497,7 +497,7 @@
 	// clear the trace structure
 	Com_Memset(&trace, 0, sizeof(aas_trace_t));
 
-	if (!aasworld.loaded) {
+	if (!(*aasworld).loaded) {
 		return trace;
 	}
 
@@ -526,7 +526,7 @@
 			trace.ent = 0;
 			trace.area = 0;
 			trace.planenum = 0;
-			trace.plane = aasworld.planes[trace.planenum];
+			trace.plane = (*aasworld).planes[trace.planenum];
 			return trace;
 		}
 		// number of the current node to test the line against
@@ -534,7 +534,7 @@
 		// if it is an area
 		if (nodenum < 0) {
 #ifdef AAS_SAMPLE_DEBUG
-			if (-nodenum > aasworld.numareasettings) {
+			if (-nodenum > (*aasworld).numareasettings) {
 				botimport.Print(PRT_ERROR, "AAS_TraceBoundingBox: -nodenum out of range\n");
 				return trace;
 			}
@@ -541,7 +541,7 @@
 #endif // AAS_SAMPLE_DEBUG
 			//botimport.Print(PRT_MESSAGE, "areanum = %d, must be %d\n", -nodenum, AAS_PointAreaNum(start));
 			// if can't enter the area because it hasn't got the right presence type
-			if (!(aasworld.areasettings[-nodenum].presencetype & presencetype)) {
+			if (!((*aasworld).areasettings[-nodenum].presencetype & presencetype)) {
 				// if the start point is still the initial start point
 				// NOTE: no need for epsilons because the points will be exactly the same when they're both the start point
 				if (tstack_p->start[0] == start[0] && tstack_p->start[1] == start[1] && tstack_p->start[2] == start[2]) {
@@ -565,13 +565,13 @@
 
 				trace.planenum = tstack_p->planenum;
 				// always take the plane with normal facing towards the trace start
-				plane = &aasworld.planes[trace.planenum];
+				plane = &(*aasworld).planes[trace.planenum];
 
 				if (DotProduct(v1, plane->normal) > 0) {
 					trace.planenum ^= 1;
 				}
 
-				trace.plane = aasworld.planes[trace.planenum];
+				trace.plane = (*aasworld).planes[trace.planenum];
 				return trace;
 			} else {
 				if (passent >= 0) {
@@ -615,29 +615,29 @@
 
 			trace.planenum = tstack_p->planenum;
 			// always take the plane with normal facing towards the trace start
-			plane = &aasworld.planes[trace.planenum];
+			plane = &(*aasworld).planes[trace.planenum];
 
 			if (DotProduct(v1, plane->normal) > 0) {
 				trace.planenum ^= 1;
 			}
 
-			trace.plane = aasworld.planes[trace.planenum];
+			trace.plane = (*aasworld).planes[trace.planenum];
 			return trace;
 		}
 #ifdef AAS_SAMPLE_DEBUG
-		if (nodenum > aasworld.numnodes) {
+		if (nodenum > (*aasworld).numnodes) {
 			botimport.Print(PRT_ERROR, "AAS_TraceBoundingBox: nodenum out of range\n");
 			return trace;
 		}
 #endif // AAS_SAMPLE_DEBUG
 		// the node to test against
-		aasnode = &aasworld.nodes[nodenum];
+		aasnode = &(*aasworld).nodes[nodenum];
 		// start point of current line to test against node
 		VectorCopy(tstack_p->start, cur_start);
 		// end point of the current line to test against node
 		VectorCopy(tstack_p->end, cur_end);
 		// the current node plane
-		plane = &aasworld.planes[aasnode->planenum];
+		plane = &(*aasworld).planes[aasnode->planenum];
 
 		switch (plane->type) {
 			/* FIXME: wtf doesn't this work? obviously the axial node planes aren't always facing positive!!!
@@ -773,7 +773,7 @@
 	numareas = 0;
 	areas[0] = 0;
 
-	if (!aasworld.loaded) {
+	if (!(*aasworld).loaded) {
 		return numareas;
 	}
 
@@ -799,7 +799,7 @@
 		// if it is an area
 		if (nodenum < 0) {
 #ifdef AAS_SAMPLE_DEBUG
-			if (-nodenum > aasworld.numareasettings) {
+			if (-nodenum > (*aasworld).numareasettings) {
 				botimport.Print(PRT_ERROR, "AAS_TraceAreas: -nodenum = %d out of range\n", -nodenum);
 				return numareas;
 			}
@@ -824,19 +824,19 @@
 			continue;
 		}
 #ifdef AAS_SAMPLE_DEBUG
-		if (nodenum > aasworld.numnodes) {
+		if (nodenum > (*aasworld).numnodes) {
 			botimport.Print(PRT_ERROR, "AAS_TraceAreas: nodenum out of range\n");
 			return numareas;
 		}
 #endif // AAS_SAMPLE_DEBUG
 		// the node to test against
-		aasnode = &aasworld.nodes[nodenum];
+		aasnode = &(*aasworld).nodes[nodenum];
 		// start point of current line to test against node
 		VectorCopy(tstack_p->start, cur_start);
 		// end point of the current line to test against node
 		VectorCopy(tstack_p->end, cur_end);
 		// the current node plane
-		plane = &aasworld.planes[aasnode->planenum];
+		plane = &(*aasworld).planes[aasnode->planenum];
 
 		switch (plane->type) {
 			/* FIXME: wtf doesn't this work? obviously the node planes aren't always facing positive!!!
@@ -979,19 +979,19 @@
 #ifdef AAS_SAMPLE_DEBUG
 	int lastvertex = 0;
 #endif // AAS_SAMPLE_DEBUG
-	if (!aasworld.loaded) {
+	if (!(*aasworld).loaded) {
 		return qfalse;
 	}
 
 	for (i = 0; i < face->numedges; i++) {
-		edgenum = aasworld.edgeindex[face->firstedge + i];
-		edge = &aasworld.edges[abs(edgenum)];
+		edgenum = (*aasworld).edgeindex[face->firstedge + i];
+		edge = &(*aasworld).edges[abs(edgenum)];
 		// get the first vertex of the edge
 		firstvertex = edgenum < 0;
 
-		VectorCopy(aasworld.vertexes[edge->v[firstvertex]], v0);
+		VectorCopy((*aasworld).vertexes[edge->v[firstvertex]], v0);
 		// edge vector
-		VectorSubtract(aasworld.vertexes[edge->v[!firstvertex]], v0, edgevec);
+		VectorSubtract((*aasworld).vertexes[edge->v[!firstvertex]], v0, edgevec);
 #ifdef AAS_SAMPLE_DEBUG
 		if (lastvertex && lastvertex != edge->v[firstvertex]) {
 			botimport.Print(PRT_MESSAGE, "winding not counter clockwise\n");
@@ -1029,20 +1029,20 @@
 	aas_plane_t *plane;
 	aas_face_t *face;
 
-	if (!aasworld.loaded) {
+	if (!(*aasworld).loaded) {
 		return qfalse;
 	}
 
-	face = &aasworld.faces[facenum];
-	plane = &aasworld.planes[face->planenum];
+	face = &(*aasworld).faces[facenum];
+	plane = &(*aasworld).planes[face->planenum];
 
 	for (i = 0; i < face->numedges; i++) {
-		edgenum = aasworld.edgeindex[face->firstedge + i];
-		edge = &aasworld.edges[abs(edgenum)];
+		edgenum = (*aasworld).edgeindex[face->firstedge + i];
+		edge = &(*aasworld).edges[abs(edgenum)];
 		// get the first vertex of the edge
 		firstvertex = edgenum < 0;
-		v1 = aasworld.vertexes[edge->v[firstvertex]];
-		v2 = aasworld.vertexes[edge->v[!firstvertex]];
+		v1 = (*aasworld).vertexes[edge->v[firstvertex]];
+		v2 = (*aasworld).vertexes[edge->v[!firstvertex]];
 		// edge vector
 		VectorSubtract(v2, v1, edgevec);
 		// vector from first edge point to point possible in face
@@ -1071,19 +1071,19 @@
 	aas_area_t *area;
 	aas_face_t *face;
 
-	if (!aasworld.loaded) {
+	if (!(*aasworld).loaded) {
 		return NULL;
 	}
 
-	area = &aasworld.areas[areanum];
+	area = &(*aasworld).areas[areanum];
 
 	for (i = 0; i < area->numfaces; i++) {
-		facenum = aasworld.faceindex[area->firstface + i];
-		face = &aasworld.faces[abs(facenum)];
+		facenum = (*aasworld).faceindex[area->firstface + i];
+		face = &(*aasworld).faces[abs(facenum)];
 		// if this is a ground face
 		if (face->faceflags & FACE_GROUND) {
 			// get the up or down normal
-			if (aasworld.planes[face->planenum].normal[2] < 0) {
+			if ((*aasworld).planes[face->planenum].normal[2] < 0) {
 				VectorNegate(up, normal);
 			} else {
 				VectorCopy(up, normal);
@@ -1108,7 +1108,7 @@
 void AAS_FacePlane(int facenum, vec3_t normal, float *dist) {
 	aas_plane_t *plane;
 
-	plane = &aasworld.planes[aasworld.faces[facenum].planenum];
+	plane = &(*aasworld).planes[(*aasworld).faces[facenum].planenum];
 	VectorCopy(plane->normal, normal);
 	*dist = plane->dist;
 }
@@ -1125,7 +1125,7 @@
 	aas_area_t *area;
 	aas_face_t *face, *firstface = NULL;
 
-	if (!aasworld.loaded) {
+	if (!(*aasworld).loaded) {
 		return NULL;
 	}
 	// if started in solid no face was hit
@@ -1133,11 +1133,11 @@
 		return NULL;
 	}
 	// trace->lastarea is the last area the trace was in
-	area = &aasworld.areas[trace->lastarea];
+	area = &(*aasworld).areas[trace->lastarea];
 	// check which face the trace.endpos was in
 	for (i = 0; i < area->numfaces; i++) {
-		facenum = aasworld.faceindex[area->firstface + i];
-		face = &aasworld.faces[abs(facenum)];
+		facenum = (*aasworld).faceindex[area->firstface + i];
+		face = &(*aasworld).faces[abs(facenum)];
 		// if the face is in the same plane as the trace end point
 		if ((face->planenum & ~1) == (trace->planenum & ~1)) {
 			// firstface is used for optimization, if there is only one face in the plane then it has to be the good one
@@ -1145,13 +1145,13 @@
 			/*
 			if (firstface) {
 				if (firstface->numedges < face->numedges) {
-					if (AAS_InsideFace(firstface, aasworld.planes[face->planenum].normal, trace->endpos)) {
+					if (AAS_InsideFace(firstface, (*aasworld).planes[face->planenum].normal, trace->endpos)) {
 						return firstface;
 					}
 
 					firstface = face;
 				} else {
-					if (AAS_InsideFace(face, aasworld.planes[face->planenum].normal, trace->endpos)) {
+					if (AAS_InsideFace(face, (*aasworld).planes[face->planenum].normal, trace->endpos)) {
 						return face;
 					}
 				}
@@ -1159,7 +1159,7 @@
 				firstface = face;
 			}
 			*/
-			if (AAS_InsideFace(face, aasworld.planes[face->planenum].normal, trace->endpos, 0.01f)) {
+			if (AAS_InsideFace(face, (*aasworld).planes[face->planenum].normal, trace->endpos, 0.01f)) {
 				return face;
 			}
 		}
@@ -1251,7 +1251,7 @@
 		if (link->prev_ent) {
 			link->prev_ent->next_ent = link->next_ent;
 		} else {
-			aasworld.arealinkedentities[link->areanum] = link->next_ent;
+			(*aasworld).arealinkedentities[link->areanum] = link->next_ent;
 		}
 
 		if (link->next_ent) {
@@ -1282,7 +1282,7 @@
 	aas_plane_t *plane;
 	aas_link_t *link, *areas;
 
-	if (!aasworld.loaded) {
+	if (!(*aasworld).loaded) {
 		botimport.Print(PRT_ERROR, "AAS_LinkEntity: aas not loaded\n");
 		return NULL;
 	}
@@ -1306,7 +1306,7 @@
 		// if it is an area
 		if (nodenum < 0) {
 			// NOTE: the entity might have already been linked into this area because several node children can point to the same area
-			for (link = aasworld.arealinkedentities[-nodenum]; link; link = link->next_ent) {
+			for (link = (*aasworld).arealinkedentities[-nodenum]; link; link = link->next_ent) {
 				if (link->entnum == entnum) {
 					break;
 				}
@@ -1335,13 +1335,13 @@
 			areas = link;
 			// put the link into the double linked entity list of the area
 			link->prev_ent = NULL;
-			link->next_ent = aasworld.arealinkedentities[-nodenum];
+			link->next_ent = (*aasworld).arealinkedentities[-nodenum];
 
-			if (aasworld.arealinkedentities[-nodenum]) {
-				aasworld.arealinkedentities[-nodenum]->prev_ent = link;
+			if ((*aasworld).arealinkedentities[-nodenum]) {
+				(*aasworld).arealinkedentities[-nodenum]->prev_ent = link;
 			}
 
-			aasworld.arealinkedentities[-nodenum] = link;
+			(*aasworld).arealinkedentities[-nodenum] = link;
 			continue;
 		}
 		// if solid leaf
@@ -1349,9 +1349,9 @@
 			continue;
 		}
 		// the node to test against
-		aasnode = &aasworld.nodes[nodenum];
+		aasnode = &(*aasworld).nodes[nodenum];
 		// the current node plane
-		plane = &aasworld.planes[aasnode->planenum];
+		plane = &(*aasworld).planes[aasnode->planenum];
 		// get the side(s) the box is situated relative to the plane
 		side = AAS_BoxOnPlaneSide2(absmins, absmaxs, plane);
 		// if on the front side of the node
@@ -1427,12 +1427,12 @@
 */
 void AAS_AreaCenter(int areanum, vec3_t center) {
 
-	if (areanum < 0 || areanum >= aasworld.numareas) {
+	if (areanum < 0 || areanum >= (*aasworld).numareas) {
 		botimport.Print(PRT_ERROR, "AAS_AreaCenter: invalid areanum %d\n", areanum);
 		return;
 	}
 
-	VectorCopy(aasworld.areas[areanum].center, center);
+	VectorCopy((*aasworld).areas[areanum].center, center);
 	return;
 }
 
@@ -1448,12 +1448,12 @@
 		return 0;
 	}
 
-	if (areanum <= 0 || areanum >= aasworld.numareas) {
+	if (areanum <= 0 || areanum >= (*aasworld).numareas) {
 		botimport.Print(PRT_ERROR, "AAS_AreaInfo: areanum %d out of range\n", areanum);
 		return 0;
 	}
 
-	settings = &aasworld.areasettings[areanum];
+	settings = &(*aasworld).areasettings[areanum];
 
 	info->cluster = settings->cluster;
 	info->contents = settings->contents;
@@ -1460,9 +1460,9 @@
 	info->flags = settings->areaflags;
 	info->presencetype = settings->presencetype;
 
-	VectorCopy(aasworld.areas[areanum].mins, info->mins);
-	VectorCopy(aasworld.areas[areanum].maxs, info->maxs);
-	VectorCopy(aasworld.areas[areanum].center, info->center);
+	VectorCopy((*aasworld).areas[areanum].mins, info->mins);
+	VectorCopy((*aasworld).areas[areanum].maxs, info->maxs);
+	VectorCopy((*aasworld).areas[areanum].center, info->center);
 	return sizeof(aas_areainfo_t);
 }
 
@@ -1473,9 +1473,9 @@
 */
 aas_plane_t *AAS_PlaneFromNum(int planenum) {
 
-	if (!aasworld.loaded) {
+	if (!(*aasworld).loaded) {
 		return NULL;
 	}
 
-	return &aasworld.planes[planenum];
+	return &(*aasworld).planes[planenum];
 }
Index: code/botlib/be_ai_move.c
===================================================================
--- code/botlib/be_ai_move.c	(revision 1306)
+++ code/botlib/be_ai_move.c	(working copy)
@@ -483,8 +483,8 @@
 	int i;
 	aas_entity_t *ent;
 
-	for (i = 0; i < aasworld.maxentities; i++) {
-		ent = &aasworld.entities[i];
+	for (i = 0; i < (*aasworld).maxentities; i++) {
+		ent = &(*aasworld).entities[i];
 
 		if (ent->i.type == ET_MOVER) {
 			if (ent->i.modelindex == modelnum) {
Index: code/botlib/be_interface.c
===================================================================
--- code/botlib/be_interface.c	(revision 1306)
+++ code/botlib/be_interface.c	(working copy)
@@ -326,9 +326,11 @@
 
 	//return 0;
 
-	if (!aasworld.loaded) {
+	if (!(*aasworld).loaded) {
 		return 0;
 	}
+	// use the default world
+	AAS_SetCurrentWorld(0);
 	/*
 	if (parm0 & 1) {
 		AAS_ClearShownPolygons();
@@ -376,39 +378,39 @@
 		botimport.Print(PRT_MESSAGE, "new area %d, cluster %d, presence type %d\n", area, AAS_AreaCluster(area), AAS_PointPresenceType(origin));
 		botimport.Print(PRT_MESSAGE, "area contents: ");
 
-		if (aasworld.areasettings[area].contents & AREACONTENTS_WATER) {
+		if ((*aasworld).areasettings[area].contents & AREACONTENTS_WATER) {
 			botimport.Print(PRT_MESSAGE, "water &");
 		}
 
-		if (aasworld.areasettings[area].contents & AREACONTENTS_LAVA) {
+		if ((*aasworld).areasettings[area].contents & AREACONTENTS_LAVA) {
 			botimport.Print(PRT_MESSAGE, "lava &");
 		}
 
-		if (aasworld.areasettings[area].contents & AREACONTENTS_SLIME) {
+		if ((*aasworld).areasettings[area].contents & AREACONTENTS_SLIME) {
 			botimport.Print(PRT_MESSAGE, "slime &");
 		}
 
-		if (aasworld.areasettings[area].contents & AREACONTENTS_JUMPPAD) {
+		if ((*aasworld).areasettings[area].contents & AREACONTENTS_JUMPPAD) {
 			botimport.Print(PRT_MESSAGE, "jump pad &");
 		}
 
-		if (aasworld.areasettings[area].contents & AREACONTENTS_CLUSTERPORTAL) {
+		if ((*aasworld).areasettings[area].contents & AREACONTENTS_CLUSTERPORTAL) {
 			botimport.Print(PRT_MESSAGE, "cluster portal &");
 		}
 
-		if (aasworld.areasettings[area].contents & AREACONTENTS_VIEWPORTAL) {
+		if ((*aasworld).areasettings[area].contents & AREACONTENTS_VIEWPORTAL) {
 			botimport.Print(PRT_MESSAGE, "view portal &");
 		}
 
-		if (aasworld.areasettings[area].contents & AREACONTENTS_DONOTENTER) {
+		if ((*aasworld).areasettings[area].contents & AREACONTENTS_DONOTENTER) {
 			botimport.Print(PRT_MESSAGE, "do not enter &");
 		}
 
-		if (aasworld.areasettings[area].contents & AREACONTENTS_MOVER) {
+		if ((*aasworld).areasettings[area].contents & AREACONTENTS_MOVER) {
 			botimport.Print(PRT_MESSAGE, "mover &");
 		}
 
-		if (!aasworld.areasettings[area].contents) {
+		if (!(*aasworld).areasettings[area].contents) {
 			botimport.Print(PRT_MESSAGE, "empty");
 		}
 
@@ -484,7 +486,7 @@
 	face = AAS_AreaGroundFace(newarea, parm2);
 
 	if (face) {
-		AAS_ShowFace(face - aasworld.faces);
+		AAS_ShowFace(face - (*aasworld).faces);
 	}
 
 	AAS_ClearShownDebugLines();
@@ -571,7 +573,7 @@
 	AAS_ClearShownDebugLines();
 
 	if (trace.entityNum) {
-		ent = &aasworld.entities[trace.entityNum];
+		ent = &(*aasworld).entities[trace.entityNum];
 		AAS_ShowBoundingBox(ent->origin, ent->mins, ent->maxs);
 	}
 
@@ -610,13 +612,13 @@
 		face = AAS_TraceEndFace(&trace);
 
 		if (face) {
-			AAS_ShowFace(face - aasworld.faces);
+			AAS_ShowFace(face - (*aasworld).faces);
 		}
 
 		AAS_DrawPlaneCross(bsptrace.endpos, bsptrace.plane.normal, bsptrace.plane.dist + bsptrace.exp_dist, bsptrace.plane.type, LINECOLOR_GREEN);
 
 		if (trace.entityNum) {
-			ent = &aasworld.entities[trace.entityNum];
+			ent = &(*aasworld).entities[trace.entityNum];
 			AAS_ShowBoundingBox(ent->origin, ent->mins, ent->maxs);
 		}
 	}
@@ -629,7 +631,7 @@
 		AAS_DrawPlaneCross(bsptrace.endpos, bsptrace.plane.normal, bsptrace.plane.dist, bsptrace.plane.type, LINECOLOR_RED);
 
 		if (bsptrace.entityNum) {
-			ent = &aasworld.entities[bsptrace.ent];
+			ent = &(*aasworld).entities[bsptrace.ent];
 			AAS_ShowBoundingBox(ent->origin, ent->mins, ent->maxs);
 		}
 	}
@@ -645,6 +647,7 @@
 */
 static void Init_AAS_Export(aas_export_t *aas) {
 
+	aas->AAS_SetCurrentWorld = AAS_SetCurrentWorld; // multiple AAS files
 	aas->AAS_Initialized = AAS_Initialized;
 	aas->AAS_Time = AAS_Time;
 	aas->AAS_AreaInfo = AAS_AreaInfo;
Index: code/botlib/botlib.h
===================================================================
--- code/botlib/botlib.h	(revision 1306)
+++ code/botlib/botlib.h	(working copy)
@@ -168,6 +168,7 @@
 } botlib_import_t;
 
 typedef struct aas_export_s {
+	void (*AAS_SetCurrentWorld)(int index);
 	int (*AAS_Initialized)(void);
 	float (*AAS_Time)(void);
 	int (*AAS_AreaInfo)(int areanum, struct aas_areainfo_s *info);
Index: code/bspc/aas_cfg.c
===================================================================
--- code/bspc/aas_cfg.c	(revision 1306)
+++ code/bspc/aas_cfg.c	(working copy)
@@ -93,7 +93,7 @@
 	{"rs_falldamage10", CFG_OFS(rs_falldamage10), FT_FLOAT},
 	{"rs_maxfallheight", CFG_OFS(rs_maxfallheight), FT_FLOAT},
 	{"rs_maxjumpfallheight", CFG_OFS(rs_maxjumpfallheight), FT_FLOAT},
-	{"rs_allowladders", CFG_OFS(rs_allowladders), FT_FLOAT},
+	{"rs_allowladders", CFG_OFS(rs_allowladders), FT_INT},
 	{NULL, 0, 0, 0}
 };
 
Index: code/bspc/aas_cfg.h
===================================================================
--- code/bspc/aas_cfg.h	(revision 1306)
+++ code/bspc/aas_cfg.h	(working copy)
@@ -77,7 +77,7 @@
 	float rs_falldamage10;
 	float rs_maxfallheight;
 	float rs_maxjumpfallheight;
-	float rs_allowladders;
+	int rs_allowladders;
 } cfg_t;
 
 extern cfg_t cfg;
Index: code/bspc/aas_create.c
===================================================================
--- code/bspc/aas_create.c	(revision 1306)
+++ code/bspc/aas_create.c	(working copy)
@@ -585,6 +585,7 @@
 	int i, flags, side, numgrounded, numladderareas, numliquidareas;
 	tmp_face_t *face;
 	tmp_area_t *tmparea;
+	int count;
 
 	numgrounded = 0;
 	numladderareas = 0;
@@ -601,11 +602,25 @@
 		tmparea->settings->contents = tmparea->contents;
 		tmparea->settings->modelnum = tmparea->modelnum;
 		flags = 0;
+		count = 0;
+		tmparea->settings->groundsteepness = 0.0;
 		for (face = tmparea->tmpfaces; face; face = face->next[side])
 		{
 			side = face->frontarea != tmparea;
 			flags |= face->faceflags;
+			// Ridah, add this face's steepness
+			if ( face->faceflags & FACE_GROUND ) {
+				tmparea->settings->groundsteepness += ( 1.0 - mapplanes[face->planenum ^ side].normal[2] );
+				count++;
+			}
 		} //end for
+		tmparea->settings->groundsteepness /= (float)count;
+		if ( tmparea->settings->groundsteepness > 1.0 ) {
+			tmparea->settings->groundsteepness = 1.0;
+		}
+		if ( tmparea->settings->groundsteepness < 0.0 ) {
+			tmparea->settings->groundsteepness = 0.0;
+		}
 		tmparea->settings->areaflags = 0;
 		if (flags & FACE_GROUND)
 		{
@@ -738,6 +753,7 @@
 	if (node->contents & CONTENTS_NOTTEAM1) tmparea->contents |= AREACONTENTS_NOTTEAM1;
 	if (node->contents & CONTENTS_NOTTEAM2) tmparea->contents |= AREACONTENTS_NOTTEAM2;
 	if (node->contents & CONTENTS_DONOTENTER) tmparea->contents |= AREACONTENTS_DONOTENTER;
+	//if ( node->contents & CONTENTS_DONOTENTER_LARGE ) tmparea->contents |= AREACONTENTS_DONOTENTER_LARGE;
 	if (node->contents & CONTENTS_WATER) tmparea->contents |= AREACONTENTS_WATER;
 	if (node->contents & CONTENTS_LAVA) tmparea->contents |= AREACONTENTS_LAVA;
 	if (node->contents & CONTENTS_SLIME) tmparea->contents |= AREACONTENTS_SLIME;
Index: code/bspc/aas_create.h
===================================================================
--- code/bspc/aas_create.h	(revision 1306)
+++ code/bspc/aas_create.h	(working copy)
@@ -56,6 +56,8 @@
 	int presencetype;				//how a bot can be present in this area
 	int numreachableareas;			//number of reachable areas from this one
 	int firstreachablearea;			//first reachable area in the reachable area index
+	// Ridah, steepness
+	float groundsteepness;
 } tmp_areasettings_t;
 
 //temporary AAS area
Index: code/bspc/aas_file.c
===================================================================
--- code/bspc/aas_file.c	(revision 1306)
+++ code/bspc/aas_file.c	(working copy)
@@ -46,121 +46,123 @@
 {
 	int i, j;
 	//bounding boxes
-	for (i = 0; i < aasworld.numbboxes; i++)
+	for (i = 0; i < ( *aasworld ).numbboxes; i++)
 	{
-		aasworld.bboxes[i].presencetype = LittleLong(aasworld.bboxes[i].presencetype);
-		aasworld.bboxes[i].flags = LittleLong(aasworld.bboxes[i].flags);
+		( *aasworld ).bboxes[i].presencetype = LittleLong(( *aasworld ).bboxes[i].presencetype);
+		( *aasworld ).bboxes[i].flags = LittleLong(( *aasworld ).bboxes[i].flags);
 		for (j = 0; j < 3; j++)
 		{
-			aasworld.bboxes[i].mins[j] = LittleLong(aasworld.bboxes[i].mins[j]);
-			aasworld.bboxes[i].maxs[j] = LittleLong(aasworld.bboxes[i].maxs[j]);
+			( *aasworld ).bboxes[i].mins[j] = LittleLong(( *aasworld ).bboxes[i].mins[j]);
+			( *aasworld ).bboxes[i].maxs[j] = LittleLong(( *aasworld ).bboxes[i].maxs[j]);
 		} //end for
 	} //end for
 	//vertexes
-	for (i = 0; i < aasworld.numvertexes; i++)
+	for (i = 0; i < ( *aasworld ).numvertexes; i++)
 	{
 		for (j = 0; j < 3; j++)
-			aasworld.vertexes[i][j] = LittleFloat(aasworld.vertexes[i][j]);
+			( *aasworld ).vertexes[i][j] = LittleFloat(( *aasworld ).vertexes[i][j]);
 	} //end for
 	//planes
-	for (i = 0; i < aasworld.numplanes; i++)
+	for (i = 0; i < ( *aasworld ).numplanes; i++)
 	{
 		for (j = 0; j < 3; j++)
-			aasworld.planes[i].normal[j] = LittleFloat(aasworld.planes[i].normal[j]);
-		aasworld.planes[i].dist = LittleFloat(aasworld.planes[i].dist);
-		aasworld.planes[i].type = LittleLong(aasworld.planes[i].type);
+			( *aasworld ).planes[i].normal[j] = LittleFloat(( *aasworld ).planes[i].normal[j]);
+		( *aasworld ).planes[i].dist = LittleFloat(( *aasworld ).planes[i].dist);
+		( *aasworld ).planes[i].type = LittleLong(( *aasworld ).planes[i].type);
 	} //end for
 	//edges
-	for (i = 0; i < aasworld.numedges; i++)
+	for (i = 0; i < ( *aasworld ).numedges; i++)
 	{
-		aasworld.edges[i].v[0] = LittleLong(aasworld.edges[i].v[0]);
-		aasworld.edges[i].v[1] = LittleLong(aasworld.edges[i].v[1]);
+		( *aasworld ).edges[i].v[0] = LittleLong(( *aasworld ).edges[i].v[0]);
+		( *aasworld ).edges[i].v[1] = LittleLong(( *aasworld ).edges[i].v[1]);
 	} //end for
 	//edgeindex
-	for (i = 0; i < aasworld.edgeindexsize; i++)
+	for (i = 0; i < ( *aasworld ).edgeindexsize; i++)
 	{
-		aasworld.edgeindex[i] = LittleLong(aasworld.edgeindex[i]);
+		( *aasworld ).edgeindex[i] = LittleLong(( *aasworld ).edgeindex[i]);
 	} //end for
 	//faces
-	for (i = 0; i < aasworld.numfaces; i++)
+	for (i = 0; i < ( *aasworld ).numfaces; i++)
 	{
-		aasworld.faces[i].planenum = LittleLong(aasworld.faces[i].planenum);
-		aasworld.faces[i].faceflags = LittleLong(aasworld.faces[i].faceflags);
-		aasworld.faces[i].numedges = LittleLong(aasworld.faces[i].numedges);
-		aasworld.faces[i].firstedge = LittleLong(aasworld.faces[i].firstedge);
-		aasworld.faces[i].frontarea = LittleLong(aasworld.faces[i].frontarea);
-		aasworld.faces[i].backarea = LittleLong(aasworld.faces[i].backarea);
+		( *aasworld ).faces[i].planenum = LittleLong(( *aasworld ).faces[i].planenum);
+		( *aasworld ).faces[i].faceflags = LittleLong(( *aasworld ).faces[i].faceflags);
+		( *aasworld ).faces[i].numedges = LittleLong(( *aasworld ).faces[i].numedges);
+		( *aasworld ).faces[i].firstedge = LittleLong(( *aasworld ).faces[i].firstedge);
+		( *aasworld ).faces[i].frontarea = LittleLong(( *aasworld ).faces[i].frontarea);
+		( *aasworld ).faces[i].backarea = LittleLong(( *aasworld ).faces[i].backarea);
 	} //end for
 	//face index
-	for (i = 0; i < aasworld.faceindexsize; i++)
+	for (i = 0; i < ( *aasworld ).faceindexsize; i++)
 	{
-		aasworld.faceindex[i] = LittleLong(aasworld.faceindex[i]);
+		( *aasworld ).faceindex[i] = LittleLong(( *aasworld ).faceindex[i]);
 	} //end for
 	//convex areas
-	for (i = 0; i < aasworld.numareas; i++)
+	for (i = 0; i < ( *aasworld ).numareas; i++)
 	{
-		aasworld.areas[i].areanum = LittleLong(aasworld.areas[i].areanum);
-		aasworld.areas[i].numfaces = LittleLong(aasworld.areas[i].numfaces);
-		aasworld.areas[i].firstface = LittleLong(aasworld.areas[i].firstface);
+		( *aasworld ).areas[i].areanum = LittleLong(( *aasworld ).areas[i].areanum);
+		( *aasworld ).areas[i].numfaces = LittleLong(( *aasworld ).areas[i].numfaces);
+		( *aasworld ).areas[i].firstface = LittleLong(( *aasworld ).areas[i].firstface);
 		for (j = 0; j < 3; j++)
 		{
-			aasworld.areas[i].mins[j] = LittleFloat(aasworld.areas[i].mins[j]);
-			aasworld.areas[i].maxs[j] = LittleFloat(aasworld.areas[i].maxs[j]);
-			aasworld.areas[i].center[j] = LittleFloat(aasworld.areas[i].center[j]);
+			( *aasworld ).areas[i].mins[j] = LittleFloat(( *aasworld ).areas[i].mins[j]);
+			( *aasworld ).areas[i].maxs[j] = LittleFloat(( *aasworld ).areas[i].maxs[j]);
+			( *aasworld ).areas[i].center[j] = LittleFloat(( *aasworld ).areas[i].center[j]);
 		} //end for
 	} //end for
 	//area settings
-	for (i = 0; i < aasworld.numareasettings; i++)
+	for (i = 0; i < ( *aasworld ).numareasettings; i++)
 	{
-		aasworld.areasettings[i].contents = LittleLong(aasworld.areasettings[i].contents);
-		aasworld.areasettings[i].areaflags = LittleLong(aasworld.areasettings[i].areaflags);
-		aasworld.areasettings[i].presencetype = LittleLong(aasworld.areasettings[i].presencetype);
-		aasworld.areasettings[i].cluster = LittleLong(aasworld.areasettings[i].cluster);
-		aasworld.areasettings[i].clusterareanum = LittleLong(aasworld.areasettings[i].clusterareanum);
-		aasworld.areasettings[i].numreachableareas = LittleLong(aasworld.areasettings[i].numreachableareas);
-		aasworld.areasettings[i].firstreachablearea = LittleLong(aasworld.areasettings[i].firstreachablearea);
+		( *aasworld ).areasettings[i].contents = LittleLong(( *aasworld ).areasettings[i].contents);
+		( *aasworld ).areasettings[i].areaflags = LittleLong(( *aasworld ).areasettings[i].areaflags);
+		( *aasworld ).areasettings[i].presencetype = LittleLong(( *aasworld ).areasettings[i].presencetype);
+		( *aasworld ).areasettings[i].cluster = LittleLong(( *aasworld ).areasettings[i].cluster);
+		( *aasworld ).areasettings[i].clusterareanum = LittleLong(( *aasworld ).areasettings[i].clusterareanum);
+		( *aasworld ).areasettings[i].numreachableareas = LittleLong(( *aasworld ).areasettings[i].numreachableareas);
+		( *aasworld ).areasettings[i].firstreachablearea = LittleLong(( *aasworld ).areasettings[i].firstreachablearea);
+		// Ridah
+		( *aasworld ).areasettings[i].groundsteepness = LittleFloat( ( *aasworld ).areasettings[i].groundsteepness );
 	} //end for
 	//area reachability
-	for (i = 0; i < aasworld.reachabilitysize; i++)
+	for (i = 0; i < ( *aasworld ).reachabilitysize; i++)
 	{
-		aasworld.reachability[i].areanum = LittleLong(aasworld.reachability[i].areanum);
-		aasworld.reachability[i].facenum = LittleLong(aasworld.reachability[i].facenum);
-		aasworld.reachability[i].edgenum = LittleLong(aasworld.reachability[i].edgenum);
+		( *aasworld ).reachability[i].areanum = LittleLong(( *aasworld ).reachability[i].areanum);
+		( *aasworld ).reachability[i].facenum = LittleLong(( *aasworld ).reachability[i].facenum);
+		( *aasworld ).reachability[i].edgenum = LittleLong(( *aasworld ).reachability[i].edgenum);
 		for (j = 0; j < 3; j++)
 		{
-			aasworld.reachability[i].start[j] = LittleFloat(aasworld.reachability[i].start[j]);
-			aasworld.reachability[i].end[j] = LittleFloat(aasworld.reachability[i].end[j]);
+			( *aasworld ).reachability[i].start[j] = LittleFloat(( *aasworld ).reachability[i].start[j]);
+			( *aasworld ).reachability[i].end[j] = LittleFloat(( *aasworld ).reachability[i].end[j]);
 		} //end for
-		aasworld.reachability[i].traveltype = LittleLong(aasworld.reachability[i].traveltype);
-		aasworld.reachability[i].traveltime = LittleShort(aasworld.reachability[i].traveltime);
+		( *aasworld ).reachability[i].traveltype = LittleLong(( *aasworld ).reachability[i].traveltype);
+		( *aasworld ).reachability[i].traveltime = LittleShort(( *aasworld ).reachability[i].traveltime);
 	} //end for
 	//nodes
-	for (i = 0; i < aasworld.numnodes; i++)
+	for (i = 0; i < ( *aasworld ).numnodes; i++)
 	{
-		aasworld.nodes[i].planenum = LittleLong(aasworld.nodes[i].planenum);
-		aasworld.nodes[i].children[0] = LittleLong(aasworld.nodes[i].children[0]);
-		aasworld.nodes[i].children[1] = LittleLong(aasworld.nodes[i].children[1]);
+		( *aasworld ).nodes[i].planenum = LittleLong(( *aasworld ).nodes[i].planenum);
+		( *aasworld ).nodes[i].children[0] = LittleLong(( *aasworld ).nodes[i].children[0]);
+		( *aasworld ).nodes[i].children[1] = LittleLong(( *aasworld ).nodes[i].children[1]);
 	} //end for
 	//cluster portals
-	for (i = 0; i < aasworld.numportals; i++)
+	for (i = 0; i < ( *aasworld ).numportals; i++)
 	{
-		aasworld.portals[i].areanum = LittleLong(aasworld.portals[i].areanum);
-		aasworld.portals[i].frontcluster = LittleLong(aasworld.portals[i].frontcluster);
-		aasworld.portals[i].backcluster = LittleLong(aasworld.portals[i].backcluster);
-		aasworld.portals[i].clusterareanum[0] = LittleLong(aasworld.portals[i].clusterareanum[0]);
-		aasworld.portals[i].clusterareanum[1] = LittleLong(aasworld.portals[i].clusterareanum[1]);
+		( *aasworld ).portals[i].areanum = LittleLong(( *aasworld ).portals[i].areanum);
+		( *aasworld ).portals[i].frontcluster = LittleLong(( *aasworld ).portals[i].frontcluster);
+		( *aasworld ).portals[i].backcluster = LittleLong(( *aasworld ).portals[i].backcluster);
+		( *aasworld ).portals[i].clusterareanum[0] = LittleLong(( *aasworld ).portals[i].clusterareanum[0]);
+		( *aasworld ).portals[i].clusterareanum[1] = LittleLong(( *aasworld ).portals[i].clusterareanum[1]);
 	} //end for
 	//cluster portal index
-	for (i = 0; i < aasworld.portalindexsize; i++)
+	for (i = 0; i < ( *aasworld ).portalindexsize; i++)
 	{
-		aasworld.portalindex[i] = LittleLong(aasworld.portalindex[i]);
+		( *aasworld ).portalindex[i] = LittleLong(( *aasworld ).portalindex[i]);
 	} //end for
 	//cluster
-	for (i = 0; i < aasworld.numclusters; i++)
+	for (i = 0; i < ( *aasworld ).numclusters; i++)
 	{
-		aasworld.clusters[i].numareas = LittleLong(aasworld.clusters[i].numareas);
-		aasworld.clusters[i].numportals = LittleLong(aasworld.clusters[i].numportals);
-		aasworld.clusters[i].firstportal = LittleLong(aasworld.clusters[i].firstportal);
+		( *aasworld ).clusters[i].numareas = LittleLong(( *aasworld ).clusters[i].numareas);
+		( *aasworld ).clusters[i].numportals = LittleLong(( *aasworld ).clusters[i].numportals);
+		( *aasworld ).clusters[i].firstportal = LittleLong(( *aasworld ).clusters[i].firstportal);
 	} //end for
 } //end of the function AAS_SwapAASData
 //===========================================================================
@@ -173,26 +175,26 @@
 void AAS_DumpAASData(void)
 {
 	/*
-	if (aasworld.vertexes) FreeMemory(aasworld.vertexes);
-	aasworld.vertexes = NULL;
-	if (aasworld.planes) FreeMemory(aasworld.planes);
-	aasworld.planes = NULL;
-	if (aasworld.edges) FreeMemory(aasworld.edges);
-	aasworld.edges = NULL;
-	if (aasworld.edgeindex) FreeMemory(aasworld.edgeindex);
-	aasworld.edgeindex = NULL;
-	if (aasworld.faces) FreeMemory(aasworld.faces);
-	aasworld.faces = NULL;
-	if (aasworld.faceindex) FreeMemory(aasworld.faceindex);
-	aasworld.faceindex = NULL;
-	if (aasworld.areas) FreeMemory(aasworld.areas);
-	aasworld.areas = NULL;
-	if (aasworld.areasettings) FreeMemory(aasworld.areasettings);
-	aasworld.areasettings = NULL;
-	if (aasworld.reachability) FreeMemory(aasworld.reachability);
-	aasworld.reachability = NULL;
+	if (( *aasworld ).vertexes) FreeMemory(( *aasworld ).vertexes);
+	( *aasworld ).vertexes = NULL;
+	if (( *aasworld ).planes) FreeMemory(( *aasworld ).planes);
+	( *aasworld ).planes = NULL;
+	if (( *aasworld ).edges) FreeMemory(( *aasworld ).edges);
+	( *aasworld ).edges = NULL;
+	if (( *aasworld ).edgeindex) FreeMemory(( *aasworld ).edgeindex);
+	( *aasworld ).edgeindex = NULL;
+	if (( *aasworld ).faces) FreeMemory(( *aasworld ).faces);
+	( *aasworld ).faces = NULL;
+	if (( *aasworld ).faceindex) FreeMemory(( *aasworld ).faceindex);
+	( *aasworld ).faceindex = NULL;
+	if (( *aasworld ).areas) FreeMemory(( *aasworld ).areas);
+	( *aasworld ).areas = NULL;
+	if (( *aasworld ).areasettings) FreeMemory(( *aasworld ).areasettings);
+	( *aasworld ).areasettings = NULL;
+	if (( *aasworld ).reachability) FreeMemory(( *aasworld ).reachability);
+	( *aasworld ).reachability = NULL;
 	*/
-	aasworld.loaded = false;
+	( *aasworld ).loaded = false;
 } //end of the function AAS_DumpAASData
 //===========================================================================
 // allocate memory and read a lump of a AAS file
@@ -283,7 +285,7 @@
 	} //end if
 	//check the version
 	header.version = LittleLong(header.version);
-	if (header.version != AASVERSION_OLD && header.version != AASVERSION)
+	if (header.version != AASVERSION)
 	{
 		AAS_Error("%s is version %i, not %i\n", filename, header.version, AASVERSION);
 		fclose(fp);
@@ -294,96 +296,96 @@
 	{
 		AAS_DData((unsigned char *) &header + 8, sizeof(aas_header_t) - 8);
 	} //end if
-	aasworld.bspchecksum = LittleLong(header.bspchecksum);
+	( *aasworld ).bspchecksum = LittleLong(header.bspchecksum);
 	//load the lumps:
 	//bounding boxes
 	offset = LittleLong(header.lumps[AASLUMP_BBOXES].fileofs);
 	length = LittleLong(header.lumps[AASLUMP_BBOXES].filelen);
-	aasworld.bboxes = (aas_bbox_t *) AAS_LoadAASLump(fp, offset, length, aasworld.bboxes);
-	if (length && !aasworld.bboxes) return false;
-	aasworld.numbboxes = length / sizeof(aas_bbox_t);
+	( *aasworld ).bboxes = (aas_bbox_t *) AAS_LoadAASLump(fp, offset, length, ( *aasworld ).bboxes);
+	if (length && !( *aasworld ).bboxes) return false;
+	( *aasworld ).numbboxes = length / sizeof(aas_bbox_t);
 	//vertexes
 	offset = LittleLong(header.lumps[AASLUMP_VERTEXES].fileofs);
 	length = LittleLong(header.lumps[AASLUMP_VERTEXES].filelen);
-	aasworld.vertexes = (aas_vertex_t *) AAS_LoadAASLump(fp, offset, length, aasworld.vertexes);
-	if (length & !aasworld.vertexes) return false;
-	aasworld.numvertexes = length / sizeof(aas_vertex_t);
+	( *aasworld ).vertexes = (aas_vertex_t *) AAS_LoadAASLump(fp, offset, length, ( *aasworld ).vertexes);
+	if (length & !( *aasworld ).vertexes) return false;
+	( *aasworld ).numvertexes = length / sizeof(aas_vertex_t);
 	//planes
 	offset = LittleLong(header.lumps[AASLUMP_PLANES].fileofs);
 	length = LittleLong(header.lumps[AASLUMP_PLANES].filelen);
-	aasworld.planes = (aas_plane_t *) AAS_LoadAASLump(fp, offset, length, aasworld.planes);
-	if (length && !aasworld.planes) return false;
-	aasworld.numplanes = length / sizeof(aas_plane_t);
+	( *aasworld ).planes = (aas_plane_t *) AAS_LoadAASLump(fp, offset, length, ( *aasworld ).planes);
+	if (length && !( *aasworld ).planes) return false;
+	( *aasworld ).numplanes = length / sizeof(aas_plane_t);
 	//edges
 	offset = LittleLong(header.lumps[AASLUMP_EDGES].fileofs);
 	length = LittleLong(header.lumps[AASLUMP_EDGES].filelen);
-	aasworld.edges = (aas_edge_t *) AAS_LoadAASLump(fp, offset, length, aasworld.edges);
-	if (length && !aasworld.edges) return false;
-	aasworld.numedges = length / sizeof(aas_edge_t);
+	( *aasworld ).edges = (aas_edge_t *) AAS_LoadAASLump(fp, offset, length, ( *aasworld ).edges);
+	if (length && !( *aasworld ).edges) return false;
+	( *aasworld ).numedges = length / sizeof(aas_edge_t);
 	//edgeindex
 	offset = LittleLong(header.lumps[AASLUMP_EDGEINDEX].fileofs);
 	length = LittleLong(header.lumps[AASLUMP_EDGEINDEX].filelen);
-	aasworld.edgeindex = (aas_edgeindex_t *) AAS_LoadAASLump(fp, offset, length, aasworld.edgeindex);
-	if (length && !aasworld.edgeindex) return false;
-	aasworld.edgeindexsize = length / sizeof(aas_edgeindex_t);
+	( *aasworld ).edgeindex = (aas_edgeindex_t *) AAS_LoadAASLump(fp, offset, length, ( *aasworld ).edgeindex);
+	if (length && !( *aasworld ).edgeindex) return false;
+	( *aasworld ).edgeindexsize = length / sizeof(aas_edgeindex_t);
 	//faces
 	offset = LittleLong(header.lumps[AASLUMP_FACES].fileofs);
 	length = LittleLong(header.lumps[AASLUMP_FACES].filelen);
-	aasworld.faces = (aas_face_t *) AAS_LoadAASLump(fp, offset, length, aasworld.faces);
-	if (length && !aasworld.faces) return false;
-	aasworld.numfaces = length / sizeof(aas_face_t);
+	( *aasworld ).faces = (aas_face_t *) AAS_LoadAASLump(fp, offset, length, ( *aasworld ).faces);
+	if (length && !( *aasworld ).faces) return false;
+	( *aasworld ).numfaces = length / sizeof(aas_face_t);
 	//faceindex
 	offset = LittleLong(header.lumps[AASLUMP_FACEINDEX].fileofs);
 	length = LittleLong(header.lumps[AASLUMP_FACEINDEX].filelen);
-	aasworld.faceindex = (aas_faceindex_t *) AAS_LoadAASLump(fp, offset, length, aasworld.faceindex);
-	if (length && !aasworld.faceindex) return false;
-	aasworld.faceindexsize = length / sizeof(int);
+	( *aasworld ).faceindex = (aas_faceindex_t *) AAS_LoadAASLump(fp, offset, length, ( *aasworld ).faceindex);
+	if (length && !( *aasworld ).faceindex) return false;
+	( *aasworld ).faceindexsize = length / sizeof(int);
 	//convex areas
 	offset = LittleLong(header.lumps[AASLUMP_AREAS].fileofs);
 	length = LittleLong(header.lumps[AASLUMP_AREAS].filelen);
-	aasworld.areas = (aas_area_t *) AAS_LoadAASLump(fp, offset, length, aasworld.areas);
-	if (length && !aasworld.areas) return false;
-	aasworld.numareas = length / sizeof(aas_area_t);
+	( *aasworld ).areas = (aas_area_t *) AAS_LoadAASLump(fp, offset, length, ( *aasworld ).areas);
+	if (length && !( *aasworld ).areas) return false;
+	( *aasworld ).numareas = length / sizeof(aas_area_t);
 	//area settings
 	offset = LittleLong(header.lumps[AASLUMP_AREASETTINGS].fileofs);
 	length = LittleLong(header.lumps[AASLUMP_AREASETTINGS].filelen);
-	aasworld.areasettings = (aas_areasettings_t *) AAS_LoadAASLump(fp, offset, length, aasworld.areasettings);
-	if (length && !aasworld.areasettings) return false;
-	aasworld.numareasettings = length / sizeof(aas_areasettings_t);
+	( *aasworld ).areasettings = (aas_areasettings_t *) AAS_LoadAASLump(fp, offset, length, ( *aasworld ).areasettings);
+	if (length && !( *aasworld ).areasettings) return false;
+	( *aasworld ).numareasettings = length / sizeof(aas_areasettings_t);
 	//reachability list
 	offset = LittleLong(header.lumps[AASLUMP_REACHABILITY].fileofs);
 	length = LittleLong(header.lumps[AASLUMP_REACHABILITY].filelen);
-	aasworld.reachability = (aas_reachability_t *) AAS_LoadAASLump(fp, offset, length, aasworld.reachability);
-	if (length && !aasworld.reachability) return false;
-	aasworld.reachabilitysize = length / sizeof(aas_reachability_t);
+	( *aasworld ).reachability = (aas_reachability_t *) AAS_LoadAASLump(fp, offset, length, ( *aasworld ).reachability);
+	if (length && !( *aasworld ).reachability) return false;
+	( *aasworld ).reachabilitysize = length / sizeof(aas_reachability_t);
 	//nodes
 	offset = LittleLong(header.lumps[AASLUMP_NODES].fileofs);
 	length = LittleLong(header.lumps[AASLUMP_NODES].filelen);
-	aasworld.nodes = (aas_node_t *) AAS_LoadAASLump(fp, offset, length, aasworld.nodes);
-	if (length && !aasworld.nodes) return false;
-	aasworld.numnodes = length / sizeof(aas_node_t);
+	( *aasworld ).nodes = (aas_node_t *) AAS_LoadAASLump(fp, offset, length, ( *aasworld ).nodes);
+	if (length && !( *aasworld ).nodes) return false;
+	( *aasworld ).numnodes = length / sizeof(aas_node_t);
 	//cluster portals
 	offset = LittleLong(header.lumps[AASLUMP_PORTALS].fileofs);
 	length = LittleLong(header.lumps[AASLUMP_PORTALS].filelen);
-	aasworld.portals = (aas_portal_t *) AAS_LoadAASLump(fp, offset, length, aasworld.portals);
-	if (length && !aasworld.portals) return false;
-	aasworld.numportals = length / sizeof(aas_portal_t);
+	( *aasworld ).portals = (aas_portal_t *) AAS_LoadAASLump(fp, offset, length, ( *aasworld ).portals);
+	if (length && !( *aasworld ).portals) return false;
+	( *aasworld ).numportals = length / sizeof(aas_portal_t);
 	//cluster portal index
 	offset = LittleLong(header.lumps[AASLUMP_PORTALINDEX].fileofs);
 	length = LittleLong(header.lumps[AASLUMP_PORTALINDEX].filelen);
-	aasworld.portalindex = (aas_portalindex_t *) AAS_LoadAASLump(fp, offset, length, aasworld.portalindex);
-	if (length && !aasworld.portalindex) return false;
-	aasworld.portalindexsize = length / sizeof(aas_portalindex_t);
+	( *aasworld ).portalindex = (aas_portalindex_t *) AAS_LoadAASLump(fp, offset, length, ( *aasworld ).portalindex);
+	if (length && !( *aasworld ).portalindex) return false;
+	( *aasworld ).portalindexsize = length / sizeof(aas_portalindex_t);
 	//clusters
 	offset = LittleLong(header.lumps[AASLUMP_CLUSTERS].fileofs);
 	length = LittleLong(header.lumps[AASLUMP_CLUSTERS].filelen);
-	aasworld.clusters = (aas_cluster_t *) AAS_LoadAASLump(fp, offset, length, aasworld.clusters);
-	if (length && !aasworld.clusters) return false;
-	aasworld.numclusters = length / sizeof(aas_cluster_t);
+	( *aasworld ).clusters = (aas_cluster_t *) AAS_LoadAASLump(fp, offset, length, ( *aasworld ).clusters);
+	if (length && !( *aasworld ).clusters) return false;
+	( *aasworld ).numclusters = length / sizeof(aas_cluster_t);
 	//swap everything
 	AAS_SwapAASData();
 	//aas file is loaded
-	aasworld.loaded = true;
+	( *aasworld ).loaded = true;
 	//close the file
 	fclose(fp);
 	return true;
@@ -425,9 +427,9 @@
 	int i, num;
 
 	num = 0;
-	for (i = 0; i < aasworld.reachabilitysize; i++)
+	for (i = 0; i < ( *aasworld ).reachabilitysize; i++)
 	{
-		if ((aasworld.reachability[i].traveltype & TRAVELTYPE_MASK) == tt)
+		if ((( *aasworld ).reachability[i].traveltype & TRAVELTYPE_MASK) == tt)
 			num++;
 	} //end for
 	Log_Print("%6d %s\n", num, name);
@@ -440,19 +442,19 @@
 //===========================================================================
 void AAS_ShowTotals(void)
 {
-	Log_Print("numvertexes = %d\r\n", aasworld.numvertexes);
-	Log_Print("numplanes = %d\r\n", aasworld.numplanes);
-	Log_Print("numedges = %d\r\n", aasworld.numedges);
-	Log_Print("edgeindexsize = %d\r\n", aasworld.edgeindexsize);
-	Log_Print("numfaces = %d\r\n", aasworld.numfaces);
-	Log_Print("faceindexsize = %d\r\n", aasworld.faceindexsize);
-	Log_Print("numareas = %d\r\n", aasworld.numareas);
-	Log_Print("numareasettings = %d\r\n", aasworld.numareasettings);
-	Log_Print("reachabilitysize = %d\r\n", aasworld.reachabilitysize);
-	Log_Print("numnodes = %d\r\n", aasworld.numnodes);
-	Log_Print("numportals = %d\r\n", aasworld.numportals);
-	Log_Print("portalindexsize = %d\r\n", aasworld.portalindexsize);
-	Log_Print("numclusters = %d\r\n", aasworld.numclusters);
+	Log_Print("numvertexes = %d\r\n", ( *aasworld ).numvertexes);
+	Log_Print("numplanes = %d\r\n", ( *aasworld ).numplanes);
+	Log_Print("numedges = %d\r\n", ( *aasworld ).numedges);
+	Log_Print("edgeindexsize = %d\r\n", ( *aasworld ).edgeindexsize);
+	Log_Print("numfaces = %d\r\n", ( *aasworld ).numfaces);
+	Log_Print("faceindexsize = %d\r\n", ( *aasworld ).faceindexsize);
+	Log_Print("numareas = %d\r\n", ( *aasworld ).numareas);
+	Log_Print("numareasettings = %d\r\n", ( *aasworld ).numareasettings);
+	Log_Print("reachabilitysize = %d\r\n", ( *aasworld ).reachabilitysize);
+	Log_Print("numnodes = %d\r\n", ( *aasworld ).numnodes);
+	Log_Print("numportals = %d\r\n", ( *aasworld ).numportals);
+	Log_Print("portalindexsize = %d\r\n", ( *aasworld ).portalindexsize);
+	Log_Print("numclusters = %d\r\n", ( *aasworld ).numclusters);
 
 	AAS_ShowNumReachabilities(TRAVEL_INVALID, "invalid");
 	AAS_ShowNumReachabilities(TRAVEL_WALK, "walk");
@@ -503,7 +505,7 @@
 	memset(&header, 0, sizeof(aas_header_t));
 	header.ident = LittleLong(AASID);
 	header.version = LittleLong(AASVERSION);
-	header.bspchecksum = LittleLong(aasworld.bspchecksum);
+	header.bspchecksum = LittleLong(( *aasworld ).bspchecksum);
 	//open a new file
 	fp = fopen(filename, "wb");
 	if (!fp)
@@ -518,34 +520,34 @@
 		return false;
 	} //end if
 	//add the data lumps to the file
-	if (!AAS_WriteAASLump(fp, &header, AASLUMP_BBOXES, aasworld.bboxes,
-		aasworld.numbboxes * sizeof(aas_bbox_t))) return false;
-	if (!AAS_WriteAASLump(fp, &header, AASLUMP_VERTEXES, aasworld.vertexes,
-		aasworld.numvertexes * sizeof(aas_vertex_t))) return false;
-	if (!AAS_WriteAASLump(fp, &header, AASLUMP_PLANES, aasworld.planes,
-		aasworld.numplanes * sizeof(aas_plane_t))) return false;
-	if (!AAS_WriteAASLump(fp, &header, AASLUMP_EDGES, aasworld.edges,
-		aasworld.numedges * sizeof(aas_edge_t))) return false;
-	if (!AAS_WriteAASLump(fp, &header, AASLUMP_EDGEINDEX, aasworld.edgeindex,
-		aasworld.edgeindexsize * sizeof(aas_edgeindex_t))) return false;
-	if (!AAS_WriteAASLump(fp, &header, AASLUMP_FACES, aasworld.faces,
-		aasworld.numfaces * sizeof(aas_face_t))) return false;
-	if (!AAS_WriteAASLump(fp, &header, AASLUMP_FACEINDEX, aasworld.faceindex,
-		aasworld.faceindexsize * sizeof(aas_faceindex_t))) return false;
-	if (!AAS_WriteAASLump(fp, &header, AASLUMP_AREAS, aasworld.areas,
-		aasworld.numareas * sizeof(aas_area_t))) return false;
-	if (!AAS_WriteAASLump(fp, &header, AASLUMP_AREASETTINGS, aasworld.areasettings,
-		aasworld.numareasettings * sizeof(aas_areasettings_t))) return false;
-	if (!AAS_WriteAASLump(fp, &header, AASLUMP_REACHABILITY, aasworld.reachability,
-		aasworld.reachabilitysize * sizeof(aas_reachability_t))) return false;
-	if (!AAS_WriteAASLump(fp, &header, AASLUMP_NODES, aasworld.nodes,
-		aasworld.numnodes * sizeof(aas_node_t))) return false;
-	if (!AAS_WriteAASLump(fp, &header, AASLUMP_PORTALS, aasworld.portals,
-		aasworld.numportals * sizeof(aas_portal_t))) return false;
-	if (!AAS_WriteAASLump(fp, &header, AASLUMP_PORTALINDEX, aasworld.portalindex,
-		aasworld.portalindexsize * sizeof(aas_portalindex_t))) return false;
-	if (!AAS_WriteAASLump(fp, &header, AASLUMP_CLUSTERS, aasworld.clusters,
-		aasworld.numclusters * sizeof(aas_cluster_t))) return false;
+	if (!AAS_WriteAASLump(fp, &header, AASLUMP_BBOXES, ( *aasworld ).bboxes,
+		( *aasworld ).numbboxes * sizeof(aas_bbox_t))) return false;
+	if (!AAS_WriteAASLump(fp, &header, AASLUMP_VERTEXES, ( *aasworld ).vertexes,
+		( *aasworld ).numvertexes * sizeof(aas_vertex_t))) return false;
+	if (!AAS_WriteAASLump(fp, &header, AASLUMP_PLANES, ( *aasworld ).planes,
+		( *aasworld ).numplanes * sizeof(aas_plane_t))) return false;
+	if (!AAS_WriteAASLump(fp, &header, AASLUMP_EDGES, ( *aasworld ).edges,
+		( *aasworld ).numedges * sizeof(aas_edge_t))) return false;
+	if (!AAS_WriteAASLump(fp, &header, AASLUMP_EDGEINDEX, ( *aasworld ).edgeindex,
+		( *aasworld ).edgeindexsize * sizeof(aas_edgeindex_t))) return false;
+	if (!AAS_WriteAASLump(fp, &header, AASLUMP_FACES, ( *aasworld ).faces,
+		( *aasworld ).numfaces * sizeof(aas_face_t))) return false;
+	if (!AAS_WriteAASLump(fp, &header, AASLUMP_FACEINDEX, ( *aasworld ).faceindex,
+		( *aasworld ).faceindexsize * sizeof(aas_faceindex_t))) return false;
+	if (!AAS_WriteAASLump(fp, &header, AASLUMP_AREAS, ( *aasworld ).areas,
+		( *aasworld ).numareas * sizeof(aas_area_t))) return false;
+	if (!AAS_WriteAASLump(fp, &header, AASLUMP_AREASETTINGS, ( *aasworld ).areasettings,
+		( *aasworld ).numareasettings * sizeof(aas_areasettings_t))) return false;
+	if (!AAS_WriteAASLump(fp, &header, AASLUMP_REACHABILITY, ( *aasworld ).reachability,
+		( *aasworld ).reachabilitysize * sizeof(aas_reachability_t))) return false;
+	if (!AAS_WriteAASLump(fp, &header, AASLUMP_NODES, ( *aasworld ).nodes,
+		( *aasworld ).numnodes * sizeof(aas_node_t))) return false;
+	if (!AAS_WriteAASLump(fp, &header, AASLUMP_PORTALS, ( *aasworld ).portals,
+		( *aasworld ).numportals * sizeof(aas_portal_t))) return false;
+	if (!AAS_WriteAASLump(fp, &header, AASLUMP_PORTALINDEX, ( *aasworld ).portalindex,
+		( *aasworld ).portalindexsize * sizeof(aas_portalindex_t))) return false;
+	if (!AAS_WriteAASLump(fp, &header, AASLUMP_CLUSTERS, ( *aasworld ).clusters,
+		( *aasworld ).numclusters * sizeof(aas_cluster_t))) return false;
 	//rewrite the header with the added lumps
 	fseek(fp, 0, SEEK_SET);
 	AAS_DData((unsigned char *) &header + 8, sizeof(aas_header_t) - 8);
Index: code/bspc/aas_map.c
===================================================================
--- code/bspc/aas_map.c	(revision 1306)
+++ code/bspc/aas_map.c	(working copy)
@@ -35,6 +35,14 @@
 #include "aas_cfg.h"
 #include "../qcommon/surfaceflags.h"
 
+#define DOOR_START_OPEN     1
+#define DOOR_REVERSE            2
+#define DOOR_CRUSHER            4
+#define DOOR_NOMONSTER      8
+#define DOOR_TOGGLE         32
+#define DOOR_X_AXIS         64
+#define DOOR_Y_AXIS         128
+
 #define BBOX_NORMAL_EPSILON			0.0001
 
 //===========================================================================
@@ -492,8 +500,39 @@
 	{
 		return true;
 	} //end if
-	if (!strcmp("trigger_hurt", ValueForKey(mapent, "classname")))
+	  //some of the func_wall brushes are also used for AAS
+	else if ( !strcmp( "func_wall", ValueForKey( mapent, "classname" ) ) )
 	{
+		//Log_Print("found func_wall entity %d\n", mapent - entities);
+		//if the func wall is used in deathmatch
+		//if (!(atoi(ValueForKey(mapent, "spawnflags")) & SPAWNFLAG_NOT_DEATHMATCH))
+		{
+			//Log_Print("func_wall USED in deathmatch mode %d\n", atoi(ValueForKey(mapent, "spawnflags")));
+			return true;
+		} //end if
+	} //end else if
+	else if ( !strcmp( "func_door_rotating", ValueForKey( mapent, "classname" ) ) ||
+			  !strcmp( "func_door", ValueForKey( mapent, "classname" ) ) ||
+			  !strcmp( "func_invisible_user", ValueForKey( mapent, "classname" ) ) )
+			  {
+		//if the func_door_rotating is present in deathmatch
+		//if (!(atoi(ValueForKey(mapent, "spawnflags")) & SPAWNFLAG_NOT_DEATHMATCH))
+		{
+			//if the func_door_rotating is always activated in deathmatch
+			if ( AAS_AlwaysTriggered( ValueForKey( mapent, "targetname" ) ) )
+			{
+				//Log_Print("found func_door_rotating in deathmatch\ntargetname %s\n", ValueForKey(mapent, "targetname"));
+				return true;
+			} //end if
+		} //end if
+	} //end else if
+	else if (!strcmp("trigger_hurt", ValueForKey(mapent, "classname")))
+	{
+		// RF, spawnflag & 1 is for delayed spawn, so ignore it
+		//if ( atoi( ValueForKey( mapent, "spawnflags" ) ) & 1 ) { // Tobias FIXME
+		//	return false;
+		//}
+
 		//"dmg" is the damage, for instance: "dmg" "666"
 		return true;
 	} //end else if
@@ -521,14 +560,18 @@
 	{
 		return true;
 	} //end else if
-	else if (!strcmp("func_static", ValueForKey(mapent, "classname")))
+	else if ( !strcmp( "func_tramcar", ValueForKey( mapent, "classname" ) ) )
 	{
-		//FIXME: easy/medium/hard/deathmatch specific?
 		return true;
 	} //end else if
-	else if (!strcmp("func_door", ValueForKey(mapent, "classname")))
+	else if ( !strcmp( "func_invisible_user", ValueForKey( mapent, "classname" ) ) )
 	{
 		return true;
+	}
+	else if (!strcmp("func_static", ValueForKey(mapent, "classname")))
+	{
+		//FIXME: easy/medium/hard/deathmatch specific?
+		return true;
 	} //end else if
 	//func_breakable for Turtle Arena
 	else if (!strcmp("func_breakable", ValueForKey(mapent, "classname")))
@@ -543,6 +586,78 @@
 // Returns:					-
 // Changes Globals:		-
 //===========================================================================
+int AAS_TransformPlane( int planenum, vec3_t origin, vec3_t angles )
+{
+	float newdist, matrix[3][3];
+	vec3_t normal;
+
+	//rotate the node plane
+	VectorCopy( mapplanes[planenum].normal, normal );
+	CreateRotationMatrix( angles, matrix );
+	RotatePoint( normal, matrix );
+	newdist = mapplanes[planenum].dist + DotProduct( normal, origin );
+	return FindFloatPlane( normal, newdist );
+} //end of the function AAS_TransformPlane
+//===========================================================================
+// this function sets the func_rotating_door in it's final position
+//
+// Parameter:				-
+// Returns:					-
+// Changes Globals:		-
+//===========================================================================
+void AAS_PositionFuncRotatingBrush( entity_t *mapent, mapbrush_t *brush )
+{
+	int spawnflags, i;
+	float distance;
+	vec3_t movedir, angles, pos1, pos2;
+	side_t *s;
+
+	spawnflags = FloatForKey( mapent, "spawnflags" );
+	VectorClear( movedir );
+	if ( spawnflags & DOOR_X_AXIS ) 
+		movedir[2] = 1.0;       //roll
+	else if ( spawnflags & DOOR_Y_AXIS )
+		movedir[0] = 1.0;       //pitch
+	else  // Z_AXIS
+		movedir[1] = 1.0;       //yaw
+
+	// check for reverse rotation
+	if ( spawnflags & DOOR_REVERSE )
+		VectorInverse( movedir );
+
+
+	distance = FloatForKey( mapent, "distance" );
+	if ( !distance ) distance = 90;
+
+	GetVectorForKey( mapent, "angles", angles );
+	VectorCopy( angles, pos1 );
+	VectorMA( angles, -distance, movedir, pos2 );
+	// if it starts open, switch the positions
+	if ( spawnflags & DOOR_START_OPEN )
+	{
+		VectorCopy( pos2, angles );
+		VectorCopy( pos1, pos2 );
+		VectorCopy( angles, pos1 );
+		VectorInverse( movedir );
+	} //end if
+	  //
+	for ( i = 0; i < brush->numsides; i++ )
+	{
+		s = &brush->original_sides[i];
+		s->planenum = AAS_TransformPlane( s->planenum, mapent->origin, pos2 );
+	} //end for
+	  //
+	FreeBrushWindings( brush );
+	AAS_MakeBrushWindings( brush );
+	AddBrushBevels( brush );
+	FreeBrushWindings( brush );
+} //end of the function AAS_PositionFuncRotatingBrush
+//===========================================================================
+//
+// Parameter:				-
+// Returns:					-
+// Changes Globals:		-
+//===========================================================================
 void AAS_PositionBrush(entity_t *mapent, mapbrush_t *brush)
 {
 	side_t *s;
@@ -550,6 +665,12 @@
 	int i, notteam;
 	char *model;
 
+	if ( !strcmp( ValueForKey( mapent, "classname" ), "func_door_rotating" ) )
+	{
+		AAS_PositionFuncRotatingBrush( mapent, brush );
+	} //end if
+	else
+	{
 	if (mapent->origin[0] || mapent->origin[1] || mapent->origin[2])
 	{
 		for (i = 0; i < brush->numsides; i++)
@@ -563,6 +684,11 @@
 	//if it's a trigger hurt
 	if (!strcmp("trigger_hurt", ValueForKey(mapent, "classname")))
 	{
+		// RF, spawnflag & 1 is for delayed spawn, so ignore it
+		//if ( atoi( ValueForKey( mapent, "spawnflags" ) ) & 1 ) {
+		//	return false;
+		//}
+
 		notteam = FloatForKey(mapent, "bot_notteam");
 		if ( notteam == 1 ) {
 			brush->contents |= CONTENTS_NOTTEAM1;
@@ -613,6 +739,12 @@
 		model = ValueForKey(mapent, "model");
 		brush->modelnum = atoi(model+1);
 	} //end if
+	else if ( !strcmp( "func_invisible_user", ValueForKey( mapent, "classname" ) ) ) {
+		//set mover contents
+		brush->contents = CONTENTS_TRIGGER;
+	} //end if
+
+	} //end else
 } //end of the function AAS_PositionBrush
 //===========================================================================
 // uses the global cfg_t cfg
Index: code/bspc/aas_store.c
===================================================================
--- code/bspc/aas_store.c	(revision 1306)
+++ code/bspc/aas_store.c	(working copy)
@@ -55,7 +55,10 @@
 #define EDGE_HASHING
 #define EDGE_HASH_SIZE			1024		//must be power of 2
 
-aas_t aasworld;
+// Ridah
+aas_t aasworlds[1];
+aas_t( *aasworld );
+// done.
 
 //vertex hash
 int *aas_vertexchain;						// the next vertex in a hash chain
@@ -155,60 +158,60 @@
 
 	AAS_InitMaxAAS();
 	//bounding boxes
-	aasworld.numbboxes = 0;
-	aasworld.bboxes = (aas_bbox_t *) GetClearedMemory(max_aas.max_bboxes * sizeof(aas_bbox_t));
+	( *aasworld ).numbboxes = 0;
+	( *aasworld ).bboxes = (aas_bbox_t *) GetClearedMemory(max_aas.max_bboxes * sizeof(aas_bbox_t));
 	allocatedaasmem += max_aas.max_bboxes * sizeof(aas_bbox_t);
 	//vertexes
-	aasworld.numvertexes = 0;
-	aasworld.vertexes = (aas_vertex_t *) GetClearedMemory(max_aas.max_vertexes * sizeof(aas_vertex_t));
+	( *aasworld ).numvertexes = 0;
+	( *aasworld ).vertexes = (aas_vertex_t *) GetClearedMemory(max_aas.max_vertexes * sizeof(aas_vertex_t));
 	allocatedaasmem += max_aas.max_vertexes * sizeof(aas_vertex_t);
 	//planes
-	aasworld.numplanes = 0;
-	aasworld.planes = (aas_plane_t *) GetClearedMemory(max_aas.max_planes * sizeof(aas_plane_t));
+	( *aasworld ).numplanes = 0;
+	( *aasworld ).planes = (aas_plane_t *) GetClearedMemory(max_aas.max_planes * sizeof(aas_plane_t));
 	allocatedaasmem += max_aas.max_planes * sizeof(aas_plane_t);
 	//edges
-	aasworld.numedges = 0;
-	aasworld.edges = (aas_edge_t *) GetClearedMemory(max_aas.max_edges * sizeof(aas_edge_t));
+	( *aasworld ).numedges = 0;
+	( *aasworld ).edges = (aas_edge_t *) GetClearedMemory(max_aas.max_edges * sizeof(aas_edge_t));
 	allocatedaasmem += max_aas.max_edges * sizeof(aas_edge_t);
 	//edge index
-	aasworld.edgeindexsize = 0;
-	aasworld.edgeindex = (aas_edgeindex_t *) GetClearedMemory(max_aas.max_edgeindexsize * sizeof(aas_edgeindex_t));
+	( *aasworld ).edgeindexsize = 0;
+	( *aasworld ).edgeindex = (aas_edgeindex_t *) GetClearedMemory(max_aas.max_edgeindexsize * sizeof(aas_edgeindex_t));
 	allocatedaasmem += max_aas.max_edgeindexsize * sizeof(aas_edgeindex_t);
 	//faces
-	aasworld.numfaces = 0;
-	aasworld.faces = (aas_face_t *) GetClearedMemory(max_aas.max_faces * sizeof(aas_face_t));
+	( *aasworld ).numfaces = 0;
+	( *aasworld ).faces = (aas_face_t *) GetClearedMemory(max_aas.max_faces * sizeof(aas_face_t));
 	allocatedaasmem += max_aas.max_faces * sizeof(aas_face_t);
 	//face index
-	aasworld.faceindexsize = 0;
-	aasworld.faceindex = (aas_faceindex_t *) GetClearedMemory(max_aas.max_faceindexsize * sizeof(aas_faceindex_t));
+	( *aasworld ).faceindexsize = 0;
+	( *aasworld ).faceindex = (aas_faceindex_t *) GetClearedMemory(max_aas.max_faceindexsize * sizeof(aas_faceindex_t));
 	allocatedaasmem += max_aas.max_faceindexsize * sizeof(aas_faceindex_t);
 	//convex areas
-	aasworld.numareas = 0;
-	aasworld.areas = (aas_area_t *) GetClearedMemory(max_aas.max_areas * sizeof(aas_area_t));
+	( *aasworld ).numareas = 0;
+	( *aasworld ).areas = (aas_area_t *) GetClearedMemory(max_aas.max_areas * sizeof(aas_area_t));
 	allocatedaasmem += max_aas.max_areas * sizeof(aas_area_t);
 	//convex area settings
-	aasworld.numareasettings = 0;
-	aasworld.areasettings = (aas_areasettings_t *) GetClearedMemory(max_aas.max_areasettings * sizeof(aas_areasettings_t));
+	( *aasworld ).numareasettings = 0;
+	( *aasworld ).areasettings = (aas_areasettings_t *) GetClearedMemory(max_aas.max_areasettings * sizeof(aas_areasettings_t));
 	allocatedaasmem += max_aas.max_areasettings * sizeof(aas_areasettings_t);
 	//reachablity list
-	aasworld.reachabilitysize = 0;
-	aasworld.reachability = (aas_reachability_t *) GetClearedMemory(max_aas.max_reachabilitysize * sizeof(aas_reachability_t));
+	( *aasworld ).reachabilitysize = 0;
+	( *aasworld ).reachability = (aas_reachability_t *) GetClearedMemory(max_aas.max_reachabilitysize * sizeof(aas_reachability_t));
 	allocatedaasmem += max_aas.max_reachabilitysize * sizeof(aas_reachability_t);
 	//nodes of the bsp tree
-	aasworld.numnodes = 0;
-	aasworld.nodes = (aas_node_t *) GetClearedMemory(max_aas.max_nodes * sizeof(aas_node_t));
+	( *aasworld ).numnodes = 0;
+	( *aasworld ).nodes = (aas_node_t *) GetClearedMemory(max_aas.max_nodes * sizeof(aas_node_t));
 	allocatedaasmem += max_aas.max_nodes * sizeof(aas_node_t);
 	//cluster portals
-	aasworld.numportals = 0;
-	aasworld.portals = (aas_portal_t *) GetClearedMemory(max_aas.max_portals * sizeof(aas_portal_t));
+	( *aasworld ).numportals = 0;
+	( *aasworld ).portals = (aas_portal_t *) GetClearedMemory(max_aas.max_portals * sizeof(aas_portal_t));
 	allocatedaasmem += max_aas.max_portals * sizeof(aas_portal_t);
 	//cluster portal index
-	aasworld.portalindexsize = 0;
-	aasworld.portalindex = (aas_portalindex_t *) GetClearedMemory(max_aas.max_portalindexsize * sizeof(aas_portalindex_t));
+	( *aasworld ).portalindexsize = 0;
+	( *aasworld ).portalindex = (aas_portalindex_t *) GetClearedMemory(max_aas.max_portalindexsize * sizeof(aas_portalindex_t));
 	allocatedaasmem += max_aas.max_portalindexsize * sizeof(aas_portalindex_t);
 	//cluster
-	aasworld.numclusters = 0;
-	aasworld.clusters = (aas_cluster_t *) GetClearedMemory(max_aas.max_clusters * sizeof(aas_cluster_t));
+	( *aasworld ).numclusters = 0;
+	( *aasworld ).clusters = (aas_cluster_t *) GetClearedMemory(max_aas.max_clusters * sizeof(aas_cluster_t));
 	allocatedaasmem += max_aas.max_clusters * sizeof(aas_cluster_t);
 	//
 	Log_Print("allocated ");
@@ -237,61 +240,61 @@
 void AAS_FreeMaxAAS(void)
 {
 	//bounding boxes
-	if (aasworld.bboxes) FreeMemory(aasworld.bboxes);
-	aasworld.bboxes = NULL;
-	aasworld.numbboxes = 0;
+	if (( *aasworld ).bboxes) FreeMemory(( *aasworld ).bboxes);
+	( *aasworld ).bboxes = NULL;
+	( *aasworld ).numbboxes = 0;
 	//vertexes
-	if (aasworld.vertexes) FreeMemory(aasworld.vertexes);
-	aasworld.vertexes = NULL;
-	aasworld.numvertexes = 0;
+	if (( *aasworld ).vertexes) FreeMemory(( *aasworld ).vertexes);
+	( *aasworld ).vertexes = NULL;
+	( *aasworld ).numvertexes = 0;
 	//planes
-	if (aasworld.planes) FreeMemory(aasworld.planes);
-	aasworld.planes = NULL;
-	aasworld.numplanes = 0;
+	if (( *aasworld ).planes) FreeMemory(( *aasworld ).planes);
+	( *aasworld ).planes = NULL;
+	( *aasworld ).numplanes = 0;
 	//edges
-	if (aasworld.edges) FreeMemory(aasworld.edges);
-	aasworld.edges = NULL;
-	aasworld.numedges = 0;
+	if (( *aasworld ).edges) FreeMemory(( *aasworld ).edges);
+	( *aasworld ).edges = NULL;
+	( *aasworld ).numedges = 0;
 	//edge index
-	if (aasworld.edgeindex) FreeMemory(aasworld.edgeindex);
-	aasworld.edgeindex = NULL;
-	aasworld.edgeindexsize = 0;
+	if (( *aasworld ).edgeindex) FreeMemory(( *aasworld ).edgeindex);
+	( *aasworld ).edgeindex = NULL;
+	( *aasworld ).edgeindexsize = 0;
 	//faces
-	if (aasworld.faces) FreeMemory(aasworld.faces);
-	aasworld.faces = NULL;
-	aasworld.numfaces = 0;
+	if (( *aasworld ).faces) FreeMemory(( *aasworld ).faces);
+	( *aasworld ).faces = NULL;
+	( *aasworld ).numfaces = 0;
 	//face index
-	if (aasworld.faceindex) FreeMemory(aasworld.faceindex);
-	aasworld.faceindex = NULL;
-	aasworld.faceindexsize = 0;
+	if (( *aasworld ).faceindex) FreeMemory(( *aasworld ).faceindex);
+	( *aasworld ).faceindex = NULL;
+	( *aasworld ).faceindexsize = 0;
 	//convex areas
-	if (aasworld.areas) FreeMemory(aasworld.areas);
-	aasworld.areas = NULL;
-	aasworld.numareas = 0;
+	if (( *aasworld ).areas) FreeMemory(( *aasworld ).areas);
+	( *aasworld ).areas = NULL;
+	( *aasworld ).numareas = 0;
 	//convex area settings
-	if (aasworld.areasettings) FreeMemory(aasworld.areasettings);
-	aasworld.areasettings = NULL;
-	aasworld.numareasettings = 0;
+	if (( *aasworld ).areasettings) FreeMemory(( *aasworld ).areasettings);
+	( *aasworld ).areasettings = NULL;
+	( *aasworld ).numareasettings = 0;
 	//reachablity list
-	if (aasworld.reachability) FreeMemory(aasworld.reachability);
-	aasworld.reachability = NULL;
-	aasworld.reachabilitysize = 0;
+	if (( *aasworld ).reachability) FreeMemory(( *aasworld ).reachability);
+	( *aasworld ).reachability = NULL;
+	( *aasworld ).reachabilitysize = 0;
 	//nodes of the bsp tree
-	if (aasworld.nodes) FreeMemory(aasworld.nodes);
-	aasworld.nodes = NULL;
-	aasworld.numnodes = 0;
+	if (( *aasworld ).nodes) FreeMemory(( *aasworld ).nodes);
+	( *aasworld ).nodes = NULL;
+	( *aasworld ).numnodes = 0;
 	//cluster portals
-	if (aasworld.portals) FreeMemory(aasworld.portals);
-	aasworld.portals = NULL;
-	aasworld.numportals = 0;
+	if (( *aasworld ).portals) FreeMemory(( *aasworld ).portals);
+	( *aasworld ).portals = NULL;
+	( *aasworld ).numportals = 0;
 	//cluster portal index
-	if (aasworld.portalindex) FreeMemory(aasworld.portalindex);
-	aasworld.portalindex = NULL;
-	aasworld.portalindexsize = 0;
+	if (( *aasworld ).portalindex) FreeMemory(( *aasworld ).portalindex);
+	( *aasworld ).portalindex = NULL;
+	( *aasworld ).portalindexsize = 0;
 	//clusters
-	if (aasworld.clusters) FreeMemory(aasworld.clusters);
-	aasworld.clusters = NULL;
-	aasworld.numclusters = 0;
+	if (( *aasworld ).clusters) FreeMemory(( *aasworld ).clusters);
+	( *aasworld ).clusters = NULL;
+	( *aasworld ).numclusters = 0;
 	
 	Log_Print("freed ");
 	PrintMemorySize(allocatedaasmem);
@@ -365,9 +368,9 @@
 
 	for (vn = aas_hashverts[h]; vn >= 0; vn = aas_vertexchain[vn])
 	{
-		if (fabs(aasworld.vertexes[vn][0] - vert[0]) < VERTEX_EPSILON
-				&& fabs(aasworld.vertexes[vn][1] - vert[1]) < VERTEX_EPSILON
-				&& fabs(aasworld.vertexes[vn][2] - vert[2]) < VERTEX_EPSILON)
+		if (fabs(( *aasworld ).vertexes[vn][0] - vert[0]) < VERTEX_EPSILON
+				&& fabs(( *aasworld ).vertexes[vn][1] - vert[1]) < VERTEX_EPSILON
+				&& fabs(( *aasworld ).vertexes[vn][2] - vert[2]) < VERTEX_EPSILON)
 		{
 			*vnum = vn;
 			return true;
@@ -376,15 +379,15 @@
 #else //VERTEX_HASHING
 	//check if the vertex is already stored
 	//stupid linear search
-	for (i = 0; i < aasworld.numvertexes; i++)
+	for (i = 0; i < ( *aasworld ).numvertexes; i++)
 	{
-		diff = vert[0] - aasworld.vertexes[i][0];
+		diff = vert[0] - ( *aasworld ).vertexes[i][0];
 		if (diff < VERTEX_EPSILON && diff > -VERTEX_EPSILON)
 		{
-			diff = vert[1] - aasworld.vertexes[i][1];
+			diff = vert[1] - ( *aasworld ).vertexes[i][1];
 			if (diff < VERTEX_EPSILON && diff > -VERTEX_EPSILON)
 			{
-				diff = vert[2] - aasworld.vertexes[i][2];
+				diff = vert[2] - ( *aasworld ).vertexes[i][2];
 				if (diff < VERTEX_EPSILON && diff > -VERTEX_EPSILON)
 				{
 					*vnum = i;
@@ -395,19 +398,19 @@
 	} //end for
 #endif //VERTEX_HASHING
 
-	if (aasworld.numvertexes >= max_aas.max_vertexes)
+	if (( *aasworld ).numvertexes >= max_aas.max_vertexes)
 	{
 		Error("AAS_MAX_VERTEXES = %d", max_aas.max_vertexes);
 	} //end if
-	VectorCopy(vert, aasworld.vertexes[aasworld.numvertexes]);
-	*vnum = aasworld.numvertexes;
+	VectorCopy(vert, ( *aasworld ).vertexes[( *aasworld ).numvertexes]);
+	*vnum = ( *aasworld ).numvertexes;
 
 #ifdef VERTEX_HASHING
-	aas_vertexchain[aasworld.numvertexes] = aas_hashverts[h];
-	aas_hashverts[h] = aasworld.numvertexes;
+	aas_vertexchain[( *aasworld ).numvertexes] = aas_hashverts[h];
+	aas_hashverts[h] = ( *aasworld ).numvertexes;
 #endif //VERTEX_HASHING
 
-	aasworld.numvertexes++;
+	( *aasworld ).numvertexes++;
 	return false;
 } //end of the function AAS_GetVertex
 //===========================================================================
@@ -443,7 +446,7 @@
 	int hash;
 	aas_edge_t *edge;
 
-	edge = &aasworld.edges[edgenum];
+	edge = &( *aasworld ).edges[edgenum];
 
 	hash = AAS_HashEdge(edge->v[0], edge->v[1]);
 
@@ -464,7 +467,7 @@
 	hash = AAS_HashEdge(v1num, v2num);
 	for (e = aas_hashedges[hash]; e >= 0; e = aas_edgechain[e])
 	{
-		edge = &aasworld.edges[e];
+		edge = &( *aasworld ).edges[e];
 		if (edge->v[0] == v1num)
 		{
 			if (edge->v[1] == v2num)
@@ -501,7 +504,7 @@
 	qboolean found;
 
 	//the first edge is a dummy
-	if (aasworld.numedges == 0) aasworld.numedges = 1;
+	if (( *aasworld ).numedges == 0) ( *aasworld ).numedges = 1;
 
 	found = AAS_GetVertex(v1, &v1num);
 	found &= AAS_GetVertex(v2, &v2num);
@@ -524,19 +527,19 @@
 		if (AAS_FindHashedEdge(v1num, v2num, edgenum)) return true;
 #else
 		int i;
-		for (i = 1; i < aasworld.numedges; i++)
+		for (i = 1; i < ( *aasworld ).numedges; i++)
 		{
-			if (aasworld.edges[i].v[0] == v1num)
+			if (( *aasworld ).edges[i].v[0] == v1num)
 			{
-				if (aasworld.edges[i].v[1] == v2num)
+				if (( *aasworld ).edges[i].v[1] == v2num)
 				{
 					*edgenum = i;
 					return true;
 				} //end if
 			} //end if
-			else if (aasworld.edges[i].v[1] == v1num)
+			else if (( *aasworld ).edges[i].v[1] == v1num)
 			{
-				if (aasworld.edges[i].v[0] == v2num)
+				if (( *aasworld ).edges[i].v[0] == v2num)
 				{
 					//negative for a reversed edge
 					*edgenum = -i;
@@ -546,17 +549,17 @@
 		} //end for
 #endif //EDGE_HASHING
 	} //end if
-	if (aasworld.numedges >= max_aas.max_edges)
+	if (( *aasworld ).numedges >= max_aas.max_edges)
 	{
 		Error("AAS_MAX_EDGES = %d", max_aas.max_edges);
 	} //end if
-	aasworld.edges[aasworld.numedges].v[0] = v1num;
-	aasworld.edges[aasworld.numedges].v[1] = v2num;
-	*edgenum = aasworld.numedges;
+	( *aasworld ).edges[( *aasworld ).numedges].v[0] = v1num;
+	( *aasworld ).edges[( *aasworld ).numedges].v[1] = v2num;
+	*edgenum = ( *aasworld ).numedges;
 #ifdef EDGE_HASHING
 	AAS_AddEdgeToHash(*edgenum);
 #endif //EDGE_HASHING
-	aasworld.numedges++;
+	( *aasworld ).numedges++;
 	return false;
 } //end of the function AAS_GetEdge
 //===========================================================================
@@ -596,7 +599,7 @@
 	int hash;
 	aas_plane_t *plane;
 
-	plane = &aasworld.planes[planenum];
+	plane = &( *aasworld ).planes[planenum];
 
 	hash = (int)fabs(plane->dist) / 8;
 	hash &= (PLANE_HASH_SIZE-1);
@@ -614,16 +617,16 @@
 {
 	float diff;
 
-	diff = dist - aasworld.planes[planenum].dist;
+	diff = dist - ( *aasworld ).planes[planenum].dist;
 	if (diff > -DIST_EPSILON && diff < DIST_EPSILON)
 	{
-		diff = normal[0] - aasworld.planes[planenum].normal[0];
+		diff = normal[0] - ( *aasworld ).planes[planenum].normal[0];
 		if (diff > -NORMAL_EPSILON && diff < NORMAL_EPSILON)
 		{
-			diff = normal[1] - aasworld.planes[planenum].normal[1];
+			diff = normal[1] - ( *aasworld ).planes[planenum].normal[1];
 			if (diff > -NORMAL_EPSILON && diff < NORMAL_EPSILON)
 			{
-				diff = normal[2] - aasworld.planes[planenum].normal[2];
+				diff = normal[2] - ( *aasworld ).planes[planenum].normal[2];
 				if (diff > -NORMAL_EPSILON && diff < NORMAL_EPSILON)
 				{
 					return true;
@@ -643,7 +646,7 @@
 {
 	int i;
 
-	for (i = 0; i < aasworld.numplanes; i++)
+	for (i = 0; i < ( *aasworld ).numplanes; i++)
 	{
 		if (AAS_PlaneEqual(normal, dist, i))
 		{
@@ -674,7 +677,7 @@
 		h = (hash+i)&(PLANE_HASH_SIZE-1);
 		for (p = aas_hashplanes[h]; p >= 0; p = aas_planechain[p])
 		{
-			//plane = &aasworld.planes[p];
+			//plane = &( *aasworld ).planes[p];
 			if (AAS_PlaneEqual(normal, dist, p))
 			{
 				*planenum = p;
@@ -697,13 +700,13 @@
 	//if (AAS_FindPlane(normal, dist, planenum)) return true;
 	if (AAS_FindHashedPlane(normal, dist, planenum)) return true;
 
-	if (aasworld.numplanes >= max_aas.max_planes-1)
+	if (( *aasworld ).numplanes >= max_aas.max_planes-1)
 	{
 		Error("AAS_MAX_PLANES = %d", max_aas.max_planes);
 	} //end if
 
 #ifdef STOREPLANESDOUBLE
-	plane = &aasworld.planes[aasworld.numplanes];
+	plane = &( *aasworld ).planes[( *aasworld ).numplanes];
 	VectorCopy(normal, plane->normal);
 	plane->dist = dist;
 	plane->type = (plane+1)->type = PlaneTypeForNormal(plane->normal);
@@ -712,7 +715,7 @@
 	VectorNegate((plane+1)->normal, (plane+1)->normal);
 	(plane+1)->dist = -dist;
 
-	aasworld.numplanes += 2;
+	( *aasworld ).numplanes += 2;
 
 	//allways put axial planes facing positive first
 	if (plane->type < 3)
@@ -723,25 +726,25 @@
 			temp = *plane;
 			*plane = *(plane+1);
 			*(plane+1) = temp;
-			*planenum = aasworld.numplanes - 1;
+			*planenum = ( *aasworld ).numplanes - 1;
 			return false;
 		} //end if
 	} //end if
-	*planenum = aasworld.numplanes - 2;
+	*planenum = ( *aasworld ).numplanes - 2;
 	//add the planes to the hash
-	AAS_AddPlaneToHash(aasworld.numplanes - 1);
-	AAS_AddPlaneToHash(aasworld.numplanes - 2);
+	AAS_AddPlaneToHash(( *aasworld ).numplanes - 1);
+	AAS_AddPlaneToHash(( *aasworld ).numplanes - 2);
 	return false;
 #else
-	plane = &aasworld.planes[aasworld.numplanes];
+	plane = &( *aasworld ).planes[( *aasworld ).numplanes];
 	VectorCopy(normal, plane->normal);
 	plane->dist = dist;
 	plane->type = AAS_PlaneTypeForNormal(normal);
 
-	*planenum = aasworld.numplanes;
-	aasworld.numplanes++;
+	*planenum = ( *aasworld ).numplanes;
+	( *aasworld ).numplanes++;
 	//add the plane to the hash
-	AAS_AddPlaneToHash(aasworld.numplanes - 1);
+	AAS_AddPlaneToHash(( *aasworld ).numplanes - 1);
 	return false;
 #endif //STOREPLANESDOUBLE
 } //end of the function AAS_GetPlane
@@ -757,22 +760,22 @@
 	aas_face_t *face;
 
 	//face zero is a dummy, because of the face index with negative numbers
-	if (aasworld.numfaces == 0) aasworld.numfaces = 1;
+	if (( *aasworld ).numfaces == 0) ( *aasworld ).numfaces = 1;
 
-	if (aasworld.numfaces >= max_aas.max_faces)
+	if (( *aasworld ).numfaces >= max_aas.max_faces)
 	{
 		Error("AAS_MAX_FACES = %d", max_aas.max_faces);
 	} //end if
-	face = &aasworld.faces[aasworld.numfaces];
+	face = &( *aasworld ).faces[( *aasworld ).numfaces];
 	AAS_GetPlane(p->normal, p->dist, &face->planenum);
 	face->faceflags = 0;
-	face->firstedge = aasworld.edgeindexsize;
+	face->firstedge = ( *aasworld ).edgeindexsize;
 	face->frontarea = 0;
 	face->backarea = 0;
 	face->numedges = 0;
 	for (i = 0; i < w->numpoints; i++)
 	{
-		if (aasworld.edgeindexsize >= max_aas.max_edgeindexsize)
+		if (( *aasworld ).edgeindexsize >= max_aas.max_edgeindexsize)
 		{
 			Error("AAS_MAX_EDGEINDEXSIZE = %d", max_aas.max_edgeindexsize);
 		} //end if
@@ -781,13 +784,13 @@
 		//if the edge wasn't degenerate
 		if (edgenum)
 		{
-			aasworld.edgeindex[aasworld.edgeindexsize++] = edgenum;
+			( *aasworld ).edgeindex[( *aasworld ).edgeindexsize++] = edgenum;
 			face->numedges++;
 		} //end if
 		else if (verbose)
 		{
 			Log_Write("AAS_GetFace: face %d had degenerate edge %d-%d\r\n",
-														aasworld.numfaces, i, j);
+														( *aasworld ).numfaces, i, j);
 		} //end else
 	} //end for
 	if (face->numedges < 1
@@ -796,12 +799,12 @@
 #endif //NOTHREEVERTEXFACES
 		)
 	{
-		memset(&aasworld.faces[aasworld.numfaces], 0, sizeof(aas_face_t));
-		Log_Write("AAS_GetFace: face %d was tiny\r\n", aasworld.numfaces);
+		memset(&( *aasworld ).faces[( *aasworld ).numfaces], 0, sizeof(aas_face_t));
+		Log_Write("AAS_GetFace: face %d was tiny\r\n", ( *aasworld ).numfaces);
 		return false;
 	} //end if
-	*facenum = aasworld.numfaces;
-	aasworld.numfaces++;
+	*facenum = ( *aasworld ).numfaces;
+	( *aasworld ).numfaces++;
 	return true;
 } //end of the function AAS_GetFace
 //===========================================================================
@@ -820,7 +823,7 @@
 	aas_face_t *face;
 
 	//face zero is a dummy, because of the face index with negative numbers
-	if (aasworld.numfaces == 0) aasworld.numfaces = 1;
+	if (( *aasworld ).numfaces == 0) ( *aasworld ).numfaces = 1;
 
 	foundplane = AAS_GetPlane(p->normal, p->dist, &planenum);
 
@@ -836,9 +839,9 @@
 	//if the plane and all edges already existed
 	if (foundplane && foundedges)
 	{
-		for (i = 0; i < aasworld.numfaces; i++)
+		for (i = 0; i < ( *aasworld ).numfaces; i++)
 		{
-			face = &aasworld.faces[i];
+			face = &( *aasworld ).faces[i];
 			if (planenum == face->planenum)
 			{
 				if (numedges == face->numedges)
@@ -845,7 +848,7 @@
 				{
 					for (j = 0; j < numedges; j++)
 					{
-						edgenum = abs(aasworld.edgeindex[face->firstedge + j]);
+						edgenum = abs(( *aasworld ).edgeindex[face->firstedge + j]);
 						if (abs(edges[i]) != edgenum) break;
 					} //end for
 					if (j == numedges)
@@ -858,27 +861,27 @@
 			} //end if
 		} //end for
 	} //end if
-	if (aasworld.numfaces >= max_aas.max_faces)
+	if (( *aasworld ).numfaces >= max_aas.max_faces)
 	{
 		Error("AAS_MAX_FACES = %d", max_aas.max_faces);
 	} //end if
-	face = &aasworld.faces[aasworld.numfaces];
+	face = &( *aasworld ).faces[( *aasworld ).numfaces];
 	face->planenum = planenum;
 	face->faceflags = 0;
 	face->numedges = numedges;
-	face->firstedge = aasworld.edgeindexsize;
+	face->firstedge = ( *aasworld ).edgeindexsize;
 	face->frontarea = 0;
 	face->backarea = 0;
 	for (i = 0; i < numedges; i++)
 	{
-		if (aasworld.edgeindexsize >= max_aas.max_edgeindexsize)
+		if (( *aasworld ).edgeindexsize >= max_aas.max_edgeindexsize)
 		{
 			Error("AAS_MAX_EDGEINDEXSIZE = %d", max_aas.max_edgeindexsize);
 		} //end if
-		aasworld.edgeindex[aasworld.edgeindexsize++] = edges[i];
+		( *aasworld ).edgeindex[( *aasworld ).edgeindexsize++] = edges[i];
 	} //end for
-	*facenum = aasworld.numfaces;
-	aasworld.numfaces++;
+	*facenum = ( *aasworld ).numfaces;
+	( *aasworld ).numfaces++;
 	return false;
 } //end of the function AAS_GetFace*/
 //===========================================================================
@@ -891,11 +894,12 @@
 {
 	aas_areasettings_t *areasettings;
 
-	if (aasworld.numareasettings == 0) aasworld.numareasettings = 1;
-	areasettings = &aasworld.areasettings[aasworld.numareasettings++];
+	if (( *aasworld ).numareasettings == 0) ( *aasworld ).numareasettings = 1;
+	areasettings = &( *aasworld ).areasettings[( *aasworld ).numareasettings++];
 	areasettings->areaflags = tmpareasettings->areaflags;
 	areasettings->presencetype = tmpareasettings->presencetype;
 	areasettings->contents = tmpareasettings->contents;
+	areasettings->groundsteepness = tmpareasettings->groundsteepness;   // Ridah
 	if (tmpareasettings->modelnum > AREACONTENTS_MAXMODELNUM)
 		Log_Print("WARNING: more than %d mover models\n", AREACONTENTS_MAXMODELNUM);
 	areasettings->contents |= (tmpareasettings->modelnum & AREACONTENTS_MAXMODELNUM) << AREACONTENTS_MODELNUMSHIFT;
@@ -916,7 +920,7 @@
 	aas_face_t *aasface;
 	aas_faceindex_t aasfacenum;
 	vec3_t facecenter;
-	winding_t *w;
+	winding_t *w = NULL; // TTimo: init
 
 	//when the area is merged go to the merged area
 	//FIXME: this isn't necessary anymore because the tree
@@ -927,17 +931,17 @@
 	//if there is an aas area already stored for this tmp area
 	if (tmparea->aasareanum) return -tmparea->aasareanum;
 	//
-	if (aasworld.numareas >= max_aas.max_areas)
+	if (( *aasworld ).numareas >= max_aas.max_areas)
 	{
 		Error("AAS_MAX_AREAS = %d", max_aas.max_areas);
 	} //end if
 	//area zero is a dummy
-	if (aasworld.numareas == 0) aasworld.numareas = 1;
+	if (( *aasworld ).numareas == 0) ( *aasworld ).numareas = 1;
 	//create an area from this leaf
-	aasarea = &aasworld.areas[aasworld.numareas];
-	aasarea->areanum = aasworld.numareas;
+	aasarea = &( *aasworld ).areas[( *aasworld ).numareas];
+	aasarea->areanum = ( *aasworld ).numareas;
 	aasarea->numfaces = 0;
-	aasarea->firstface = aasworld.faceindexsize;
+	aasarea->firstface = ( *aasworld ).faceindexsize;
 	ClearBounds(aasarea->mins, aasarea->maxs);
 	VectorClear(aasarea->center);
 	//
@@ -959,7 +963,7 @@
 				Error("AAS_CreateTree_r: face number out of range");
 			} //end if
 #endif //DEBUG
-			aasface = &aasworld.faces[tmpface->aasfacenum];
+			aasface = &( *aasworld ).faces[tmpface->aasfacenum];
 			aasface->backarea = aasarea->areanum;
 		} //end if
 		else
@@ -976,7 +980,7 @@
 				FreeWinding(tmpface->winding);
 				tmpface->winding = w;
 			} //end if
-			aasface = &aasworld.faces[aasfacenum];
+			aasface = &( *aasworld ).faces[aasfacenum];
 			aasface->frontarea = aasarea->areanum;
 			aasface->backarea = 0;
 			aasface->faceflags = tmpface->faceflags;
@@ -988,11 +992,11 @@
 		VectorClear(facecenter);
 		for (edgenum = 0; edgenum < aasface->numedges; edgenum++)
 		{
-			edge = &aasworld.edges[abs(aasworld.edgeindex[aasface->firstedge + edgenum])];
+			edge = &( *aasworld ).edges[abs(( *aasworld ).edgeindex[aasface->firstedge + edgenum])];
 			for (i = 0; i < 2; i++)
 			{
-				AddPointToBounds(aasworld.vertexes[edge->v[i]], aasarea->mins, aasarea->maxs);
-				VectorAdd(aasworld.vertexes[edge->v[i]], facecenter, facecenter);
+				AddPointToBounds(( *aasworld ).vertexes[edge->v[i]], aasarea->mins, aasarea->maxs);
+				VectorAdd(( *aasworld ).vertexes[edge->v[i]], facecenter, facecenter);
 			} //end for
 		} //end for
 		VectorScale(facecenter, 1.0 / (aasface->numedges * 2.0), facecenter);
@@ -999,11 +1003,11 @@
 		//add the face 'center' to the area 'center'
 		VectorAdd(aasarea->center, facecenter, aasarea->center);
 		//
-		if (aasworld.faceindexsize >= max_aas.max_faceindexsize)
+		if (( *aasworld ).faceindexsize >= max_aas.max_faceindexsize)
 		{
 			Error("AAS_MAX_FACEINDEXSIZE = %d", max_aas.max_faceindexsize);
 		} //end if
-		aasworld.faceindex[aasworld.faceindexsize++] = aasfacenum;
+		( *aasworld ).faceindex[( *aasworld ).faceindexsize++] = aasfacenum;
 		aasarea->numfaces++;
 	} //end for
 	//if the area has no faces at all (return 0, = solid leaf)
@@ -1010,7 +1014,7 @@
 	if (!aasarea->numfaces) return 0;
 	//
 	VectorScale(aasarea->center, 1.0 / aasarea->numfaces, aasarea->center);
-	//Log_Write("area %d center %f %f %f\r\n", aasworld.numareas,
+	//Log_Write("area %d center %f %f %f\r\n", ( *aasworld ).numareas,
 	//				aasarea->center[0], aasarea->center[1], aasarea->center[2]);
 	//store the area settings
 	AAS_StoreAreaSettings(tmparea->settings);
@@ -1018,8 +1022,8 @@
 	//Log_Write("tmp area %d became aas area %d\r\n", tmpareanum, aasarea->areanum);
 	qprintf("\r%6d", aasarea->areanum);
 	//
-	aasworld.numareas++;
-	return -(aasworld.numareas - 1);
+	( *aasworld ).numareas++;
+	return -(( *aasworld ).numareas - 1);
 } //end of the function AAS_StoreArea
 //===========================================================================
 //
@@ -1039,13 +1043,13 @@
 	if (tmpnode->tmparea) return AAS_StoreArea(tmpnode->tmparea);
 	//it's another node
 	//the first node is a dummy
-	if (aasworld.numnodes == 0) aasworld.numnodes = 1;
-	if (aasworld.numnodes >= max_aas.max_nodes)
+	if (( *aasworld ).numnodes == 0) ( *aasworld ).numnodes = 1;
+	if (( *aasworld ).numnodes >= max_aas.max_nodes)
 	{
 		Error("AAS_MAX_NODES = %d", max_aas.max_nodes);
 	} //end if
-	aasnodenum = aasworld.numnodes;
-	aasnode = &aasworld.nodes[aasworld.numnodes++];
+	aasnodenum = ( *aasworld ).numnodes;
+	aasnode = &( *aasworld ).nodes[( *aasworld ).numnodes++];
 	plane = &mapplanes[tmpnode->planenum];
 	AAS_GetPlane(plane->normal, plane->dist, &aasnode->planenum);
 	aasnode->children[0] = AAS_StoreTree_r(tmpnode->children[0]);
@@ -1064,8 +1068,8 @@
 	{
 		Error("more than %d bounding boxes", max_aas.max_bboxes);
 	} //end if
-	aasworld.numbboxes = cfg.numbboxes;
-	memcpy(aasworld.bboxes, cfg.bboxes, cfg.numbboxes * sizeof(aas_bbox_t));
+	( *aasworld ).numbboxes = cfg.numbboxes;
+	memcpy(( *aasworld ).bboxes, cfg.bboxes, cfg.numbboxes * sizeof(aas_bbox_t));
 } //end of the function AAS_StoreBoundingBoxes
 //===========================================================================
 //
@@ -1085,6 +1089,6 @@
 	//start with node 1 because node zero is a dummy
 	AAS_StoreTree_r(tmpaasworld.nodes);
 	qprintf("\n");
-	Log_Write("%6d areas stored\r\n", aasworld.numareas);
-	aasworld.loaded = true;
+	Log_Write("%6d areas stored\r\n", ( *aasworld ).numareas);
+	( *aasworld ).loaded = true;
 } //end of the function AAS_StoreFile
Index: code/bspc/aas_store.h
===================================================================
--- code/bspc/aas_store.h	(revision 1306)
+++ code/bspc/aas_store.h	(working copy)
@@ -103,7 +103,10 @@
 extern bspc_aas_t aasworld;
 //*/
 
-extern aas_t aasworld;
+// Ridah
+extern aas_t aasworlds[1];
+extern aas_t *aasworld;
+// done.
 
 //stores the AAS file from the temporary AAS
 void AAS_StoreFile(char *filename);
Index: code/bspc/be_aas_bspc.c
===================================================================
--- code/bspc/be_aas_bspc.c	(revision 1306)
+++ code/bspc/be_aas_bspc.c	(working copy)
@@ -246,7 +246,7 @@
 	//
 	if (!qf->pakfile[0]) strcpy(qf->pakfile, qf->filename);
 	//load the map
-	CM_LoadMap((char *) qf, qfalse, &aasworld.bspchecksum);
+	CM_LoadMap((char *) qf, qfalse, &( *aasworld ).bspchecksum);
 	//get a handle to the world model
 	worldmodel = CM_InlineModel(0);		// 0 = world, 1 + are bmodels
 	//initialize bot import structure
@@ -260,8 +260,8 @@
 	//initialize the AAS linked entities for the new map
 	AAS_InitAASLinkedEntities();
 	//reset all reachabilities and clusters
-	aasworld.reachabilitysize = 0;
-	aasworld.numclusters = 0;
+	( *aasworld ).reachabilitysize = 0;
+	( *aasworld ).numclusters = 0;
 	//set all view portals as cluster portals in case we re-calculate the reachabilities and clusters (with -reach)
 	AAS_SetViewPortalsAsClusterPortals();
 	//calculate reachabilities
@@ -271,6 +271,12 @@
 	//calculate clusters
 	AAS_InitClustering();
 } //end of the function AAS_CalcReachAndClusters
+
+// Ridah
+void AAS_SetWorldPointer( aas_t *newaasworld ) {
+	aasworld = newaasworld;
+}
+// done.
 //===========================================================================
 //
 // Parameter:				-
@@ -279,7 +285,7 @@
 //===========================================================================
 void AAS_RecalcClusters(void)
 {
-	aasworld.numclusters = 0;
+	( *aasworld ).numclusters = 0;
 	AAS_InitBotImport();
 	AAS_InitClustering();
 } //end of the function AAS_RecalcClusters
Index: code/bspc/be_aas_bspc.h
===================================================================
--- code/bspc/be_aas_bspc.h	(revision 1306)
+++ code/bspc/be_aas_bspc.h	(working copy)
@@ -30,4 +30,7 @@
 
 void AAS_RecalcClusters( void );
 void AAS_CalcReachAndClusters(struct quakefile_s *qf);
+void AAS_InitBotImport(void);
+// Ridah
+void AAS_SetWorldPointer( aas_t *newaasworld );
 void AAS_InitBotImport( void );
Index: code/bspc/bspc.c
===================================================================
--- code/bspc/bspc.c	(revision 1306)
+++ code/bspc/bspc.c	(working copy)
@@ -80,8 +80,10 @@
 qboolean	cancelconversion;	//true if the conversion is being cancelled
 qboolean	noliquids;			//no liquids when writing map file
 qboolean	forcesidesvisible;	//force all brush sides to be visible when loaded from bsp
+qboolean	writeaasmap;
 qboolean	capsule_collision = 0;
 
+char aas_extension[64]; // allow to specify an extension for multiple AAS files per map
 
 //===========================================================================
 //
@@ -88,6 +90,8 @@
 // Parameter:			-
 // Returns:				-
 // Changes Globals:		-
+
+// Tobias FIXME: this creates test._b0aas instead of test_b0.aas! This has always been the case afaik, at least in RtCW
 //===========================================================================
 void AASOuputFile(quakefile_t *qf, char *outputpath, char *filename)
 {
@@ -100,6 +104,10 @@
 		//append the bsp file base
 		AppendPathSeperator(filename, MAX_PATH);
 		ExtractFileBase(qf->origname, &filename[strlen(filename)]);
+
+		// Ridah, add extension
+		strcat( filename, aas_extension );
+		// done.
 		//append .aas
 		strcat(filename, ".aas");
 		return;
@@ -120,6 +128,10 @@
 		if (access(filename, 0x04)) CreatePath(filename);
 		//append the bsp file base
 		ExtractFileBase(qf->origname, &filename[strlen(filename)]);
+
+		// Ridah, add extension
+		strcat( filename, aas_extension );
+		// done.
 		//append .aas
 		strcat(filename, ".aas");
 	} //end if
@@ -131,6 +143,10 @@
 		{
 			filename[strlen(filename)-1] = '\0';
 		} //end while
+
+		// Ridah, add extension
+		strcat( filename, aas_extension );
+		// done.
 		strcat(filename, "aas");
 	} //end else
 } //end of the function AASOutputFile
@@ -279,7 +295,14 @@
 	char filename[MAX_PATH] = "unknown";
 	quakefile_t *qfiles = NULL, *qf;
 	double start_time;
+	// Ridah, allow to specify an extension for multiple AAS files per map
+	int has_ext = 0;
+	// done.
 
+	// Ridah, set the world pointer up for reachabilities
+	aasworld = aasworlds;
+	AAS_SetWorldPointer( &( *aasworld ) );
+	// done.
 	myargc = argc;
 	myargv = argv;
 
@@ -497,6 +520,20 @@
 			comp = COMP_AASOPTIMIZE;
 			qfiles = GetArgumentFiles(argc, argv, &i, "aas");
 		} //end else if
+		else if ( !stricmp( argv[i], "-writeaasmap" ) ) {
+			writeaasmap = true;
+			Log_Print( "writeaasmap = true\n" );
+		}
+		// Ridah, allow to specify an extension for multiple AAS files per map
+		else if ( !stricmp( argv[i], "-ext" ) ) {
+			if ( i + 1 >= argc ) {
+				i = 0; break;
+			}
+			strcpy( aas_extension, argv[++i] );
+			has_ext = 1;
+
+		} //end else if
+		  // done.
 		else
 		{
 			Log_Print("unknown parameter %s\n", argv[i]);
@@ -734,6 +771,7 @@
 			"   forcesidesvisible                    = force all sides to be visible\n"
 			"   scoutreach                           = calculate scout reachabilities\n"
 #endif
+			"   writeaasmap                          = write the map the AI sees\n"
 /*			"   noweld     = disables weld\n"
 			"   noshare    = disables sharing\n"
 			"   notjunc    = disables juncs\n"
Index: code/bspc/leakfile.c
===================================================================
--- code/bspc/leakfile.c	(revision 1306)
+++ code/bspc/leakfile.c	(working copy)
@@ -76,8 +76,8 @@
 	while (node->occupied > 1)
 	{
 		int			next;
-		portal_t	*p, *nextportal;
-		node_t		*nextnode;
+		portal_t    *p, *nextportal = NULL; // TTimo: init
+		node_t      *nextnode = NULL; // TTimo: init
 		int			s;
 
 		nextportal = NULL;
Index: code/bspc/map_q3.c
===================================================================
--- code/bspc/map_q3.c	(revision 1306)
+++ code/bspc/map_q3.c	(working copy)
@@ -361,7 +361,22 @@
 
 //	b->contents = Q3_BrushContents(b);
 	//
+	// Ridah, CONTENTS_MOSTERCLIP should prevent AAS from being created, but not clip players/AI in the game
+	if ( b->contents & CONTENTS_MONSTERCLIP ) {
+		b->contents |= CONTENTS_PLAYERCLIP;
+	}
 
+	// func_explosive's not solid
+	if ( !strcmp( "func_explosive", ValueForKey( &entities[b->entitynum], "classname" ) ) ||
+		 !strcmp( "func_invisible_user", ValueForKey( &entities[b->entitynum], "classname" ) ) ||
+		 !strcmp( "script_mover", ValueForKey( &entities[b->entitynum], "classname" ) ) ||
+		 !strcmp( "func_static", ValueForKey( &entities[b->entitynum], "classname" ) ) ) {
+		Log_Print( "Ignoring %s brush..\n", ValueForKey( &entities[b->entitynum], "classname" ) );
+		b->numsides = 0;
+		b->contents = 0;
+		return;
+	}
+
 	if (BrushExists(b))
 	{
 		c_squattbrushes++;
@@ -741,6 +756,13 @@
 		PrintContents(mapbrushes[i].contents);
 		Log_Print("\n");
 	} //end for*/
+	if ( writeaasmap ) {
+		char name[MAX_QPATH];
+		strncpy( name, qf->filename, sizeof( name ) );
+		COM_StripExtension(name, name, sizeof(name)); // Toias CHECK
+		strcat( name, "_aas.map" );
+		WriteMapFile( name );
+	}
 } //end of the function Q3_LoadMapFromBSP
 //===========================================================================
 //
Index: code/bspc/portals.c
===================================================================
--- code/bspc/portals.c	(revision 1306)
+++ code/bspc/portals.c	(working copy)
@@ -415,8 +415,8 @@
 	portal_t	*new_portal, *p;
 	winding_t	*w;
 	vec3_t		normal;
-	float		dist;
-	int			side;
+	float		dist = 0;       // TTimo: init
+	int			side = 0;
 
 	w = BaseWindingForNode (node);
 
@@ -485,7 +485,7 @@
 {
 	portal_t	*p, *next_portal, *new_portal;
 	node_t *f, *b, *other_node;
-	int side;
+	int side = 0; // TTimo: init
 	plane_t *plane;
 	winding_t *frontwinding, *backwinding;
 
Index: code/bspc/q3files.h
===================================================================
--- code/bspc/q3files.h	(revision 1308)
+++ code/bspc/q3files.h	(working copy)
@@ -51,7 +51,8 @@
 PCX files are used for 8 bit images
 
 ========================================================================
-* 
+*/
+/*
 
 typedef struct {
     char	manufacturer;
@@ -77,7 +78,8 @@
 TGA files are used for 24/32 bit images
 
 ========================================================================
-* 
+*/
+/*
 
 typedef struct _TargaHeader {
 	unsigned char 	id_length, colormap_type, image_type;
Index: code/bspc/qbsp.h
===================================================================
--- code/bspc/qbsp.h	(revision 1306)
+++ code/bspc/qbsp.h	(working copy)
@@ -225,7 +225,7 @@
 extern	qboolean cancelconversion;
 extern	qboolean noliquids;
 extern	qboolean capsule_collision;
-
+extern	qboolean writeaasmap;
 extern	float subdivide_size;
 extern	vec_t microvolume;
 
Index: code/game/g_local.h
===================================================================
--- code/game/g_local.h	(revision 1306)
+++ code/game/g_local.h	(working copy)
@@ -571,6 +571,7 @@
 int trap_BotGetSnapshotEntity(int clientNum, int sequence);
 int trap_BotGetServerCommand(int clientNum, char *message, int size);
 void trap_BotUserCommand(int client, usercmd_t *ucmd);
+void trap_AAS_SetCurrentWorld(int index);
 int trap_AAS_BBoxAreas(vec3_t absmins, vec3_t absmaxs, int *areas, int maxareas);
 int trap_AAS_AreaInfo(int areanum, void /*struct aas_areainfo_s*/ *info);
 void trap_AAS_EntityInfo(int entnum, void /*struct aas_entityinfo_s*/ *info);
Index: code/game/g_public.h
===================================================================
--- code/game/g_public.h	(revision 1306)
+++ code/game/g_public.h	(working copy)
@@ -188,7 +188,8 @@
 	BOTLIB_GET_CONSOLE_MESSAGE,	// (int client, char *message, int size);
 	BOTLIB_USER_COMMAND,		// (int client, usercmd_t *ucmd);
 
-	BOTLIB_AAS_INITIALIZED = 300,
+	BOTLIB_AAS_SETCURRENTWORLD = 300,
+	BOTLIB_AAS_INITIALIZED,
 	BOTLIB_AAS_TIME,
 	BOTLIB_AAS_AREA_INFO,
 	BOTLIB_AAS_ENTITY_INFO,
Index: code/game/g_syscalls.asm
===================================================================
--- code/game/g_syscalls.asm	(revision 1306)
+++ code/game/g_syscalls.asm	(working copy)
@@ -82,29 +82,30 @@
 equ trap_BotGetServerCommand				-210
 equ trap_BotUserCommand						-211
 
-equ trap_AAS_Initialized					-301
-equ trap_AAS_Time							-302
-equ trap_AAS_AreaInfo						-303
-equ trap_AAS_EntityInfo						-304
-equ trap_AAS_PresenceTypeBoundingBox		-305
-equ trap_AAS_BBoxAreas						-306
-equ trap_AAS_TraceAreas						-307
-equ trap_AAS_AreaCenter						-308
-equ trap_AAS_PointAreaNum					-309
-equ trap_AAS_PointContents					-310
-equ trap_AAS_PointReachabilityAreaIndex		-311
-equ trap_AAS_AreaReachability				-312
-equ trap_AAS_AreaTravelTimeToGoalArea		-313
-equ trap_AAS_EnableRoutingArea				-314
-equ trap_AAS_PredictClientMovement			-315
-equ trap_AAS_PredictRoute					-316
-equ trap_AAS_AlternativeRouteGoals			-317
-equ trap_AAS_ValueForBSPEpairKey			-318
-equ trap_AAS_VectorForBSPEpairKey			-319
-equ trap_AAS_FloatForBSPEpairKey			-320
-equ trap_AAS_IntForBSPEpairKey				-321
-equ trap_AAS_NextBSPEntity					-322
-equ trap_AAS_Swimming						-323
+equ trap_AAS_SetCurrentWorld				-301
+equ trap_AAS_Initialized					-302
+equ trap_AAS_Time							-303
+equ trap_AAS_AreaInfo						-304
+equ trap_AAS_EntityInfo						-305
+equ trap_AAS_PresenceTypeBoundingBox		-306
+equ trap_AAS_BBoxAreas						-307
+equ trap_AAS_TraceAreas						-308
+equ trap_AAS_AreaCenter						-309
+equ trap_AAS_PointAreaNum					-310
+equ trap_AAS_PointContents					-311
+equ trap_AAS_PointReachabilityAreaIndex		-312
+equ trap_AAS_AreaReachability				-313
+equ trap_AAS_AreaTravelTimeToGoalArea		-314
+equ trap_AAS_EnableRoutingArea				-315
+equ trap_AAS_PredictClientMovement			-316
+equ trap_AAS_PredictRoute					-317
+equ trap_AAS_AlternativeRouteGoals			-318
+equ trap_AAS_ValueForBSPEpairKey			-319
+equ trap_AAS_VectorForBSPEpairKey			-320
+equ trap_AAS_FloatForBSPEpairKey			-321
+equ trap_AAS_IntForBSPEpairKey				-322
+equ trap_AAS_NextBSPEntity					-323
+equ trap_AAS_Swimming						-324
 
 equ trap_EA_GetInput						-401
 equ trap_EA_ResetInput						-402
Index: code/game/g_syscalls.c
===================================================================
--- code/game/g_syscalls.c	(revision 1306)
+++ code/game/g_syscalls.c	(working copy)
@@ -676,6 +676,17 @@
 
 /*
 =======================================================================================================================================
+trap_AAS_SetCurrentWorld
+
+Multiple AAS files.
+=======================================================================================================================================
+*/
+void trap_AAS_SetCurrentWorld(int index) {
+	syscall(BOTLIB_AAS_SETCURRENTWORLD, index);
+}
+
+/*
+=======================================================================================================================================
 trap_AAS_Initialized
 =======================================================================================================================================
 */
Index: code/server/sv_game.c
===================================================================
--- code/server/sv_game.c	(revision 1306)
+++ code/server/sv_game.c	(working copy)
@@ -536,6 +536,9 @@
 			}
 
 			return 0;
+		case BOTLIB_AAS_SETCURRENTWORLD:
+			botlib_export->aas.AAS_SetCurrentWorld(args[1]);
+			return 0;
 		case BOTLIB_AAS_INITIALIZED:
 			return botlib_export->aas.AAS_Initialized();
 		case BOTLIB_AAS_TIME:
